
snake.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001ac  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .user_data    00000000  081e0000  081e0000  00020574  2**0
                  CONTENTS
  2 .text         000099b8  080001ac  080001ac  000101ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00001960  08009b64  08009b64  00019b64  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  0800b4c4  0800b4c4  0001b4c4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  0800b4c8  0800b4c8  0001b4c8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000574  20000000  0800b4cc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .ccmram       00000000  10000000  10000000  00020574  2**0
                  CONTENTS
  8 .bss          00021e9c  20000574  20000574  00020574  2**2
                  ALLOC
  9 ._user_heap_stack 00002400  20022410  20022410  00020574  2**0
                  ALLOC
 10 .ARM.attributes 0000002e  00000000  00000000  00020574  2**0
                  CONTENTS, READONLY
 11 .debug_line   00010ba0  00000000  00000000  000205a2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_info   000505bd  00000000  00000000  00031142  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 0000d313  00000000  00000000  000816ff  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00002540  00000000  00000000  0008ea18  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00002a50  00000000  00000000  00090f58  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000b42a  00000000  00000000  000939a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      00000100  00000000  00000000  0009edd2  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00005f98  00000000  00000000  0009eed4  2**2
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_loc    0001d9ec  00000000  00000000  000a4e6c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001ac <__do_global_dtors_aux>:
 80001ac:	b510      	push	{r4, lr}
 80001ae:	4c05      	ldr	r4, [pc, #20]	; (80001c4 <__do_global_dtors_aux+0x18>)
 80001b0:	7823      	ldrb	r3, [r4, #0]
 80001b2:	b933      	cbnz	r3, 80001c2 <__do_global_dtors_aux+0x16>
 80001b4:	4b04      	ldr	r3, [pc, #16]	; (80001c8 <__do_global_dtors_aux+0x1c>)
 80001b6:	b113      	cbz	r3, 80001be <__do_global_dtors_aux+0x12>
 80001b8:	4804      	ldr	r0, [pc, #16]	; (80001cc <__do_global_dtors_aux+0x20>)
 80001ba:	f3af 8000 	nop.w
 80001be:	2301      	movs	r3, #1
 80001c0:	7023      	strb	r3, [r4, #0]
 80001c2:	bd10      	pop	{r4, pc}
 80001c4:	20000574 	.word	0x20000574
 80001c8:	00000000 	.word	0x00000000
 80001cc:	08009b4c 	.word	0x08009b4c

080001d0 <frame_dummy>:
 80001d0:	b508      	push	{r3, lr}
 80001d2:	4b03      	ldr	r3, [pc, #12]	; (80001e0 <frame_dummy+0x10>)
 80001d4:	b11b      	cbz	r3, 80001de <frame_dummy+0xe>
 80001d6:	4903      	ldr	r1, [pc, #12]	; (80001e4 <frame_dummy+0x14>)
 80001d8:	4803      	ldr	r0, [pc, #12]	; (80001e8 <frame_dummy+0x18>)
 80001da:	f3af 8000 	nop.w
 80001de:	bd08      	pop	{r3, pc}
 80001e0:	00000000 	.word	0x00000000
 80001e4:	20000578 	.word	0x20000578
 80001e8:	08009b4c 	.word	0x08009b4c

080001ec <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 80001ec:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000224 <LoopFillZerobss+0x14>
 
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80001f0:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80001f2:	e003      	b.n	80001fc <LoopCopyDataInit>

080001f4 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80001f4:	4b0c      	ldr	r3, [pc, #48]	; (8000228 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80001f6:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80001f8:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80001fa:	3104      	adds	r1, #4

080001fc <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80001fc:	480b      	ldr	r0, [pc, #44]	; (800022c <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80001fe:	4b0c      	ldr	r3, [pc, #48]	; (8000230 <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 8000200:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 8000202:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 8000204:	d3f6      	bcc.n	80001f4 <CopyDataInit>
  ldr  r2, =_sbss
 8000206:	4a0b      	ldr	r2, [pc, #44]	; (8000234 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 8000208:	e002      	b.n	8000210 <LoopFillZerobss>

0800020a <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 800020a:	2300      	movs	r3, #0
  str  r3, [r2], #4
 800020c:	f842 3b04 	str.w	r3, [r2], #4

08000210 <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000210:	4b09      	ldr	r3, [pc, #36]	; (8000238 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 8000212:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000214:	d3f9      	bcc.n	800020a <FillZerobss>

/* Call the clock system intitialization function.*/
  bl  SystemInit   
 8000216:	f001 fbfb 	bl	8001a10 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800021a:	f009 f8ad 	bl	8009378 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800021e:	f000 fac1 	bl	80007a4 <main>
  bx  lr    
 8000222:	4770      	bx	lr

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler: 
  ldr   sp, =_estack       /* set stack pointer */
 8000224:	20030000 	.word	0x20030000
/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
  b  LoopCopyDataInit

CopyDataInit:
  ldr  r3, =_sidata
 8000228:	0800b4cc 	.word	0x0800b4cc
  ldr  r3, [r3, r1]
  str  r3, [r0, r1]
  adds  r1, r1, #4
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 800022c:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 8000230:	20000574 	.word	0x20000574
  adds  r2, r0, r1
  cmp  r2, r3
  bcc  CopyDataInit
  ldr  r2, =_sbss
 8000234:	20000574 	.word	0x20000574
FillZerobss:
  movs  r3, #0
  str  r3, [r2], #4
    
LoopFillZerobss:
  ldr  r3, = _ebss
 8000238:	20022410 	.word	0x20022410

0800023c <ADC_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 800023c:	e7fe      	b.n	800023c <ADC_IRQHandler>
	...

08000240 <boardInit>:
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  HAL_I2C_Init(&hi2c3);
}

void boardInit(void)
{
 8000240:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8000244:	b096      	sub	sp, #88	; 0x58

  /* Initialize the Touch screen */
  BSP_TS_Init(240, 320);

  /* Enable Back up SRAM */
  __HAL_RCC_BKPSRAM_CLK_ENABLE();
 8000246:	2400      	movs	r4, #0
 8000248:	4d50      	ldr	r5, [pc, #320]	; (800038c <boardInit+0x14c>)
  HAL_I2C_Init(&hi2c3);
}

void boardInit(void)
{
  HAL_Init();
 800024a:	f001 fc1b 	bl	8001a84 <HAL_Init>
}

static void BSP_Config(void)
{
  /* Initializes the SDRAM device */
  BSP_SDRAM_Init();
 800024e:	f001 fac9 	bl	80017e4 <BSP_SDRAM_Init>

  /* Initialize the Touch screen */
  BSP_TS_Init(240, 320);
 8000252:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8000256:	20f0      	movs	r0, #240	; 0xf0
 8000258:	f001 fbb8 	bl	80019cc <BSP_TS_Init>

  /* Enable Back up SRAM */
  __HAL_RCC_BKPSRAM_CLK_ENABLE();
 800025c:	9403      	str	r4, [sp, #12]
 800025e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000260:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8000264:	632b      	str	r3, [r5, #48]	; 0x30
 8000266:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000268:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 800026c:	9303      	str	r3, [sp, #12]
 800026e:	9b03      	ldr	r3, [sp, #12]

  /* Enable the CRC Module */
  __HAL_RCC_CRC_CLK_ENABLE();
 8000270:	9404      	str	r4, [sp, #16]
 8000272:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000274:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8000278:	632b      	str	r3, [r5, #48]	; 0x30
 800027a:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800027c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8000280:	9304      	str	r3, [sp, #16]
 8000282:	9b04      	ldr	r3, [sp, #16]
static void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct;
  RCC_ClkInitTypeDef RCC_ClkInitStruct;

  __PWR_CLK_ENABLE();
 8000284:	9401      	str	r4, [sp, #4]
 8000286:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8000288:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800028c:	642b      	str	r3, [r5, #64]	; 0x40
 800028e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8000290:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000294:	9301      	str	r3, [sp, #4]
 8000296:	9b01      	ldr	r3, [sp, #4]

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 8000298:	4b3d      	ldr	r3, [pc, #244]	; (8000390 <boardInit+0x150>)
 800029a:	9402      	str	r4, [sp, #8]
 800029c:	681a      	ldr	r2, [r3, #0]
 800029e:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 80002a2:	601a      	str	r2, [r3, #0]
 80002a4:	681b      	ldr	r3, [r3, #0]
 80002a6:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 80002aa:	9302      	str	r3, [sp, #8]
 80002ac:	9b02      	ldr	r3, [sp, #8]

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 80002ae:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 80002b2:	9311      	str	r3, [sp, #68]	; 0x44
  RCC_OscInitStruct.PLL.PLLM = 8;
 80002b4:	2308      	movs	r3, #8
 80002b6:	9312      	str	r3, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 336;
 80002b8:	f44f 73a8 	mov.w	r3, #336	; 0x150

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80002bc:	2601      	movs	r6, #1
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80002be:	2702      	movs	r7, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
 80002c0:	9313      	str	r3, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80002c2:	a80a      	add	r0, sp, #40	; 0x28
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
 80002c4:	2307      	movs	r3, #7
 80002c6:	9315      	str	r3, [sp, #84]	; 0x54

  __PWR_CLK_ENABLE();

  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 80002c8:	960a      	str	r6, [sp, #40]	; 0x28
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80002ca:	960b      	str	r6, [sp, #44]	; 0x2c
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80002cc:	9710      	str	r7, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
 80002ce:	9714      	str	r7, [sp, #80]	; 0x50
  RCC_OscInitStruct.PLL.PLLQ = 7;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80002d0:	f002 fda2 	bl	8002e18 <HAL_RCC_OscConfig>

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80002d4:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 80002d8:	f04f 080f 	mov.w	r8, #15
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
 80002dc:	9308      	str	r3, [sp, #32]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 80002de:	2105      	movs	r1, #5
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80002e0:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 80002e4:	a805      	add	r0, sp, #20
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
 80002e6:	9309      	str	r3, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
  RCC_OscInitStruct.PLL.PLLQ = 7;
  HAL_RCC_OscConfig(&RCC_OscInitStruct);

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
 80002e8:	f8cd 8014 	str.w	r8, [sp, #20]
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 80002ec:	9706      	str	r7, [sp, #24]
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 80002ee:	9407      	str	r4, [sp, #28]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
  HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
 80002f0:	f002 ff38 	bl	8003164 <HAL_RCC_ClockConfig>

  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80002f4:	2004      	movs	r0, #4
 80002f6:	f001 fc63 	bl	8001bc0 <HAL_SYSTICK_CLKSourceConfig>

  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 80002fa:	4622      	mov	r2, r4
 80002fc:	4641      	mov	r1, r8
 80002fe:	f04f 30ff 	mov.w	r0, #4294967295
 8000302:	f001 fc07 	bl	8001b14 <HAL_NVIC_SetPriority>
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
 8000306:	9400      	str	r4, [sp, #0]
 8000308:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800030a:	4333      	orrs	r3, r6
 800030c:	632b      	str	r3, [r5, #48]	; 0x30
 800030e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000310:	4033      	ands	r3, r6
 8000312:	9300      	str	r3, [sp, #0]
 8000314:	9b00      	ldr	r3, [sp, #0]
  __GPIOG_CLK_ENABLE();
 8000316:	9405      	str	r4, [sp, #20]
 8000318:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800031a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800031e:	632b      	str	r3, [r5, #48]	; 0x30
 8000320:	6b2b      	ldr	r3, [r5, #48]	; 0x30

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13 | GPIO_PIN_14, GPIO_PIN_RESET);
 8000322:	f5a5 5500 	sub.w	r5, r5, #8192	; 0x2000
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
  __GPIOG_CLK_ENABLE();
 8000326:	f003 0340 	and.w	r3, r3, #64	; 0x40

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13 | GPIO_PIN_14, GPIO_PIN_RESET);
 800032a:	4622      	mov	r2, r4
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
  __GPIOG_CLK_ENABLE();
 800032c:	9305      	str	r3, [sp, #20]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13 | GPIO_PIN_14, GPIO_PIN_RESET);
 800032e:	4628      	mov	r0, r5
 8000330:	f44f 41c0 	mov.w	r1, #24576	; 0x6000
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __GPIOA_CLK_ENABLE();
  __GPIOG_CLK_ENABLE();
 8000334:	9b05      	ldr	r3, [sp, #20]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13 | GPIO_PIN_14, GPIO_PIN_RESET);
 8000336:	f001 fedd 	bl	80020f4 <HAL_GPIO_WritePin>
  /*Configure GPIO pins : PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800033a:	a90a      	add	r1, sp, #40	; 0x28

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13 | GPIO_PIN_14, GPIO_PIN_RESET);

  /*Configure GPIO pins : PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14;
 800033c:	f44f 43c0 	mov.w	r3, #24576	; 0x6000
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8000340:	4628      	mov	r0, r5

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13 | GPIO_PIN_14, GPIO_PIN_RESET);

  /*Configure GPIO pins : PG13 PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_13 | GPIO_PIN_14;
 8000342:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000344:	960b      	str	r6, [sp, #44]	; 0x2c
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000346:	940c      	str	r4, [sp, #48]	; 0x30
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 8000348:	940d      	str	r4, [sp, #52]	; 0x34
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800034a:	f001 fd3b 	bl	8001dc4 <HAL_GPIO_Init>
{
  HAL_Init();
  BSP_Config();
  SystemClock_Config();
  MX_GPIO_Init();
  uartInit();
 800034e:	f000 f93f 	bl	80005d0 <uartInit>
  xdev_out(sendConsole);
 8000352:	4b10      	ldr	r3, [pc, #64]	; (8000394 <boardInit+0x154>)
 8000354:	4a10      	ldr	r2, [pc, #64]	; (8000398 <boardInit+0x158>)
 8000356:	601a      	str	r2, [r3, #0]

static void MX_RNG_Init(void)
{
  RNG_HandleTypeDef hrng;
  hrng.Instance = RNG;
  HAL_RNG_Init(&hrng);
 8000358:	a80a      	add	r0, sp, #40	; 0x28
}

static void MX_RNG_Init(void)
{
  RNG_HandleTypeDef hrng;
  hrng.Instance = RNG;
 800035a:	4b10      	ldr	r3, [pc, #64]	; (800039c <boardInit+0x15c>)
 800035c:	930a      	str	r3, [sp, #40]	; 0x28
  HAL_RNG_Init(&hrng);
 800035e:	f003 f94a 	bl	80035f6 <HAL_RNG_Init>
}

static void MX_I2C3_Init(void)
{
  hi2c3.Instance = I2C3;
 8000362:	480f      	ldr	r0, [pc, #60]	; (80003a0 <boardInit+0x160>)
  hi2c3.Init.ClockSpeed = 400000;
 8000364:	4a0f      	ldr	r2, [pc, #60]	; (80003a4 <boardInit+0x164>)
 8000366:	4b10      	ldr	r3, [pc, #64]	; (80003a8 <boardInit+0x168>)
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
 8000368:	6084      	str	r4, [r0, #8]
}

static void MX_I2C3_Init(void)
{
  hi2c3.Instance = I2C3;
  hi2c3.Init.ClockSpeed = 400000;
 800036a:	e880 000c 	stmia.w	r0, {r2, r3}
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c3.Init.OwnAddress1 = 0;
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 800036e:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8000372:	6103      	str	r3, [r0, #16]
static void MX_I2C3_Init(void)
{
  hi2c3.Instance = I2C3;
  hi2c3.Init.ClockSpeed = 400000;
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c3.Init.OwnAddress1 = 0;
 8000374:	60c4      	str	r4, [r0, #12]
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8000376:	6144      	str	r4, [r0, #20]
  hi2c3.Init.OwnAddress2 = 0;
 8000378:	6184      	str	r4, [r0, #24]
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 800037a:	61c4      	str	r4, [r0, #28]
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 800037c:	6204      	str	r4, [r0, #32]
  HAL_I2C_Init(&hi2c3);
 800037e:	f002 f885 	bl	800248c <HAL_I2C_Init>
  uartInit();
  xdev_out(sendConsole);
  MX_RNG_Init();
  MX_I2C3_Init();

  accInit();
 8000382:	f000 f94b 	bl	800061c <accInit>
}
 8000386:	b016      	add	sp, #88	; 0x58
 8000388:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800038c:	40023800 	.word	0x40023800
 8000390:	40007000 	.word	0x40007000
 8000394:	20002184 	.word	0x20002184
 8000398:	0800056d 	.word	0x0800056d
 800039c:	50060800 	.word	0x50060800
 80003a0:	200020e8 	.word	0x200020e8
 80003a4:	40005c00 	.word	0x40005c00
 80003a8:	00061a80 	.word	0x00061a80

080003ac <show>:
static uint16_t width;
static uint16_t height;
static uint16_t cols, rows;

static void show(snake_t *snake)
{
 80003ac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  do
    {
      spotFound = true;

      x = (rand() % cols) * food.size;
 80003b0:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8000474 <show+0xc8>
 80003b4:	4f29      	ldr	r7, [pc, #164]	; (800045c <show+0xb0>)
static uint16_t width;
static uint16_t height;
static uint16_t cols, rows;

static void show(snake_t *snake)
{
 80003b6:	4606      	mov	r6, r0

  do
    {
      spotFound = true;

      x = (rand() % cols) * food.size;
 80003b8:	f009 f832 	bl	8009420 <rand>
 80003bc:	f8b8 3000 	ldrh.w	r3, [r8]
 80003c0:	fb90 f4f3 	sdiv	r4, r0, r3
 80003c4:	fb04 0013 	mls	r0, r4, r3, r0
 80003c8:	783c      	ldrb	r4, [r7, #0]
 80003ca:	f8df 9090 	ldr.w	r9, [pc, #144]	; 800045c <show+0xb0>
 80003ce:	fb14 f400 	smulbb	r4, r4, r0
      y = (rand() % rows) * food.size;
 80003d2:	f009 f825 	bl	8009420 <rand>
 80003d6:	4b22      	ldr	r3, [pc, #136]	; (8000460 <show+0xb4>)
 80003d8:	881b      	ldrh	r3, [r3, #0]
 80003da:	fb90 f5f3 	sdiv	r5, r0, r3
 80003de:	fb05 0013 	mls	r0, r5, r3, r0
 80003e2:	783d      	ldrb	r5, [r7, #0]

  do
    {
      spotFound = true;

      x = (rand() % cols) * food.size;
 80003e4:	b2a4      	uxth	r4, r4
      y = (rand() % rows) * food.size;
 80003e6:	fb15 f500 	smulbb	r5, r5, r0

      xprintf("x: %d\n", x);
 80003ea:	4621      	mov	r1, r4
 80003ec:	481d      	ldr	r0, [pc, #116]	; (8000464 <show+0xb8>)
  do
    {
      spotFound = true;

      x = (rand() % cols) * food.size;
      y = (rand() % rows) * food.size;
 80003ee:	b2ad      	uxth	r5, r5

      xprintf("x: %d\n", x);
 80003f0:	f000 fcc5 	bl	8000d7e <xprintf>
      xprintf("y: %d\n", y);
 80003f4:	4629      	mov	r1, r5
 80003f6:	481c      	ldr	r0, [pc, #112]	; (8000468 <show+0xbc>)
 80003f8:	f000 fcc1 	bl	8000d7e <xprintf>

      // sprawdz czy wylosowane wspolrzedne jedzenia nie pokrywaja sie z cialem snejka
      // jesli tak, to ponow losowanie
      for (i = 0; i <= snake->length; i++)
 80003fc:	f04f 0a00 	mov.w	sl, #0
  uint16_t x, y, i;
  bool spotFound;

  do
    {
      spotFound = true;
 8000400:	2201      	movs	r2, #1
      xprintf("x: %d\n", x);
      xprintf("y: %d\n", y);

      // sprawdz czy wylosowane wspolrzedne jedzenia nie pokrywaja sie z cialem snejka
      // jesli tak, to ponow losowanie
      for (i = 0; i <= snake->length; i++)
 8000402:	7831      	ldrb	r1, [r6, #0]
 8000404:	fa1f f38a 	uxth.w	r3, sl
 8000408:	4299      	cmp	r1, r3
 800040a:	d310      	bcc.n	800042e <show+0x82>
 800040c:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
        {
          if (snake->tail[i].x0 == x && snake->tail[i].y0 == y)
 8000410:	f9b3 1010 	ldrsh.w	r1, [r3, #16]
 8000414:	428c      	cmp	r4, r1
 8000416:	d107      	bne.n	8000428 <show+0x7c>
 8000418:	f9b3 3012 	ldrsh.w	r3, [r3, #18]
 800041c:	429d      	cmp	r5, r3
 800041e:	d103      	bne.n	8000428 <show+0x7c>
            {
              xprintf("Overlap\n");
 8000420:	4812      	ldr	r0, [pc, #72]	; (800046c <show+0xc0>)
 8000422:	f000 fcac 	bl	8000d7e <xprintf>
              spotFound = false;
 8000426:	2200      	movs	r2, #0
 8000428:	f10a 0a01 	add.w	sl, sl, #1
 800042c:	e7e9      	b.n	8000402 <show+0x56>
            }
        }
    }
  while (!spotFound);
 800042e:	2a00      	cmp	r2, #0
 8000430:	d0c2      	beq.n	80003b8 <show+0xc>

  food.pos.x0 = x;
  food.pos.y0 = y;
  food.pos.x1 = x + food.size;
 8000432:	f899 0000 	ldrb.w	r0, [r9]
            }
        }
    }
  while (!spotFound);

  food.pos.x0 = x;
 8000436:	f8a9 4002 	strh.w	r4, [r9, #2]
  food.pos.y0 = y;
 800043a:	f8a9 5004 	strh.w	r5, [r9, #4]
  food.pos.x1 = x + food.size;
 800043e:	4404      	add	r4, r0
  food.pos.y1 = y + food.size;
 8000440:	4405      	add	r5, r0

  GUI_SetColor(GUI_GREEN);
 8000442:	f44f 407f 	mov.w	r0, #65280	; 0xff00
    }
  while (!spotFound);

  food.pos.x0 = x;
  food.pos.y0 = y;
  food.pos.x1 = x + food.size;
 8000446:	f8a9 4006 	strh.w	r4, [r9, #6]
  food.pos.y1 = y + food.size;
 800044a:	f8a9 5008 	strh.w	r5, [r9, #8]

  GUI_SetColor(GUI_GREEN);
 800044e:	f007 f827 	bl	80074a0 <GUI_SetColor>
  GUI_FillRectEx(&food.pos);
 8000452:	4807      	ldr	r0, [pc, #28]	; (8000470 <show+0xc4>)
}
 8000454:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  food.pos.y0 = y;
  food.pos.x1 = x + food.size;
  food.pos.y1 = y + food.size;

  GUI_SetColor(GUI_GREEN);
  GUI_FillRectEx(&food.pos);
 8000458:	f007 b8e0 	b.w	800761c <GUI_FillRectEx>
 800045c:	20000594 	.word	0x20000594
 8000460:	200005a4 	.word	0x200005a4
 8000464:	08009baf 	.word	0x08009baf
 8000468:	08009bbc 	.word	0x08009bbc
 800046c:	08009b64 	.word	0x08009b64
 8000470:	20000596 	.word	0x20000596
 8000474:	20000592 	.word	0x20000592

08000478 <foodInit>:
}

food_t *foodInit(uint8_t size)
{
 8000478:	b538      	push	{r3, r4, r5, lr}
  food.show = show;
 800047a:	4c0b      	ldr	r4, [pc, #44]	; (80004a8 <foodInit+0x30>)
 800047c:	4b0b      	ldr	r3, [pc, #44]	; (80004ac <foodInit+0x34>)
 800047e:	60e3      	str	r3, [r4, #12]
  food.size = size;
 8000480:	7020      	strb	r0, [r4, #0]

  width = LCD_GetXSize();
 8000482:	f006 faaf 	bl	80069e4 <LCD_GetXSize>
 8000486:	4d0a      	ldr	r5, [pc, #40]	; (80004b0 <foodInit+0x38>)
 8000488:	8028      	strh	r0, [r5, #0]
  height = LCD_GetYSize();
 800048a:	f006 fab3 	bl	80069f4 <LCD_GetYSize>

  cols = width / food.size;
 800048e:	4909      	ldr	r1, [pc, #36]	; (80004b4 <foodInit+0x3c>)
 8000490:	7822      	ldrb	r2, [r4, #0]
 8000492:	882b      	ldrh	r3, [r5, #0]
 8000494:	fb93 f3f2 	sdiv	r3, r3, r2
 8000498:	800b      	strh	r3, [r1, #0]
  rows = height / food.size;
 800049a:	4b07      	ldr	r3, [pc, #28]	; (80004b8 <foodInit+0x40>)
 800049c:	b280      	uxth	r0, r0
 800049e:	fb90 f0f2 	sdiv	r0, r0, r2
 80004a2:	8018      	strh	r0, [r3, #0]

  return &food;
}
 80004a4:	4620      	mov	r0, r4
 80004a6:	bd38      	pop	{r3, r4, r5, pc}
 80004a8:	20000594 	.word	0x20000594
 80004ac:	080003ad 	.word	0x080003ad
 80004b0:	20000590 	.word	0x20000590
 80004b4:	20000592 	.word	0x20000592
 80004b8:	200005a4 	.word	0x200005a4

080004bc <guiInit>:
#include "guiLib.h"
#include <stdlib.h>
#include "xprintf.h"

void guiInit(void)
{
 80004bc:	b508      	push	{r3, lr}
  WM_SetCreateFlags(WM_CF_MEMDEV);
 80004be:	2004      	movs	r0, #4
 80004c0:	f004 f8e0 	bl	8004684 <WM_SetCreateFlags>
  // WM_MULTIBUF_Enable(1);
  GUI_Init();
 80004c4:	f007 fae4 	bl	8007a90 <GUI_Init>

  GUI_SetBkColor(GUI_WHITE);
 80004c8:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 80004cc:	f006 ffe6 	bl	800749c <GUI_SetBkColor>
  GUI_Clear();
}
 80004d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  WM_SetCreateFlags(WM_CF_MEMDEV);
  // WM_MULTIBUF_Enable(1);
  GUI_Init();

  GUI_SetBkColor(GUI_WHITE);
  GUI_Clear();
 80004d4:	f007 baa2 	b.w	8007a1c <GUI_Clear>

080004d8 <endGameScreen>:
}

void endGameScreen(uint8_t score)
{
 80004d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80004da:	b089      	sub	sp, #36	; 0x24
 80004dc:	4607      	mov	r7, r0
  int x = LCD_GetXSize() / 2;
 80004de:	f006 fa81 	bl	80069e4 <LCD_GetXSize>
 80004e2:	2602      	movs	r6, #2
 80004e4:	fb90 f4f6 	sdiv	r4, r0, r6
  int y = LCD_GetYSize() / 2;
 80004e8:	f006 fa84 	bl	80069f4 <LCD_GetYSize>

  uint16_t xOffset = 80, yOffset = 50;

  GUI_RECT endR =
 80004ec:	b2a2      	uxth	r2, r4
 80004ee:	f1a2 0350 	sub.w	r3, r2, #80	; 0x50
}

void endGameScreen(uint8_t score)
{
  int x = LCD_GetXSize() / 2;
  int y = LCD_GetYSize() / 2;
 80004f2:	fb90 f5f6 	sdiv	r5, r0, r6

  uint16_t xOffset = 80, yOffset = 50;

  GUI_RECT endR =
 80004f6:	f8ad 3004 	strh.w	r3, [sp, #4]
 80004fa:	b2ab      	uxth	r3, r5
 80004fc:	f1a3 0132 	sub.w	r1, r3, #50	; 0x32
 8000500:	3250      	adds	r2, #80	; 0x50
 8000502:	3332      	adds	r3, #50	; 0x32
    .y0 = y - yOffset,
    .x1 = x + xOffset,
    .y1 = y + yOffset
  };

  GUI_SetColor(GUI_LIGHTGRAY);
 8000504:	4815      	ldr	r0, [pc, #84]	; (800055c <endGameScreen+0x84>)
  int x = LCD_GetXSize() / 2;
  int y = LCD_GetYSize() / 2;

  uint16_t xOffset = 80, yOffset = 50;

  GUI_RECT endR =
 8000506:	f8ad 300a 	strh.w	r3, [sp, #10]
 800050a:	f8ad 1006 	strh.w	r1, [sp, #6]
 800050e:	f8ad 2008 	strh.w	r2, [sp, #8]
    .y0 = y - yOffset,
    .x1 = x + xOffset,
    .y1 = y + yOffset
  };

  GUI_SetColor(GUI_LIGHTGRAY);
 8000512:	f006 ffc5 	bl	80074a0 <GUI_SetColor>
  GUI_FillRectEx(&endR);
 8000516:	a801      	add	r0, sp, #4
 8000518:	f007 f880 	bl	800761c <GUI_FillRectEx>


  GUI_SetColor(GUI_BLACK);
 800051c:	2000      	movs	r0, #0
 800051e:	f006 ffbf 	bl	80074a0 <GUI_SetColor>
  GUI_SetFont(&GUI_Font20_ASCII);
 8000522:	480f      	ldr	r0, [pc, #60]	; (8000560 <endGameScreen+0x88>)
 8000524:	f006 ffb0 	bl	8007488 <GUI_SetFont>
  GUI_SetTextMode(GUI_TM_TRANS);
 8000528:	4630      	mov	r0, r6
 800052a:	f006 ffa3 	bl	8007474 <GUI_SetTextMode>
  GUI_DispStringHCenterAt("GAME OVER", x, y - 35);
 800052e:	f1a5 0223 	sub.w	r2, r5, #35	; 0x23
 8000532:	4621      	mov	r1, r4
 8000534:	480b      	ldr	r0, [pc, #44]	; (8000564 <endGameScreen+0x8c>)
 8000536:	f007 f89f 	bl	8007678 <GUI_DispStringHCenterAt>
  char buf[20] = {0};
 800053a:	2214      	movs	r2, #20
 800053c:	2100      	movs	r1, #0
 800053e:	a803      	add	r0, sp, #12
 8000540:	f008 ff66 	bl	8009410 <memset>
  xsprintf(buf, "SCORE: %d", score);
 8000544:	463a      	mov	r2, r7
 8000546:	a803      	add	r0, sp, #12
 8000548:	4907      	ldr	r1, [pc, #28]	; (8000568 <endGameScreen+0x90>)
 800054a:	f000 fc25 	bl	8000d98 <xsprintf>
  GUI_DispStringHCenterAt(buf, x, y + 5);
 800054e:	1d6a      	adds	r2, r5, #5
 8000550:	4621      	mov	r1, r4
 8000552:	a803      	add	r0, sp, #12
 8000554:	f007 f890 	bl	8007678 <GUI_DispStringHCenterAt>

 8000558:	b009      	add	sp, #36	; 0x24
 800055a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800055c:	00d3d3d3 	.word	0x00d3d3d3
 8000560:	0800ac48 	.word	0x0800ac48
 8000564:	08009b6d 	.word	0x08009b6d
 8000568:	08009b77 	.word	0x08009b77

0800056c <sendConsole>:
volatile bool semaphore = false;
UART_HandleTypeDef huart1;
uint8_t rxChar = 0;

void sendConsole(char data)
{
 800056c:	b507      	push	{r0, r1, r2, lr}
 800056e:	a902      	add	r1, sp, #8
  HAL_UART_Transmit_IT(&huart1, (uint8_t *)&data, sizeof(uint8_t));
 8000570:	2201      	movs	r2, #1
volatile bool semaphore = false;
UART_HandleTypeDef huart1;
uint8_t rxChar = 0;

void sendConsole(char data)
{
 8000572:	f801 0d01 	strb.w	r0, [r1, #-1]!
  HAL_UART_Transmit_IT(&huart1, (uint8_t *)&data, sizeof(uint8_t));
 8000576:	4806      	ldr	r0, [pc, #24]	; (8000590 <sendConsole+0x24>)
 8000578:	f003 fb5c 	bl	8003c34 <HAL_UART_Transmit_IT>
  semaphore = true;
 800057c:	4b05      	ldr	r3, [pc, #20]	; (8000594 <sendConsole+0x28>)
 800057e:	2201      	movs	r2, #1
 8000580:	701a      	strb	r2, [r3, #0]
  while (semaphore);
 8000582:	781a      	ldrb	r2, [r3, #0]
 8000584:	2a00      	cmp	r2, #0
 8000586:	d1fc      	bne.n	8000582 <sendConsole+0x16>
}
 8000588:	b003      	add	sp, #12
 800058a:	f85d fb04 	ldr.w	pc, [sp], #4
 800058e:	bf00      	nop
 8000590:	2000213c 	.word	0x2000213c
 8000594:	200005a7 	.word	0x200005a7

08000598 <HAL_UART_RxCpltCallback>:

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART1)
 8000598:	6802      	ldr	r2, [r0, #0]
 800059a:	4b04      	ldr	r3, [pc, #16]	; (80005ac <HAL_UART_RxCpltCallback+0x14>)
 800059c:	429a      	cmp	r2, r3
 800059e:	d104      	bne.n	80005aa <HAL_UART_RxCpltCallback+0x12>
    {
      HAL_UART_Receive_IT(&huart1, &rxChar, 1);
 80005a0:	2201      	movs	r2, #1
 80005a2:	4903      	ldr	r1, [pc, #12]	; (80005b0 <HAL_UART_RxCpltCallback+0x18>)
 80005a4:	4803      	ldr	r0, [pc, #12]	; (80005b4 <HAL_UART_RxCpltCallback+0x1c>)
 80005a6:	f003 bb64 	b.w	8003c72 <HAL_UART_Receive_IT>
 80005aa:	4770      	bx	lr
 80005ac:	40011000 	.word	0x40011000
 80005b0:	200005a6 	.word	0x200005a6
 80005b4:	2000213c 	.word	0x2000213c

080005b8 <HAL_UART_TxCpltCallback>:
    }
}

void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart)
{
  if (huart->Instance == USART1)
 80005b8:	6802      	ldr	r2, [r0, #0]
 80005ba:	4b03      	ldr	r3, [pc, #12]	; (80005c8 <HAL_UART_TxCpltCallback+0x10>)
 80005bc:	429a      	cmp	r2, r3
    {
      semaphore = false;
 80005be:	bf02      	ittt	eq
 80005c0:	4b02      	ldreq	r3, [pc, #8]	; (80005cc <HAL_UART_TxCpltCallback+0x14>)
 80005c2:	2200      	moveq	r2, #0
 80005c4:	701a      	strbeq	r2, [r3, #0]
 80005c6:	4770      	bx	lr
 80005c8:	40011000 	.word	0x40011000
 80005cc:	200005a7 	.word	0x200005a7

080005d0 <uartInit>:
    }
}

void uartInit(void)
{
 80005d0:	b538      	push	{r3, r4, r5, lr}
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200; // Prędkość transmisji równa 115200 bit/s
  huart1.Init.WordLength = UART_WORDLENGTH_8B; // Osiem bitów danych
 80005d2:	4a0f      	ldr	r2, [pc, #60]	; (8000610 <uartInit+0x40>)
    }
}

void uartInit(void)
{
  huart1.Instance = USART1;
 80005d4:	4c0f      	ldr	r4, [pc, #60]	; (8000614 <uartInit+0x44>)
  huart1.Init.BaudRate = 115200; // Prędkość transmisji równa 115200 bit/s
  huart1.Init.WordLength = UART_WORDLENGTH_8B; // Osiem bitów danych
 80005d6:	2500      	movs	r5, #0
 80005d8:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 80005dc:	e884 002c 	stmia.w	r4, {r2, r3, r5}
  huart1.Init.StopBits = UART_STOPBITS_1; // Jeden bit stopu
  huart1.Init.Parity = UART_PARITY_NONE; // Brak bitu parzystości
  huart1.Init.Mode = UART_MODE_TX_RX; // Komunikacja w obie strony (nadawanie i odbieranie)
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; // Brak sprzętowej kontroli przepływu
  huart1.Init.OverSampling = UART_OVERSAMPLING_16; // Nadpróbkowanie sygnału
  HAL_UART_Init(&huart1); // Inicjalizacja peryferium
 80005e0:	4620      	mov	r0, r4
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200; // Prędkość transmisji równa 115200 bit/s
  huart1.Init.WordLength = UART_WORDLENGTH_8B; // Osiem bitów danych
  huart1.Init.StopBits = UART_STOPBITS_1; // Jeden bit stopu
  huart1.Init.Parity = UART_PARITY_NONE; // Brak bitu parzystości
  huart1.Init.Mode = UART_MODE_TX_RX; // Komunikacja w obie strony (nadawanie i odbieranie)
 80005e2:	230c      	movs	r3, #12
 80005e4:	6163      	str	r3, [r4, #20]
void uartInit(void)
{
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 115200; // Prędkość transmisji równa 115200 bit/s
  huart1.Init.WordLength = UART_WORDLENGTH_8B; // Osiem bitów danych
  huart1.Init.StopBits = UART_STOPBITS_1; // Jeden bit stopu
 80005e6:	60e5      	str	r5, [r4, #12]
  huart1.Init.Parity = UART_PARITY_NONE; // Brak bitu parzystości
 80005e8:	6125      	str	r5, [r4, #16]
  huart1.Init.Mode = UART_MODE_TX_RX; // Komunikacja w obie strony (nadawanie i odbieranie)
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; // Brak sprzętowej kontroli przepływu
 80005ea:	61a5      	str	r5, [r4, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16; // Nadpróbkowanie sygnału
 80005ec:	61e5      	str	r5, [r4, #28]
  HAL_UART_Init(&huart1); // Inicjalizacja peryferium
 80005ee:	f003 faf3 	bl	8003bd8 <HAL_UART_Init>

  HAL_NVIC_SetPriority(USART1_IRQn, 2, 0); // Ustawienie priorytetu przerwań
 80005f2:	462a      	mov	r2, r5
 80005f4:	2102      	movs	r1, #2
 80005f6:	2025      	movs	r0, #37	; 0x25
 80005f8:	f001 fa8c 	bl	8001b14 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(USART1_IRQn); // Włączenie przerwań peryferium USART1
 80005fc:	2025      	movs	r0, #37	; 0x25
 80005fe:	f001 fabd 	bl	8001b7c <HAL_NVIC_EnableIRQ>

  HAL_UART_Receive_IT(&huart1, &rxChar, 1); // Rozpoczęcie nasłuchiwania w trybie przerwań
 8000602:	4620      	mov	r0, r4
 8000604:	2201      	movs	r2, #1
 8000606:	4904      	ldr	r1, [pc, #16]	; (8000618 <uartInit+0x48>)
}
 8000608:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_UART_Init(&huart1); // Inicjalizacja peryferium

  HAL_NVIC_SetPriority(USART1_IRQn, 2, 0); // Ustawienie priorytetu przerwań
  HAL_NVIC_EnableIRQ(USART1_IRQn); // Włączenie przerwań peryferium USART1

  HAL_UART_Receive_IT(&huart1, &rxChar, 1); // Rozpoczęcie nasłuchiwania w trybie przerwań
 800060c:	f003 bb31 	b.w	8003c72 <HAL_UART_Receive_IT>
 8000610:	40011000 	.word	0x40011000
 8000614:	2000213c 	.word	0x2000213c
 8000618:	200005a6 	.word	0x200005a6

0800061c <accInit>:
} acc_t;

acc_t acc;

void accInit(void)
{
 800061c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  uint8_t cfg = CFG_100_HZ | CFG_X_EN | CFG_Y_EN | CFG_Z_EN;
 800061e:	aa06      	add	r2, sp, #24
 8000620:	2357      	movs	r3, #87	; 0x57
 8000622:	f802 3d01 	strb.w	r3, [r2, #-1]!

  HAL_StatusTypeDef status = HAL_I2C_Mem_Write(&hi2c3, ACC_I2C_ADDRESS, CTRL_REG1, 1, &cfg, 1, 100);
 8000626:	2364      	movs	r3, #100	; 0x64
 8000628:	9302      	str	r3, [sp, #8]
 800062a:	2301      	movs	r3, #1
 800062c:	e88d 000c 	stmia.w	sp, {r2, r3}
 8000630:	2132      	movs	r1, #50	; 0x32
 8000632:	2220      	movs	r2, #32
 8000634:	4805      	ldr	r0, [pc, #20]	; (800064c <accInit+0x30>)
 8000636:	f001 ffb1 	bl	800259c <HAL_I2C_Mem_Write>
  if (status != HAL_OK)
 800063a:	b108      	cbz	r0, 8000640 <accInit+0x24>
    xprintf("ACC init FAIL\n");
 800063c:	4804      	ldr	r0, [pc, #16]	; (8000650 <accInit+0x34>)
 800063e:	e000      	b.n	8000642 <accInit+0x26>
  else
    xprintf("ACC init OK\n");
 8000640:	4804      	ldr	r0, [pc, #16]	; (8000654 <accInit+0x38>)
 8000642:	f000 fb9c 	bl	8000d7e <xprintf>

}
 8000646:	b007      	add	sp, #28
 8000648:	f85d fb04 	ldr.w	pc, [sp], #4
 800064c:	200020e8 	.word	0x200020e8
 8000650:	08009b81 	.word	0x08009b81
 8000654:	08009b90 	.word	0x08009b90

08000658 <getDirection>:
  acc.y = (buf[3] << 8) | buf[2];
  acc.z = (buf[5] << 8) | buf[4];
}

direction_t getDirection(void)
{
 8000658:	b510      	push	{r4, lr}
 800065a:	b086      	sub	sp, #24
}

static void readRaw(void)
{
  uint8_t buf[6];
  HAL_I2C_Mem_Read(&hi2c3, ACC_I2C_ADDRESS, (OUT_X_L | 0x80), 1, buf, 6, 100);
 800065c:	2364      	movs	r3, #100	; 0x64
 800065e:	9302      	str	r3, [sp, #8]
 8000660:	2306      	movs	r3, #6
 8000662:	9301      	str	r3, [sp, #4]
 8000664:	ab04      	add	r3, sp, #16
 8000666:	9300      	str	r3, [sp, #0]
 8000668:	22a8      	movs	r2, #168	; 0xa8
 800066a:	2301      	movs	r3, #1
 800066c:	2132      	movs	r1, #50	; 0x32
 800066e:	4818      	ldr	r0, [pc, #96]	; (80006d0 <getDirection+0x78>)
 8000670:	f002 f818 	bl	80026a4 <HAL_I2C_Mem_Read>

  acc.x = (buf[1] << 8) | buf[0];
 8000674:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8000678:	f89d 2011 	ldrb.w	r2, [sp, #17]
  acc.y = (buf[3] << 8) | buf[2];
 800067c:	f89d 0013 	ldrb.w	r0, [sp, #19]
  acc.z = (buf[5] << 8) | buf[4];
 8000680:	f89d 4015 	ldrb.w	r4, [sp, #21]
static void readRaw(void)
{
  uint8_t buf[6];
  HAL_I2C_Mem_Read(&hi2c3, ACC_I2C_ADDRESS, (OUT_X_L | 0x80), 1, buf, 6, 100);

  acc.x = (buf[1] << 8) | buf[0];
 8000684:	4913      	ldr	r1, [pc, #76]	; (80006d4 <getDirection+0x7c>)
 8000686:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
  acc.y = (buf[3] << 8) | buf[2];
 800068a:	f89d 3012 	ldrb.w	r3, [sp, #18]
 800068e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  acc.z = (buf[5] << 8) | buf[4];
 8000692:	f89d 3014 	ldrb.w	r3, [sp, #20]
static void readRaw(void)
{
  uint8_t buf[6];
  HAL_I2C_Mem_Read(&hi2c3, ACC_I2C_ADDRESS, (OUT_X_L | 0x80), 1, buf, 6, 100);

  acc.x = (buf[1] << 8) | buf[0];
 8000696:	b212      	sxth	r2, r2
  acc.y = (buf[3] << 8) | buf[2];
 8000698:	b200      	sxth	r0, r0
  acc.z = (buf[5] << 8) | buf[4];
 800069a:	ea43 2304 	orr.w	r3, r3, r4, lsl #8
static void readRaw(void)
{
  uint8_t buf[6];
  HAL_I2C_Mem_Read(&hi2c3, ACC_I2C_ADDRESS, (OUT_X_L | 0x80), 1, buf, 6, 100);

  acc.x = (buf[1] << 8) | buf[0];
 800069e:	800a      	strh	r2, [r1, #0]
  acc.y = (buf[3] << 8) | buf[2];
 80006a0:	8048      	strh	r0, [r1, #2]
  acc.z = (buf[5] << 8) | buf[4];
 80006a2:	808b      	strh	r3, [r1, #4]

direction_t getDirection(void)
{
  readRaw();

  if (acc.x > 10000)
 80006a4:	f242 7110 	movw	r1, #10000	; 0x2710
 80006a8:	428a      	cmp	r2, r1
 80006aa:	dc09      	bgt.n	80006c0 <getDirection+0x68>
    return DIR_UP;
  else if (acc.x < -10000)
 80006ac:	4b0a      	ldr	r3, [pc, #40]	; (80006d8 <getDirection+0x80>)
 80006ae:	429a      	cmp	r2, r3
 80006b0:	db08      	blt.n	80006c4 <getDirection+0x6c>
    return DIR_DOWN;
  else if (acc.y > 10000)
 80006b2:	4288      	cmp	r0, r1
 80006b4:	dc08      	bgt.n	80006c8 <getDirection+0x70>
    return DIR_LEFT;
  else if (acc.y < -10000)
    return DIR_RIGHT;

  return DIR_NONE;
 80006b6:	4298      	cmp	r0, r3
 80006b8:	bfb4      	ite	lt
 80006ba:	2004      	movlt	r0, #4
 80006bc:	2000      	movge	r0, #0
 80006be:	e004      	b.n	80006ca <getDirection+0x72>
direction_t getDirection(void)
{
  readRaw();

  if (acc.x > 10000)
    return DIR_UP;
 80006c0:	2001      	movs	r0, #1
 80006c2:	e002      	b.n	80006ca <getDirection+0x72>
  else if (acc.x < -10000)
    return DIR_DOWN;
 80006c4:	2002      	movs	r0, #2
 80006c6:	e000      	b.n	80006ca <getDirection+0x72>
  else if (acc.y > 10000)
    return DIR_LEFT;
 80006c8:	2003      	movs	r0, #3
  else if (acc.y < -10000)
    return DIR_RIGHT;

  return DIR_NONE;
}
 80006ca:	b006      	add	sp, #24
 80006cc:	bd10      	pop	{r4, pc}
 80006ce:	bf00      	nop
 80006d0:	200020e8 	.word	0x200020e8
 80006d4:	2000217c 	.word	0x2000217c
 80006d8:	ffffd8f0 	.word	0xffffd8f0

080006dc <changeLedState>:
  snake->show();
}

static void changeLedState(void)
{
  GREEN_LED_TOGGLE();
 80006dc:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80006e0:	4801      	ldr	r0, [pc, #4]	; (80006e8 <changeLedState+0xc>)
 80006e2:	f001 bd0b 	b.w	80020fc <HAL_GPIO_TogglePin>
 80006e6:	bf00      	nop
 80006e8:	40021800 	.word	0x40021800

080006ec <checkInput>:
  food->show(snake);
  periodEvents[GAME_EVENT].callback = gameUpdate;
}

static void checkInput(void) // called every 20 ms
{
 80006ec:	b570      	push	{r4, r5, r6, lr}
  static uint8_t state = 0;
  static bool pressed = false;

  if (BSP_PB_GetState(BUTTON_KEY) == 1)
 80006ee:	2000      	movs	r0, #0
 80006f0:	f000 ff10 	bl	8001514 <BSP_PB_GetState>
 80006f4:	2801      	cmp	r0, #1
 80006f6:	4606      	mov	r6, r0
 80006f8:	4a15      	ldr	r2, [pc, #84]	; (8000750 <checkInput+0x64>)
 80006fa:	d124      	bne.n	8000746 <checkInput+0x5a>
    {
      state++;
 80006fc:	7813      	ldrb	r3, [r2, #0]
 80006fe:	3301      	adds	r3, #1
 8000700:	b2db      	uxtb	r3, r3
      if (state > 3 && pressed == false)
 8000702:	2b03      	cmp	r3, #3
  static uint8_t state = 0;
  static bool pressed = false;

  if (BSP_PB_GetState(BUTTON_KEY) == 1)
    {
      state++;
 8000704:	7013      	strb	r3, [r2, #0]
      if (state > 3 && pressed == false)
 8000706:	d922      	bls.n	800074e <checkInput+0x62>
 8000708:	4d12      	ldr	r5, [pc, #72]	; (8000754 <checkInput+0x68>)
 800070a:	782b      	ldrb	r3, [r5, #0]
 800070c:	b9fb      	cbnz	r3, 800074e <checkInput+0x62>
  GREEN_LED_TOGGLE();
}

static void gameRestart(void)
{
  GUI_Clear();
 800070e:	f007 f985 	bl	8007a1c <GUI_Clear>
  snake = snakeInit(LCD_GetXSize() / 2, LCD_GetYSize() / 2, GRID_SIZE);
 8000712:	f006 f967 	bl	80069e4 <LCD_GetXSize>
 8000716:	4604      	mov	r4, r0
 8000718:	f006 f96c 	bl	80069f4 <LCD_GetYSize>
 800071c:	2302      	movs	r3, #2
 800071e:	2228      	movs	r2, #40	; 0x28
 8000720:	fb90 f1f3 	sdiv	r1, r0, r3
 8000724:	fb94 f0f3 	sdiv	r0, r4, r3
 8000728:	b2c9      	uxtb	r1, r1
 800072a:	b2c0      	uxtb	r0, r0
 800072c:	f000 f95a 	bl	80009e4 <snakeInit>
 8000730:	4b09      	ldr	r3, [pc, #36]	; (8000758 <checkInput+0x6c>)
 8000732:	6018      	str	r0, [r3, #0]
  food->show(snake);
 8000734:	4b09      	ldr	r3, [pc, #36]	; (800075c <checkInput+0x70>)
 8000736:	681b      	ldr	r3, [r3, #0]
 8000738:	68db      	ldr	r3, [r3, #12]
 800073a:	4798      	blx	r3
  periodEvents[GAME_EVENT].callback = gameUpdate;
 800073c:	4b08      	ldr	r3, [pc, #32]	; (8000760 <checkInput+0x74>)
 800073e:	4a09      	ldr	r2, [pc, #36]	; (8000764 <checkInput+0x78>)
 8000740:	60da      	str	r2, [r3, #12]
    {
      state++;
      if (state > 3 && pressed == false)
        {
          gameRestart();
          pressed = true;
 8000742:	702e      	strb	r6, [r5, #0]
 8000744:	bd70      	pop	{r4, r5, r6, pc}
        }
    }
  else
    {
      pressed = false;
 8000746:	4903      	ldr	r1, [pc, #12]	; (8000754 <checkInput+0x68>)
 8000748:	2300      	movs	r3, #0
 800074a:	700b      	strb	r3, [r1, #0]
      state = 0;
 800074c:	7013      	strb	r3, [r2, #0]
 800074e:	bd70      	pop	{r4, r5, r6, pc}
 8000750:	200005a9 	.word	0x200005a9
 8000754:	200005a8 	.word	0x200005a8
 8000758:	200005b4 	.word	0x200005b4
 800075c:	200005b8 	.word	0x200005b8
 8000760:	20000000 	.word	0x20000000
 8000764:	08000769 	.word	0x08000769

08000768 <gameUpdate>:
        }
    }
}

static void gameUpdate(void)
{
 8000768:	b510      	push	{r4, lr}
  if (!snake->move()) // warunek konca gry
 800076a:	4c0b      	ldr	r4, [pc, #44]	; (8000798 <gameUpdate+0x30>)
 800076c:	6823      	ldr	r3, [r4, #0]
 800076e:	689b      	ldr	r3, [r3, #8]
 8000770:	4798      	blx	r3
 8000772:	b938      	cbnz	r0, 8000784 <gameUpdate+0x1c>
    {
      periodEvents[GAME_EVENT].callback = NULL;
 8000774:	4b09      	ldr	r3, [pc, #36]	; (800079c <gameUpdate+0x34>)
 8000776:	60d8      	str	r0, [r3, #12]
      endGameScreen(snake->length);
 8000778:	6823      	ldr	r3, [r4, #0]
      return;
    }

  snake->eat(food);
  snake->show();
}
 800077a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static void gameUpdate(void)
{
  if (!snake->move()) // warunek konca gry
    {
      periodEvents[GAME_EVENT].callback = NULL;
      endGameScreen(snake->length);
 800077e:	7818      	ldrb	r0, [r3, #0]
 8000780:	f7ff beaa 	b.w	80004d8 <endGameScreen>
      return;
    }

  snake->eat(food);
 8000784:	6823      	ldr	r3, [r4, #0]
 8000786:	4a06      	ldr	r2, [pc, #24]	; (80007a0 <gameUpdate+0x38>)
 8000788:	685b      	ldr	r3, [r3, #4]
 800078a:	6810      	ldr	r0, [r2, #0]
 800078c:	4798      	blx	r3
  snake->show();
 800078e:	6823      	ldr	r3, [r4, #0]
}
 8000790:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      endGameScreen(snake->length);
      return;
    }

  snake->eat(food);
  snake->show();
 8000794:	68db      	ldr	r3, [r3, #12]
 8000796:	4718      	bx	r3
 8000798:	200005b4 	.word	0x200005b4
 800079c:	20000000 	.word	0x20000000
 80007a0:	200005b8 	.word	0x200005b8

080007a4 <main>:

// rozmiar siatki po ktorej porusza sie snejk
#define GRID_SIZE 40

int main(void)
{
 80007a4:	b580      	push	{r7, lr}
  boardInit();
 80007a6:	f7ff fd4b 	bl	8000240 <boardInit>
  guiInit();
 80007aa:	f7ff fe87 	bl	80004bc <guiInit>
  xprintf("Init done.\n");
 80007ae:	4825      	ldr	r0, [pc, #148]	; (8000844 <main+0xa0>)
{
  static uint32_t tick = 0;
  static uint8_t i;

  tick = HAL_GetTick();
  for (i = 0; i < eventsNum; i++)
 80007b0:	4d25      	ldr	r5, [pc, #148]	; (8000848 <main+0xa4>)
static void doPeriodically(void)
{
  static uint32_t tick = 0;
  static uint8_t i;

  tick = HAL_GetTick();
 80007b2:	4f26      	ldr	r7, [pc, #152]	; (800084c <main+0xa8>)

int main(void)
{
  boardInit();
  guiInit();
  xprintf("Init done.\n");
 80007b4:	f000 fae3 	bl	8000d7e <xprintf>

  snake = snakeInit(LCD_GetXSize() / 2, LCD_GetYSize() / 2, GRID_SIZE);
 80007b8:	f006 f914 	bl	80069e4 <LCD_GetXSize>
 80007bc:	4604      	mov	r4, r0
 80007be:	f006 f919 	bl	80069f4 <LCD_GetYSize>
 80007c2:	2302      	movs	r3, #2
 80007c4:	2228      	movs	r2, #40	; 0x28
 80007c6:	fb90 f1f3 	sdiv	r1, r0, r3
 80007ca:	fb94 f0f3 	sdiv	r0, r4, r3
 80007ce:	b2c9      	uxtb	r1, r1
 80007d0:	b2c0      	uxtb	r0, r0
 80007d2:	f000 f907 	bl	80009e4 <snakeInit>
 80007d6:	4c1e      	ldr	r4, [pc, #120]	; (8000850 <main+0xac>)
 80007d8:	6020      	str	r0, [r4, #0]
  food = foodInit(GRID_SIZE);
 80007da:	2028      	movs	r0, #40	; 0x28
 80007dc:	f7ff fe4c 	bl	8000478 <foodInit>
 80007e0:	4b1c      	ldr	r3, [pc, #112]	; (8000854 <main+0xb0>)
 80007e2:	6018      	str	r0, [r3, #0]
  food->show(snake);
 80007e4:	68c3      	ldr	r3, [r0, #12]
 80007e6:	6820      	ldr	r0, [r4, #0]

  periodEvents[GAME_EVENT].callback = gameUpdate;
 80007e8:	4c1b      	ldr	r4, [pc, #108]	; (8000858 <main+0xb4>)
  guiInit();
  xprintf("Init done.\n");

  snake = snakeInit(LCD_GetXSize() / 2, LCD_GetYSize() / 2, GRID_SIZE);
  food = foodInit(GRID_SIZE);
  food->show(snake);
 80007ea:	4798      	blx	r3

  periodEvents[GAME_EVENT].callback = gameUpdate;
 80007ec:	4b1b      	ldr	r3, [pc, #108]	; (800085c <main+0xb8>)
 80007ee:	60e3      	str	r3, [r4, #12]

  BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);
 80007f0:	2100      	movs	r1, #0
 80007f2:	4608      	mov	r0, r1
 80007f4:	f000 fe54 	bl	80014a0 <BSP_PB_Init>
 80007f8:	462e      	mov	r6, r5
static void doPeriodically(void)
{
  static uint32_t tick = 0;
  static uint8_t i;

  tick = HAL_GetTick();
 80007fa:	f001 f965 	bl	8001ac8 <HAL_GetTick>
 80007fe:	f8df 804c 	ldr.w	r8, [pc, #76]	; 800084c <main+0xa8>
  for (i = 0; i < eventsNum; i++)
    {
      if (tick - periodEvents[i].lastExeTime >= periodEvents[i].period)
 8000802:	f8df 9054 	ldr.w	r9, [pc, #84]	; 8000858 <main+0xb4>
static void doPeriodically(void)
{
  static uint32_t tick = 0;
  static uint8_t i;

  tick = HAL_GetTick();
 8000806:	6038      	str	r0, [r7, #0]
  for (i = 0; i < eventsNum; i++)
 8000808:	2300      	movs	r3, #0
 800080a:	702b      	strb	r3, [r5, #0]
 800080c:	7833      	ldrb	r3, [r6, #0]
 800080e:	2b02      	cmp	r3, #2
 8000810:	d8f3      	bhi.n	80007fa <main+0x56>
    {
      if (tick - periodEvents[i].lastExeTime >= periodEvents[i].period)
 8000812:	f04f 0a0c 	mov.w	sl, #12
 8000816:	fb0a f303 	mul.w	r3, sl, r3
 800081a:	18e0      	adds	r0, r4, r3
 800081c:	f8d8 2000 	ldr.w	r2, [r8]
 8000820:	6881      	ldr	r1, [r0, #8]
 8000822:	1a52      	subs	r2, r2, r1
 8000824:	6841      	ldr	r1, [r0, #4]
 8000826:	428a      	cmp	r2, r1
 8000828:	d307      	bcc.n	800083a <main+0x96>
        {
          if (periodEvents[i].callback)
 800082a:	58e3      	ldr	r3, [r4, r3]
 800082c:	b12b      	cbz	r3, 800083a <main+0x96>
            {
              periodEvents[i].callback();
 800082e:	4798      	blx	r3
              periodEvents[i].lastExeTime = tick;
 8000830:	782b      	ldrb	r3, [r5, #0]
 8000832:	683a      	ldr	r2, [r7, #0]
 8000834:	fb0a 9303 	mla	r3, sl, r3, r9
 8000838:	609a      	str	r2, [r3, #8]
{
  static uint32_t tick = 0;
  static uint8_t i;

  tick = HAL_GetTick();
  for (i = 0; i < eventsNum; i++)
 800083a:	7833      	ldrb	r3, [r6, #0]
 800083c:	3301      	adds	r3, #1
 800083e:	7033      	strb	r3, [r6, #0]
 8000840:	e7e4      	b.n	800080c <main+0x68>
 8000842:	bf00      	nop
 8000844:	08009b9d 	.word	0x08009b9d
 8000848:	200005b0 	.word	0x200005b0
 800084c:	200005ac 	.word	0x200005ac
 8000850:	200005b4 	.word	0x200005b4
 8000854:	200005b8 	.word	0x200005b8
 8000858:	20000000 	.word	0x20000000
 800085c:	08000769 	.word	0x08000769

08000860 <show>:
  // xprintf("x: %d, y: %d\n", snake.tail[0].x0, snake.tail[0].y0);
}

/* Wyswietla snejka na ekranie */
static void show(void)
{
 8000860:	b538      	push	{r3, r4, r5, lr}
  uint16_t i;

  GUI_SetColor(GUI_BLACK);
 8000862:	2000      	movs	r0, #0
  for (i = 0; i <= snake.length; i++)
 8000864:	4c08      	ldr	r4, [pc, #32]	; (8000888 <show+0x28>)
/* Wyswietla snejka na ekranie */
static void show(void)
{
  uint16_t i;

  GUI_SetColor(GUI_BLACK);
 8000866:	f006 fe1b 	bl	80074a0 <GUI_SetColor>
  for (i = 0; i <= snake.length; i++)
 800086a:	2000      	movs	r0, #0
 800086c:	7823      	ldrb	r3, [r4, #0]
 800086e:	1c45      	adds	r5, r0, #1
 8000870:	b280      	uxth	r0, r0
 8000872:	4283      	cmp	r3, r0
 8000874:	d306      	bcc.n	8000884 <show+0x24>
    GUI_FillRectEx(&snake.tail[i]);
 8000876:	3002      	adds	r0, #2
 8000878:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 800087c:	f006 fece 	bl	800761c <GUI_FillRectEx>
 8000880:	4628      	mov	r0, r5
 8000882:	e7f3      	b.n	800086c <show+0xc>
}
 8000884:	bd38      	pop	{r3, r4, r5, pc}
 8000886:	bf00      	nop
 8000888:	200005bc 	.word	0x200005bc

0800088c <move>:
 * dodaje nowy na początek. Funkcja zwraca:
 * false jesli nie udalo się poruszyc (wystąpila kolizja)
 * true jesli wykonano ruch na prawidlowe pole
 */
static bool move(void)
{
 800088c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (getDirection() != DIR_NONE)
 800088e:	f7ff fee3 	bl	8000658 <getDirection>
 8000892:	4c35      	ldr	r4, [pc, #212]	; (8000968 <move+0xdc>)
 8000894:	b1e8      	cbz	r0, 80008d2 <move+0x46>
    snake.dir = filterDirection(getDirection());
 8000896:	f7ff fedf 	bl	8000658 <getDirection>

static direction_t filterDirection(direction_t newDir)
{
  static direction_t prevDir = DIR_NONE;

  if (snake.length == 0)
 800089a:	7822      	ldrb	r2, [r4, #0]
 800089c:	4b33      	ldr	r3, [pc, #204]	; (800096c <move+0xe0>)
 800089e:	b192      	cbz	r2, 80008c6 <move+0x3a>
    {
      prevDir = newDir;
      return newDir;
    }

  switch (newDir)
 80008a0:	1e42      	subs	r2, r0, #1
 80008a2:	2a03      	cmp	r2, #3
 80008a4:	d80f      	bhi.n	80008c6 <move+0x3a>
 80008a6:	e8df f002 	tbb	[pc, r2]
 80008aa:	0502      	.short	0x0502
 80008ac:	0b08      	.short	0x0b08
    {
    case DIR_UP:
      if (prevDir == DIR_DOWN)
 80008ae:	781a      	ldrb	r2, [r3, #0]
 80008b0:	2a02      	cmp	r2, #2
 80008b2:	e007      	b.n	80008c4 <move+0x38>
        return prevDir;
      break;

    case DIR_DOWN:
      if (prevDir == DIR_UP)
 80008b4:	781a      	ldrb	r2, [r3, #0]
 80008b6:	2a01      	cmp	r2, #1
 80008b8:	e004      	b.n	80008c4 <move+0x38>
        return prevDir;
      break;

    case DIR_LEFT:
      if (prevDir == DIR_RIGHT)
 80008ba:	781a      	ldrb	r2, [r3, #0]
 80008bc:	2a04      	cmp	r2, #4
 80008be:	e001      	b.n	80008c4 <move+0x38>
        return prevDir;
      break;

    case DIR_RIGHT:
      if (prevDir == DIR_LEFT)
 80008c0:	781a      	ldrb	r2, [r3, #0]
 80008c2:	2a03      	cmp	r2, #3
 80008c4:	d001      	beq.n	80008ca <move+0x3e>

    default:
      break;
    }

  prevDir = newDir;
 80008c6:	7018      	strb	r0, [r3, #0]
 80008c8:	e000      	b.n	80008cc <move+0x40>
      if (prevDir == DIR_RIGHT)
        return prevDir;
      break;

    case DIR_RIGHT:
      if (prevDir == DIR_LEFT)
 80008ca:	4610      	mov	r0, r2
 * true jesli wykonano ruch na prawidlowe pole
 */
static bool move(void)
{
  if (getDirection() != DIR_NONE)
    snake.dir = filterDirection(getDirection());
 80008cc:	f641 0310 	movw	r3, #6160	; 0x1810
 80008d0:	54e0      	strb	r0, [r4, r3]

  tempRect = snake.tail[0];
 80008d2:	4b27      	ldr	r3, [pc, #156]	; (8000970 <move+0xe4>)
 80008d4:	4a27      	ldr	r2, [pc, #156]	; (8000974 <move+0xe8>)
 80008d6:	cb03      	ldmia	r3!, {r0, r1}

  switch (snake.dir)
 80008d8:	f641 0310 	movw	r3, #6160	; 0x1810
static bool move(void)
{
  if (getDirection() != DIR_NONE)
    snake.dir = filterDirection(getDirection());

  tempRect = snake.tail[0];
 80008dc:	6010      	str	r0, [r2, #0]

  switch (snake.dir)
 80008de:	5ce3      	ldrb	r3, [r4, r3]
static bool move(void)
{
  if (getDirection() != DIR_NONE)
    snake.dir = filterDirection(getDirection());

  tempRect = snake.tail[0];
 80008e0:	6051      	str	r1, [r2, #4]

  switch (snake.dir)
 80008e2:	3b01      	subs	r3, #1
 80008e4:	2b03      	cmp	r3, #3
 80008e6:	d812      	bhi.n	800090e <move+0x82>
 80008e8:	e8df f003 	tbb	[pc, r3]
 80008ec:	080b0502 	.word	0x080b0502
    {
    case DIR_UP:
      GUI_MoveRect(&tempRect, 0, -snake.size);
 80008f0:	7862      	ldrb	r2, [r4, #1]
 80008f2:	4252      	negs	r2, r2
 80008f4:	e000      	b.n	80008f8 <move+0x6c>
      break;

    case DIR_DOWN:
      GUI_MoveRect(&tempRect, 0, snake.size);
 80008f6:	7862      	ldrb	r2, [r4, #1]
 80008f8:	2100      	movs	r1, #0
 80008fa:	e005      	b.n	8000908 <move+0x7c>
      break;

    case DIR_RIGHT:
      GUI_MoveRect(&tempRect, snake.size, 0);
 80008fc:	2200      	movs	r2, #0
 80008fe:	7861      	ldrb	r1, [r4, #1]
 8000900:	e002      	b.n	8000908 <move+0x7c>
      break;

    case DIR_LEFT:
      GUI_MoveRect(&tempRect, -snake.size, 0);
 8000902:	7861      	ldrb	r1, [r4, #1]
 8000904:	2200      	movs	r2, #0
 8000906:	4249      	negs	r1, r1
 8000908:	481a      	ldr	r0, [pc, #104]	; (8000974 <move+0xe8>)
 800090a:	f006 fe15 	bl	8007538 <GUI_MoveRect>
 * true jesli kolizja wystapila
 */
static bool checkCollision(void)
{
  // krawedzie ekranu
  if (snake.tail[0].x1 > LCD_GetXSize() || snake.tail[0].x0 < 0)
 800090e:	f9b4 6014 	ldrsh.w	r6, [r4, #20]
 8000912:	4d15      	ldr	r5, [pc, #84]	; (8000968 <move+0xdc>)
 8000914:	f006 f866 	bl	80069e4 <LCD_GetXSize>
 8000918:	4286      	cmp	r6, r0
 800091a:	dc23      	bgt.n	8000964 <move+0xd8>
 800091c:	f9b5 3010 	ldrsh.w	r3, [r5, #16]
 8000920:	2b00      	cmp	r3, #0
 8000922:	db1f      	blt.n	8000964 <move+0xd8>
    return true;

  if (snake.tail[0].y1 > LCD_GetYSize() || snake.tail[0].y0 < 0)
 8000924:	f9b5 6016 	ldrsh.w	r6, [r5, #22]
 8000928:	f006 f864 	bl	80069f4 <LCD_GetYSize>
 800092c:	4286      	cmp	r6, r0
 800092e:	dc19      	bgt.n	8000964 <move+0xd8>
 8000930:	f9b5 1012 	ldrsh.w	r1, [r5, #18]
 8000934:	2900      	cmp	r1, #0
 8000936:	db15      	blt.n	8000964 <move+0xd8>
    return true;

  // cialo snejka
  uint16_t i;
  for (i = 1; i <= snake.length; i++)
 8000938:	7828      	ldrb	r0, [r5, #0]
    {
      if (snake.tail[0].x0 == snake.tail[i].x0 && snake.tail[0].y0 == snake.tail[i].y0)
 800093a:	f9b5 6010 	ldrsh.w	r6, [r5, #16]
 800093e:	2301      	movs	r3, #1
  if (snake.tail[0].y1 > LCD_GetYSize() || snake.tail[0].y0 < 0)
    return true;

  // cialo snejka
  uint16_t i;
  for (i = 1; i <= snake.length; i++)
 8000940:	4283      	cmp	r3, r0
 8000942:	d80d      	bhi.n	8000960 <move+0xd4>
    {
      if (snake.tail[0].x0 == snake.tail[i].x0 && snake.tail[0].y0 == snake.tail[i].y0)
 8000944:	1c9a      	adds	r2, r3, #2
 8000946:	f934 7032 	ldrsh.w	r7, [r4, r2, lsl #3]
 800094a:	42b7      	cmp	r7, r6
 800094c:	d105      	bne.n	800095a <move+0xce>
 800094e:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 8000952:	f9b2 2002 	ldrsh.w	r2, [r2, #2]
 8000956:	428a      	cmp	r2, r1
 8000958:	d004      	beq.n	8000964 <move+0xd8>
  if (snake.tail[0].y1 > LCD_GetYSize() || snake.tail[0].y0 < 0)
    return true;

  // cialo snejka
  uint16_t i;
  for (i = 1; i <= snake.length; i++)
 800095a:	3301      	adds	r3, #1
 800095c:	b29b      	uxth	r3, r3
 800095e:	e7ef      	b.n	8000940 <move+0xb4>
    }

  if (checkCollision())
    return false;

  return true;
 8000960:	2001      	movs	r0, #1
 8000962:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      break;

    }

  if (checkCollision())
    return false;
 8000964:	2000      	movs	r0, #0

  return true;
}
 8000966:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000968:	200005bc 	.word	0x200005bc
 800096c:	20001dd8 	.word	0x20001dd8
 8000970:	200005cc 	.word	0x200005cc
 8000974:	20001dd0 	.word	0x20001dd0

08000978 <eat>:
/*
 * Sprawdza czy glowa snejka znajduje sie na jedzeniu,
 * jesli tak, to usuwa jedzenie z ekranu i wydluza snejka
 */
static void eat(food_t *food)
{
 8000978:	b538      	push	{r3, r4, r5, lr}
  uint16_t i;

  if (tempRect.x0 == food->pos.x0 && tempRect.y0 == food->pos.y0)
 800097a:	4d17      	ldr	r5, [pc, #92]	; (80009d8 <eat+0x60>)
 800097c:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
 8000980:	f9b5 2000 	ldrsh.w	r2, [r5]
 8000984:	4c15      	ldr	r4, [pc, #84]	; (80009dc <eat+0x64>)
 8000986:	429a      	cmp	r2, r3
 8000988:	d10c      	bne.n	80009a4 <eat+0x2c>
 800098a:	f9b5 2002 	ldrsh.w	r2, [r5, #2]
 800098e:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
 8000992:	429a      	cmp	r2, r3
 8000994:	d106      	bne.n	80009a4 <eat+0x2c>
    {
      snake.length++;
 8000996:	7823      	ldrb	r3, [r4, #0]
 8000998:	3301      	adds	r3, #1
 800099a:	7023      	strb	r3, [r4, #0]
      food->show(&snake);
 800099c:	68c3      	ldr	r3, [r0, #12]
 800099e:	4620      	mov	r0, r4
 80009a0:	4798      	blx	r3
 80009a2:	e005      	b.n	80009b0 <eat+0x38>
    }
  else
    {
      GUI_ClearRectEx(&snake.tail[snake.length]);
 80009a4:	7820      	ldrb	r0, [r4, #0]
 80009a6:	3002      	adds	r0, #2
 80009a8:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
 80009ac:	f007 f8ac 	bl	8007b08 <GUI_ClearRectEx>
    }

  for (i = snake.length; i > 0; i--)
 80009b0:	7823      	ldrb	r3, [r4, #0]
 80009b2:	b15b      	cbz	r3, 80009cc <eat+0x54>
    snake.tail[i] = snake.tail[i - 1];
 80009b4:	1c59      	adds	r1, r3, #1
 80009b6:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
 80009ba:	c903      	ldmia	r1, {r0, r1}
 80009bc:	1c9a      	adds	r2, r3, #2
 80009be:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
  else
    {
      GUI_ClearRectEx(&snake.tail[snake.length]);
    }

  for (i = snake.length; i > 0; i--)
 80009c2:	3b01      	subs	r3, #1
    snake.tail[i] = snake.tail[i - 1];
 80009c4:	e882 0003 	stmia.w	r2, {r0, r1}
  else
    {
      GUI_ClearRectEx(&snake.tail[snake.length]);
    }

  for (i = snake.length; i > 0; i--)
 80009c8:	b29b      	uxth	r3, r3
 80009ca:	e7f2      	b.n	80009b2 <eat+0x3a>
    snake.tail[i] = snake.tail[i - 1];

  snake.tail[0] = tempRect;
 80009cc:	4b04      	ldr	r3, [pc, #16]	; (80009e0 <eat+0x68>)
 80009ce:	6828      	ldr	r0, [r5, #0]
 80009d0:	6869      	ldr	r1, [r5, #4]
 80009d2:	c303      	stmia	r3!, {r0, r1}
 80009d4:	bd38      	pop	{r3, r4, r5, pc}
 80009d6:	bf00      	nop
 80009d8:	20001dd0 	.word	0x20001dd0
 80009dc:	200005bc 	.word	0x200005bc
 80009e0:	200005cc 	.word	0x200005cc

080009e4 <snakeInit>:
 * Konstruktor
 * x, y - pozycja snejka
 * size - rozmiar snejka
 */
snake_t *snakeInit(uint8_t x, uint8_t y, uint8_t size)
{
 80009e4:	b510      	push	{r4, lr}
  snake.eat = eat;
 80009e6:	4c13      	ldr	r4, [pc, #76]	; (8000a34 <snakeInit+0x50>)
 * Konstruktor
 * x, y - pozycja snejka
 * size - rozmiar snejka
 */
snake_t *snakeInit(uint8_t x, uint8_t y, uint8_t size)
{
 80009e8:	4603      	mov	r3, r0
  snake.eat = eat;
  snake.move = move;
  snake.show = show;
  snake.size = size;
 80009ea:	7062      	strb	r2, [r4, #1]
 * x, y - pozycja snejka
 * size - rozmiar snejka
 */
snake_t *snakeInit(uint8_t x, uint8_t y, uint8_t size)
{
  snake.eat = eat;
 80009ec:	4812      	ldr	r0, [pc, #72]	; (8000a38 <snakeInit+0x54>)
 80009ee:	6060      	str	r0, [r4, #4]
  snake.size = size;
  snake.length = 0;

  snake.tail[0].x0 = x;
  snake.tail[0].y0 = y;
  snake.tail[0].x1 = x + size;
 80009f0:	b292      	uxth	r2, r2
  snake.move = move;
  snake.show = show;
  snake.size = size;
  snake.length = 0;

  snake.tail[0].x0 = x;
 80009f2:	8223      	strh	r3, [r4, #16]
 * size - rozmiar snejka
 */
snake_t *snakeInit(uint8_t x, uint8_t y, uint8_t size)
{
  snake.eat = eat;
  snake.move = move;
 80009f4:	4811      	ldr	r0, [pc, #68]	; (8000a3c <snakeInit+0x58>)
 80009f6:	60a0      	str	r0, [r4, #8]
  snake.size = size;
  snake.length = 0;

  snake.tail[0].x0 = x;
  snake.tail[0].y0 = y;
  snake.tail[0].x1 = x + size;
 80009f8:	4413      	add	r3, r2
 80009fa:	82a3      	strh	r3, [r4, #20]
  snake.tail[0].y1 = y + size;
 80009fc:	440a      	add	r2, r1

  snake.dir = DIR_NONE;
 80009fe:	f641 0310 	movw	r3, #6160	; 0x1810
 */
snake_t *snakeInit(uint8_t x, uint8_t y, uint8_t size)
{
  snake.eat = eat;
  snake.move = move;
  snake.show = show;
 8000a02:	480f      	ldr	r0, [pc, #60]	; (8000a40 <snakeInit+0x5c>)
  snake.length = 0;

  snake.tail[0].x0 = x;
  snake.tail[0].y0 = y;
  snake.tail[0].x1 = x + size;
  snake.tail[0].y1 = y + size;
 8000a04:	82e2      	strh	r2, [r4, #22]
  snake.show = show;
  snake.size = size;
  snake.length = 0;

  snake.tail[0].x0 = x;
  snake.tail[0].y0 = y;
 8000a06:	8261      	strh	r1, [r4, #18]
 */
snake_t *snakeInit(uint8_t x, uint8_t y, uint8_t size)
{
  snake.eat = eat;
  snake.move = move;
  snake.show = show;
 8000a08:	60e0      	str	r0, [r4, #12]
  snake.size = size;
  snake.length = 0;
 8000a0a:	2000      	movs	r0, #0
  snake.tail[0].x0 = x;
  snake.tail[0].y0 = y;
  snake.tail[0].x1 = x + size;
  snake.tail[0].y1 = y + size;

  snake.dir = DIR_NONE;
 8000a0c:	54e0      	strb	r0, [r4, r3]
{
  snake.eat = eat;
  snake.move = move;
  snake.show = show;
  snake.size = size;
  snake.length = 0;
 8000a0e:	7020      	strb	r0, [r4, #0]
  snake.tail[0].y1 = y + size;

  snake.dir = DIR_NONE;

  // Wyswietl snejka przy startupie
  GUI_SetColor(GUI_BLACK);
 8000a10:	f006 fd46 	bl	80074a0 <GUI_SetColor>
  GUI_FillRectEx(&snake.tail[0]);
 8000a14:	f104 0010 	add.w	r0, r4, #16
 8000a18:	f006 fe00 	bl	800761c <GUI_FillRectEx>

  xprintf("snake.x: %d\n", snake.tail[0].x0);
 8000a1c:	f9b4 1010 	ldrsh.w	r1, [r4, #16]
 8000a20:	4808      	ldr	r0, [pc, #32]	; (8000a44 <snakeInit+0x60>)
 8000a22:	f000 f9ac 	bl	8000d7e <xprintf>
  xprintf("snake.y: %d\n", snake.tail[0].y0);
 8000a26:	f9b4 1012 	ldrsh.w	r1, [r4, #18]
 8000a2a:	4807      	ldr	r0, [pc, #28]	; (8000a48 <snakeInit+0x64>)
 8000a2c:	f000 f9a7 	bl	8000d7e <xprintf>

  return &snake;
}
 8000a30:	4620      	mov	r0, r4
 8000a32:	bd10      	pop	{r4, pc}
 8000a34:	200005bc 	.word	0x200005bc
 8000a38:	08000979 	.word	0x08000979
 8000a3c:	0800088d 	.word	0x0800088d
 8000a40:	08000861 	.word	0x08000861
 8000a44:	08009ba9 	.word	0x08009ba9
 8000a48:	08009bb6 	.word	0x08009bb6

08000a4c <HAL_MspInit>:
#include "stm32f4xx_hal.h"

void HAL_MspInit(void)
{
 8000a4c:	b508      	push	{r3, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000a4e:	2003      	movs	r0, #3
 8000a50:	f001 f84e 	bl	8001af0 <HAL_NVIC_SetPriorityGrouping>
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8000a54:	2200      	movs	r2, #0
 8000a56:	210f      	movs	r1, #15
 8000a58:	f04f 30ff 	mov.w	r0, #4294967295
}
 8000a5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
#include "stm32f4xx_hal.h"

void HAL_MspInit(void)
{
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 8000a60:	f001 b858 	b.w	8001b14 <HAL_NVIC_SetPriority>

08000a64 <HAL_UART_MspInit>:
}

void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
 8000a64:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == USART1)
 8000a66:	6802      	ldr	r2, [r0, #0]
 8000a68:	4b10      	ldr	r3, [pc, #64]	; (8000aac <HAL_UART_MspInit+0x48>)
 8000a6a:	429a      	cmp	r2, r3
 8000a6c:	d11a      	bne.n	8000aa4 <HAL_UART_MspInit+0x40>
    {
      __USART1_CLK_ENABLE();
 8000a6e:	2300      	movs	r3, #0
 8000a70:	9300      	str	r3, [sp, #0]
 8000a72:	4b0f      	ldr	r3, [pc, #60]	; (8000ab0 <HAL_UART_MspInit+0x4c>)
      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_PULLUP;
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a74:	480f      	ldr	r0, [pc, #60]	; (8000ab4 <HAL_UART_MspInit+0x50>)
{

  GPIO_InitTypeDef GPIO_InitStruct;
  if (huart->Instance == USART1)
    {
      __USART1_CLK_ENABLE();
 8000a76:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000a78:	f042 0210 	orr.w	r2, r2, #16
 8000a7c:	645a      	str	r2, [r3, #68]	; 0x44
 8000a7e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8000a80:	f003 0310 	and.w	r3, r3, #16
 8000a84:	9300      	str	r3, [sp, #0]
 8000a86:	9b00      	ldr	r3, [sp, #0]

      /**USART1 GPIO Configuration
      PA9     ------> USART1_TX
      PA10     ------> USART1_RX
      */
      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;
 8000a88:	f44f 63c0 	mov.w	r3, #1536	; 0x600
 8000a8c:	9301      	str	r3, [sp, #4]
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000a8e:	2302      	movs	r3, #2
 8000a90:	9302      	str	r3, [sp, #8]
      GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000a92:	2301      	movs	r3, #1
 8000a94:	9303      	str	r3, [sp, #12]
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
 8000a96:	2303      	movs	r3, #3
 8000a98:	9304      	str	r3, [sp, #16]
      GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000a9a:	a901      	add	r1, sp, #4
      */
      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
      GPIO_InitStruct.Pull = GPIO_PULLUP;
      GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8000a9c:	2307      	movs	r3, #7
 8000a9e:	9305      	str	r3, [sp, #20]
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000aa0:	f001 f990 	bl	8001dc4 <HAL_GPIO_Init>
    }

}
 8000aa4:	b007      	add	sp, #28
 8000aa6:	f85d fb04 	ldr.w	pc, [sp], #4
 8000aaa:	bf00      	nop
 8000aac:	40011000 	.word	0x40011000
 8000ab0:	40023800 	.word	0x40023800
 8000ab4:	40020000 	.word	0x40020000

08000ab8 <HAL_I2C_MspInit>:
      HAL_NVIC_DisableIRQ(UART4_IRQn);
    }
}

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8000ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStruct;

  if (hi2c->Instance == I2C3)
 8000aba:	6802      	ldr	r2, [r0, #0]
 8000abc:	4b16      	ldr	r3, [pc, #88]	; (8000b18 <HAL_I2C_MspInit+0x60>)
 8000abe:	429a      	cmp	r2, r3
      HAL_NVIC_DisableIRQ(UART4_IRQn);
    }
}

void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
{
 8000ac0:	b087      	sub	sp, #28
  GPIO_InitTypeDef GPIO_InitStruct;

  if (hi2c->Instance == I2C3)
 8000ac2:	d127      	bne.n	8000b14 <HAL_I2C_MspInit+0x5c>
      */
      GPIO_InitStruct.Pin = GPIO_PIN_9;
      GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
      GPIO_InitStruct.Pull = GPIO_PULLUP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8000ac4:	2404      	movs	r4, #4

      /**I2C3 GPIO Configuration
      PC9     ------> I2C3_SDA
      PA8     ------> I2C3_SCL
      */
      GPIO_InitStruct.Pin = GPIO_PIN_9;
 8000ac6:	f44f 7300 	mov.w	r3, #512	; 0x200
      GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8000aca:	2712      	movs	r7, #18
      GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000acc:	2601      	movs	r6, #1
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000ace:	2502      	movs	r5, #2
      GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ad0:	eb0d 0104 	add.w	r1, sp, r4
 8000ad4:	4811      	ldr	r0, [pc, #68]	; (8000b1c <HAL_I2C_MspInit+0x64>)

      /**I2C3 GPIO Configuration
      PC9     ------> I2C3_SDA
      PA8     ------> I2C3_SCL
      */
      GPIO_InitStruct.Pin = GPIO_PIN_9;
 8000ad6:	9301      	str	r3, [sp, #4]
      GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8000ad8:	9702      	str	r7, [sp, #8]
      GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000ada:	9603      	str	r6, [sp, #12]
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000adc:	9504      	str	r5, [sp, #16]
      GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8000ade:	9405      	str	r4, [sp, #20]
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8000ae0:	f001 f970 	bl	8001dc4 <HAL_GPIO_Init>

      GPIO_InitStruct.Pin = GPIO_PIN_8;
 8000ae4:	f44f 7380 	mov.w	r3, #256	; 0x100
      GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
      GPIO_InitStruct.Pull = GPIO_PULLUP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000ae8:	eb0d 0104 	add.w	r1, sp, r4
 8000aec:	480c      	ldr	r0, [pc, #48]	; (8000b20 <HAL_I2C_MspInit+0x68>)
      GPIO_InitStruct.Pull = GPIO_PULLUP;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
      GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

      GPIO_InitStruct.Pin = GPIO_PIN_8;
 8000aee:	9301      	str	r3, [sp, #4]
      GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8000af0:	9702      	str	r7, [sp, #8]
      GPIO_InitStruct.Pull = GPIO_PULLUP;
 8000af2:	9603      	str	r6, [sp, #12]
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8000af4:	9504      	str	r5, [sp, #16]
      GPIO_InitStruct.Alternate = GPIO_AF4_I2C3;
 8000af6:	9405      	str	r4, [sp, #20]
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000af8:	f001 f964 	bl	8001dc4 <HAL_GPIO_Init>

      /* Peripheral clock enable */
      __HAL_RCC_I2C3_CLK_ENABLE();
 8000afc:	2300      	movs	r3, #0
 8000afe:	9300      	str	r3, [sp, #0]
 8000b00:	4b08      	ldr	r3, [pc, #32]	; (8000b24 <HAL_I2C_MspInit+0x6c>)
 8000b02:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000b04:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8000b08:	641a      	str	r2, [r3, #64]	; 0x40
 8000b0a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000b0c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8000b10:	9300      	str	r3, [sp, #0]
 8000b12:	9b00      	ldr	r3, [sp, #0]
      /* USER CODE BEGIN I2C3_MspInit 1 */

      /* USER CODE END I2C3_MspInit 1 */
    }
}
 8000b14:	b007      	add	sp, #28
 8000b16:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000b18:	40005c00 	.word	0x40005c00
 8000b1c:	40020800 	.word	0x40020800
 8000b20:	40020000 	.word	0x40020000
 8000b24:	40023800 	.word	0x40023800

08000b28 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
{
 8000b28:	b508      	push	{r3, lr}

  if (hi2c->Instance == I2C3)
 8000b2a:	6802      	ldr	r2, [r0, #0]
 8000b2c:	4b0a      	ldr	r3, [pc, #40]	; (8000b58 <HAL_I2C_MspDeInit+0x30>)
 8000b2e:	429a      	cmp	r2, r3
 8000b30:	d110      	bne.n	8000b54 <HAL_I2C_MspDeInit+0x2c>
    {
      /* USER CODE BEGIN I2C3_MspDeInit 0 */

      /* USER CODE END I2C3_MspDeInit 0 */
      /* Peripheral clock disable */
      __HAL_RCC_I2C3_CLK_DISABLE();
 8000b32:	4a0a      	ldr	r2, [pc, #40]	; (8000b5c <HAL_I2C_MspDeInit+0x34>)

      /**I2C3 GPIO Configuration
      PC9     ------> I2C3_SDA
      PA8     ------> I2C3_SCL
      */
      HAL_GPIO_DeInit(GPIOC, GPIO_PIN_9);
 8000b34:	480a      	ldr	r0, [pc, #40]	; (8000b60 <HAL_I2C_MspDeInit+0x38>)
    {
      /* USER CODE BEGIN I2C3_MspDeInit 0 */

      /* USER CODE END I2C3_MspDeInit 0 */
      /* Peripheral clock disable */
      __HAL_RCC_I2C3_CLK_DISABLE();
 8000b36:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000b38:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8000b3c:	6413      	str	r3, [r2, #64]	; 0x40

      /**I2C3 GPIO Configuration
      PC9     ------> I2C3_SDA
      PA8     ------> I2C3_SCL
      */
      HAL_GPIO_DeInit(GPIOC, GPIO_PIN_9);
 8000b3e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000b42:	f001 fa2b 	bl	8001f9c <HAL_GPIO_DeInit>

      HAL_GPIO_DeInit(GPIOA, GPIO_PIN_8);
 8000b46:	f44f 7180 	mov.w	r1, #256	; 0x100
 8000b4a:	4806      	ldr	r0, [pc, #24]	; (8000b64 <HAL_I2C_MspDeInit+0x3c>)

    }
  /* USER CODE BEGIN I2C3_MspDeInit 1 */

  /* USER CODE END I2C3_MspDeInit 1 */
 8000b4c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      PC9     ------> I2C3_SDA
      PA8     ------> I2C3_SCL
      */
      HAL_GPIO_DeInit(GPIOC, GPIO_PIN_9);

      HAL_GPIO_DeInit(GPIOA, GPIO_PIN_8);
 8000b50:	f001 ba24 	b.w	8001f9c <HAL_GPIO_DeInit>
 8000b54:	bd08      	pop	{r3, pc}
 8000b56:	bf00      	nop
 8000b58:	40005c00 	.word	0x40005c00
 8000b5c:	40023800 	.word	0x40023800
 8000b60:	40020800 	.word	0x40020800
 8000b64:	40020000 	.word	0x40020000

08000b68 <SysTick_Handler>:

extern void LTDC_ISR_Handler(void);
extern void DMA2D_ISR_Handler(void);

void SysTick_Handler(void)
{
 8000b68:	b508      	push	{r3, lr}
  HAL_IncTick();
 8000b6a:	f000 ffa5 	bl	8001ab8 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
}
 8000b6e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
extern void DMA2D_ISR_Handler(void);

void SysTick_Handler(void)
{
  HAL_IncTick();
  HAL_SYSTICK_IRQHandler();
 8000b72:	f001 b832 	b.w	8001bda <HAL_SYSTICK_IRQHandler>
	...

08000b78 <USART1_IRQHandler>:
}

void USART1_IRQHandler(void)
{
  HAL_UART_IRQHandler(&huart1);
 8000b78:	4801      	ldr	r0, [pc, #4]	; (8000b80 <USART1_IRQHandler+0x8>)
 8000b7a:	f003 b8db 	b.w	8003d34 <HAL_UART_IRQHandler>
 8000b7e:	bf00      	nop
 8000b80:	2000213c 	.word	0x2000213c

08000b84 <LTDC_IRQHandler>:
}

void LTDC_IRQHandler(void)
{
  HAL_LTDC_IRQHandler(&hltdc);
 8000b84:	4801      	ldr	r0, [pc, #4]	; (8000b8c <LTDC_IRQHandler+0x8>)
 8000b86:	f001 bf91 	b.w	8002aac <HAL_LTDC_IRQHandler>
 8000b8a:	bf00      	nop
 8000b8c:	200221e0 	.word	0x200221e0

08000b90 <xputc>:
/* Put a character                              */
/*----------------------------------------------*/

void xputc (char c)
{
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
 8000b90:	280a      	cmp	r0, #10
/*----------------------------------------------*/
/* Put a character                              */
/*----------------------------------------------*/

void xputc (char c)
{
 8000b92:	b510      	push	{r4, lr}
 8000b94:	4604      	mov	r4, r0
	if (_CR_CRLF && c == '\n') xputc('\r');		/* CR -> CRLF */
 8000b96:	d102      	bne.n	8000b9e <xputc+0xe>
 8000b98:	200d      	movs	r0, #13
 8000b9a:	f7ff fff9 	bl	8000b90 <xputc>

	if (outptr) {
 8000b9e:	4a07      	ldr	r2, [pc, #28]	; (8000bbc <xputc+0x2c>)
 8000ba0:	6813      	ldr	r3, [r2, #0]
 8000ba2:	b11b      	cbz	r3, 8000bac <xputc+0x1c>
		*outptr++ = (unsigned char)c;
 8000ba4:	1c59      	adds	r1, r3, #1
 8000ba6:	701c      	strb	r4, [r3, #0]
 8000ba8:	6011      	str	r1, [r2, #0]
		return;
 8000baa:	bd10      	pop	{r4, pc}
	}

	if (xfunc_out) xfunc_out((unsigned char)c);
 8000bac:	4b04      	ldr	r3, [pc, #16]	; (8000bc0 <xputc+0x30>)
 8000bae:	681b      	ldr	r3, [r3, #0]
 8000bb0:	b11b      	cbz	r3, 8000bba <xputc+0x2a>
 8000bb2:	4620      	mov	r0, r4
}
 8000bb4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	if (outptr) {
		*outptr++ = (unsigned char)c;
		return;
	}

	if (xfunc_out) xfunc_out((unsigned char)c);
 8000bb8:	4718      	bx	r3
 8000bba:	bd10      	pop	{r4, pc}
 8000bbc:	20001ddc 	.word	0x20001ddc
 8000bc0:	20002184 	.word	0x20002184

08000bc4 <xputs>:
/*----------------------------------------------*/

void xputs (					/* Put a string to the default device */
	const char* str				/* Pointer to the string */
)
{
 8000bc4:	b510      	push	{r4, lr}
 8000bc6:	1e44      	subs	r4, r0, #1
	while (*str)
 8000bc8:	f814 0f01 	ldrb.w	r0, [r4, #1]!
 8000bcc:	b110      	cbz	r0, 8000bd4 <xputs+0x10>
		xputc(*str++);
 8000bce:	f7ff ffdf 	bl	8000b90 <xputc>
 8000bd2:	e7f9      	b.n	8000bc8 <xputs+0x4>
}
 8000bd4:	bd10      	pop	{r4, pc}

08000bd6 <xvprintf>:
static
void xvprintf (
	const char*	fmt,	/* Pointer to the format string */
	va_list arp			/* Pointer to arguments */
)
{
 8000bd6:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8000bda:	4602      	mov	r2, r0
 8000bdc:	460d      	mov	r5, r1
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
 8000bde:	7810      	ldrb	r0, [r2, #0]
		if (!c) break;				/* End of format? */
 8000be0:	2800      	cmp	r0, #0
 8000be2:	f000 80c9 	beq.w	8000d78 <xvprintf+0x1a2>
		if (c != '%') {				/* Pass through it if not a % sequense */
 8000be6:	2825      	cmp	r0, #37	; 0x25
 8000be8:	d001      	beq.n	8000bee <xvprintf+0x18>
	unsigned long v;
	char s[16], c, d, *p;


	for (;;) {
		c = *fmt++;					/* Get a char */
 8000bea:	1c57      	adds	r7, r2, #1
 8000bec:	e06b      	b.n	8000cc6 <xvprintf+0xf0>
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
			xputc(c); continue;
		}
		f = 0;
		c = *fmt++;					/* Get first char of the sequense */
 8000bee:	7853      	ldrb	r3, [r2, #1]
		if (c == '0') {				/* Flag: '0' padded */
 8000bf0:	2b30      	cmp	r3, #48	; 0x30
 8000bf2:	d103      	bne.n	8000bfc <xvprintf+0x26>
			f = 1; c = *fmt++;
 8000bf4:	1cd7      	adds	r7, r2, #3
 8000bf6:	7893      	ldrb	r3, [r2, #2]
 8000bf8:	2601      	movs	r6, #1
 8000bfa:	e007      	b.n	8000c0c <xvprintf+0x36>
		} else {
			if (c == '-') {			/* Flag: left justified */
 8000bfc:	2b2d      	cmp	r3, #45	; 0x2d
				f = 2; c = *fmt++;
 8000bfe:	bf0d      	iteet	eq
 8000c00:	7893      	ldrbeq	r3, [r2, #2]
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
			xputc(c); continue;
		}
		f = 0;
		c = *fmt++;					/* Get first char of the sequense */
 8000c02:	1c97      	addne	r7, r2, #2
		c = *fmt++;					/* Get a char */
		if (!c) break;				/* End of format? */
		if (c != '%') {				/* Pass through it if not a % sequense */
			xputc(c); continue;
		}
		f = 0;
 8000c04:	2600      	movne	r6, #0
		c = *fmt++;					/* Get first char of the sequense */
		if (c == '0') {				/* Flag: '0' padded */
			f = 1; c = *fmt++;
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
 8000c06:	1cd7      	addeq	r7, r2, #3
 8000c08:	bf08      	it	eq
 8000c0a:	2602      	moveq	r6, #2
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
 8000c0c:	f04f 0800 	mov.w	r8, #0
			w = w * 10 + c - '0';
 8000c10:	210a      	movs	r1, #10
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
 8000c12:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8000c16:	2a09      	cmp	r2, #9
 8000c18:	d806      	bhi.n	8000c28 <xvprintf+0x52>
			w = w * 10 + c - '0';
 8000c1a:	fb01 3808 	mla	r8, r1, r8, r3
 8000c1e:	f1a8 0830 	sub.w	r8, r8, #48	; 0x30
		} else {
			if (c == '-') {			/* Flag: left justified */
				f = 2; c = *fmt++;
			}
		}
		for (w = 0; c >= '0' && c <= '9'; c = *fmt++)	/* Minimum width */
 8000c22:	f817 3b01 	ldrb.w	r3, [r7], #1
 8000c26:	e7f4      	b.n	8000c12 <xvprintf+0x3c>
			w = w * 10 + c - '0';
		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
 8000c28:	f003 02df 	and.w	r2, r3, #223	; 0xdf
 8000c2c:	2a4c      	cmp	r2, #76	; 0x4c
			f |= 4; c = *fmt++;
 8000c2e:	bf02      	ittt	eq
 8000c30:	783b      	ldrbeq	r3, [r7, #0]
 8000c32:	f046 0604 	orreq.w	r6, r6, #4
 8000c36:	3701      	addeq	r7, #1
		}
		if (!c) break;				/* End of format? */
 8000c38:	2b00      	cmp	r3, #0
 8000c3a:	f000 809d 	beq.w	8000d78 <xvprintf+0x1a2>
		d = c;
		if (d >= 'a') d -= 0x20;
 8000c3e:	2b60      	cmp	r3, #96	; 0x60
 8000c40:	bf86      	itte	hi
 8000c42:	f1a3 0220 	subhi.w	r2, r3, #32
 8000c46:	b2d2      	uxtbhi	r2, r2
 8000c48:	461a      	movls	r2, r3
		switch (d) {				/* Type is... */
 8000c4a:	2a4f      	cmp	r2, #79	; 0x4f
 8000c4c:	d012      	beq.n	8000c74 <xvprintf+0x9e>
 8000c4e:	d806      	bhi.n	8000c5e <xvprintf+0x88>
 8000c50:	2a43      	cmp	r2, #67	; 0x43
 8000c52:	d030      	beq.n	8000cb6 <xvprintf+0xe0>
 8000c54:	2a44      	cmp	r2, #68	; 0x44
 8000c56:	d03c      	beq.n	8000cd2 <xvprintf+0xfc>
 8000c58:	2a42      	cmp	r2, #66	; 0x42
 8000c5a:	d038      	beq.n	8000cce <xvprintf+0xf8>
 8000c5c:	e032      	b.n	8000cc4 <xvprintf+0xee>
 8000c5e:	2a55      	cmp	r2, #85	; 0x55
 8000c60:	d037      	beq.n	8000cd2 <xvprintf+0xfc>
 8000c62:	2a58      	cmp	r2, #88	; 0x58
 8000c64:	d02c      	beq.n	8000cc0 <xvprintf+0xea>
 8000c66:	2a53      	cmp	r2, #83	; 0x53
 8000c68:	d12c      	bne.n	8000cc4 <xvprintf+0xee>
		case 'S' :					/* String */
			p = va_arg(arp, char*);
 8000c6a:	f8d5 9000 	ldr.w	r9, [r5]
 8000c6e:	1d2c      	adds	r4, r5, #4
			for (j = 0; p[j]; j++) ;
 8000c70:	464b      	mov	r3, r9
 8000c72:	e001      	b.n	8000c78 <xvprintf+0xa2>
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
		case 'B' :					/* Binary */
			r = 2; break;
		case 'O' :					/* Octal */
			r = 8; break;
 8000c74:	2008      	movs	r0, #8
 8000c76:	e02d      	b.n	8000cd4 <xvprintf+0xfe>
 8000c78:	ebc9 0503 	rsb	r5, r9, r3
		d = c;
		if (d >= 'a') d -= 0x20;
		switch (d) {				/* Type is... */
		case 'S' :					/* String */
			p = va_arg(arp, char*);
			for (j = 0; p[j]; j++) ;
 8000c7c:	f813 2b01 	ldrb.w	r2, [r3], #1
 8000c80:	2a00      	cmp	r2, #0
 8000c82:	d1f9      	bne.n	8000c78 <xvprintf+0xa2>
			while (!(f & 2) && j++ < w) xputc(' ');
 8000c84:	07b0      	lsls	r0, r6, #30
 8000c86:	d409      	bmi.n	8000c9c <xvprintf+0xc6>
 8000c88:	4545      	cmp	r5, r8
 8000c8a:	f105 0601 	add.w	r6, r5, #1
 8000c8e:	d204      	bcs.n	8000c9a <xvprintf+0xc4>
 8000c90:	2020      	movs	r0, #32
 8000c92:	f7ff ff7d 	bl	8000b90 <xputc>
 8000c96:	4635      	mov	r5, r6
 8000c98:	e7f6      	b.n	8000c88 <xvprintf+0xb2>
 8000c9a:	4635      	mov	r5, r6
			xputs(p);
 8000c9c:	4648      	mov	r0, r9
 8000c9e:	f7ff ff91 	bl	8000bc4 <xputs>
			while (j++ < w) xputc(' ');
 8000ca2:	45a8      	cmp	r8, r5
 8000ca4:	d802      	bhi.n	8000cac <xvprintf+0xd6>
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
 8000ca6:	4625      	mov	r5, r4
 8000ca8:	463a      	mov	r2, r7
 8000caa:	e798      	b.n	8000bde <xvprintf+0x8>
		case 'S' :					/* String */
			p = va_arg(arp, char*);
			for (j = 0; p[j]; j++) ;
			while (!(f & 2) && j++ < w) xputc(' ');
			xputs(p);
			while (j++ < w) xputc(' ');
 8000cac:	2020      	movs	r0, #32
 8000cae:	f7ff ff6f 	bl	8000b90 <xputc>
 8000cb2:	3501      	adds	r5, #1
 8000cb4:	e7f5      	b.n	8000ca2 <xvprintf+0xcc>
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
 8000cb6:	7828      	ldrb	r0, [r5, #0]
 8000cb8:	1d2c      	adds	r4, r5, #4
 8000cba:	f7ff ff69 	bl	8000b90 <xputc>
 8000cbe:	e7f2      	b.n	8000ca6 <xvprintf+0xd0>
			r = 8; break;
		case 'D' :					/* Signed decimal */
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
		case 'X' :					/* Hexdecimal */
			r = 16; break;
 8000cc0:	2010      	movs	r0, #16
 8000cc2:	e007      	b.n	8000cd4 <xvprintf+0xfe>
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
 8000cc4:	4618      	mov	r0, r3
 8000cc6:	f7ff ff63 	bl	8000b90 <xputc>
 8000cca:	462c      	mov	r4, r5
 8000ccc:	e7eb      	b.n	8000ca6 <xvprintf+0xd0>
			while (j++ < w) xputc(' ');
			continue;
		case 'C' :					/* Character */
			xputc((char)va_arg(arp, int)); continue;
		case 'B' :					/* Binary */
			r = 2; break;
 8000cce:	2002      	movs	r0, #2
 8000cd0:	e000      	b.n	8000cd4 <xvprintf+0xfe>
		case 'O' :					/* Octal */
			r = 8; break;
		case 'D' :					/* Signed decimal */
		case 'U' :					/* Unsigned decimal */
			r = 10; break;
 8000cd2:	200a      	movs	r0, #10
		default:					/* Unknown type (passthrough) */
			xputc(c); continue;
		}

		/* Get an argument and put it in numeral */
		v = (f & 4) ? va_arg(arp, long) : ((d == 'D') ? (long)va_arg(arp, int) : (long)va_arg(arp, unsigned int));
 8000cd4:	2a44      	cmp	r2, #68	; 0x44
 8000cd6:	6829      	ldr	r1, [r5, #0]
 8000cd8:	f105 0404 	add.w	r4, r5, #4
 8000cdc:	d104      	bne.n	8000ce8 <xvprintf+0x112>
		if (d == 'D' && (v & 0x80000000)) {
 8000cde:	2900      	cmp	r1, #0
			v = 0 - v;
 8000ce0:	bfbc      	itt	lt
 8000ce2:	4249      	neglt	r1, r1
			f |= 8;
 8000ce4:	f046 0608 	orrlt.w	r6, r6, #8
 8000ce8:	2b78      	cmp	r3, #120	; 0x78
 8000cea:	bf14      	ite	ne
 8000cec:	f04f 0c07 	movne.w	ip, #7
 8000cf0:	f04f 0c27 	moveq.w	ip, #39	; 0x27
		}
		i = 0;
 8000cf4:	2200      	movs	r2, #0
		do {
			d = (char)(v % r); v /= r;
 8000cf6:	fbb1 fef0 	udiv	lr, r1, r0
 8000cfa:	fb00 151e 	mls	r5, r0, lr, r1
 8000cfe:	b2eb      	uxtb	r3, r5
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
 8000d00:	2d09      	cmp	r5, #9
 8000d02:	bf84      	itt	hi
 8000d04:	4463      	addhi	r3, ip
 8000d06:	b2db      	uxtbhi	r3, r3
			s[i++] = d + '0';
 8000d08:	3330      	adds	r3, #48	; 0x30
			v = 0 - v;
			f |= 8;
		}
		i = 0;
		do {
			d = (char)(v % r); v /= r;
 8000d0a:	4671      	mov	r1, lr
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
			s[i++] = d + '0';
 8000d0c:	1c55      	adds	r5, r2, #1
 8000d0e:	f80d 3002 	strb.w	r3, [sp, r2]
		} while (v && i < sizeof(s));
 8000d12:	f1be 0f00 	cmp.w	lr, #0
 8000d16:	d004      	beq.n	8000d22 <xvprintf+0x14c>
 8000d18:	2d10      	cmp	r5, #16
 8000d1a:	d001      	beq.n	8000d20 <xvprintf+0x14a>
 8000d1c:	462a      	mov	r2, r5
 8000d1e:	e7ea      	b.n	8000cf6 <xvprintf+0x120>
 8000d20:	220f      	movs	r2, #15
		if (f & 8) s[i++] = '-';
 8000d22:	0731      	lsls	r1, r6, #28
 8000d24:	d505      	bpl.n	8000d32 <xvprintf+0x15c>
 8000d26:	ab04      	add	r3, sp, #16
 8000d28:	441d      	add	r5, r3
 8000d2a:	232d      	movs	r3, #45	; 0x2d
 8000d2c:	f805 3c10 	strb.w	r3, [r5, #-16]
 8000d30:	1c95      	adds	r5, r2, #2
		j = i; d = (f & 1) ? '0' : ' ';
 8000d32:	f016 0f01 	tst.w	r6, #1
 8000d36:	bf14      	ite	ne
 8000d38:	f04f 0a30 	movne.w	sl, #48	; 0x30
 8000d3c:	f04f 0a20 	moveq.w	sl, #32
		while (!(f & 2) && j++ < w) xputc(d);
 8000d40:	07b3      	lsls	r3, r6, #30
			d = (char)(v % r); v /= r;
			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
			s[i++] = d + '0';
		} while (v && i < sizeof(s));
		if (f & 8) s[i++] = '-';
		j = i; d = (f & 1) ? '0' : ' ';
 8000d42:	46a9      	mov	r9, r5
		while (!(f & 2) && j++ < w) xputc(d);
 8000d44:	d409      	bmi.n	8000d5a <xvprintf+0x184>
 8000d46:	45c1      	cmp	r9, r8
 8000d48:	f109 0601 	add.w	r6, r9, #1
 8000d4c:	d204      	bcs.n	8000d58 <xvprintf+0x182>
 8000d4e:	4650      	mov	r0, sl
 8000d50:	f7ff ff1e 	bl	8000b90 <xputc>
 8000d54:	46b1      	mov	r9, r6
 8000d56:	e7f6      	b.n	8000d46 <xvprintf+0x170>
 8000d58:	46b1      	mov	r9, r6
		do xputc(s[--i]); while(i);
 8000d5a:	3d01      	subs	r5, #1
 8000d5c:	f81d 0005 	ldrb.w	r0, [sp, r5]
 8000d60:	f7ff ff16 	bl	8000b90 <xputc>
 8000d64:	2d00      	cmp	r5, #0
 8000d66:	d1f8      	bne.n	8000d5a <xvprintf+0x184>
		while (j++ < w) xputc(' ');
 8000d68:	45c8      	cmp	r8, r9
 8000d6a:	d99c      	bls.n	8000ca6 <xvprintf+0xd0>
 8000d6c:	2020      	movs	r0, #32
 8000d6e:	f7ff ff0f 	bl	8000b90 <xputc>
 8000d72:	f109 0901 	add.w	r9, r9, #1
 8000d76:	e7f7      	b.n	8000d68 <xvprintf+0x192>
	}
}
 8000d78:	b004      	add	sp, #16
 8000d7a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08000d7e <xprintf>:

void xprintf (			/* Put a formatted string to the default device */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
 8000d7e:	b40f      	push	{r0, r1, r2, r3}
 8000d80:	b507      	push	{r0, r1, r2, lr}
 8000d82:	a904      	add	r1, sp, #16
 8000d84:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list arp;


	va_start(arp, fmt);
 8000d88:	9101      	str	r1, [sp, #4]
	xvprintf(fmt, arp);
 8000d8a:	f7ff ff24 	bl	8000bd6 <xvprintf>
	va_end(arp);
}
 8000d8e:	b003      	add	sp, #12
 8000d90:	f85d eb04 	ldr.w	lr, [sp], #4
 8000d94:	b004      	add	sp, #16
 8000d96:	4770      	bx	lr

08000d98 <xsprintf>:
void xsprintf (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
 8000d98:	b40e      	push	{r1, r2, r3}
 8000d9a:	b517      	push	{r0, r1, r2, r4, lr}
 8000d9c:	a905      	add	r1, sp, #20
	va_list arp;


	outptr = buff;		/* Switch destination for memory */
 8000d9e:	4c08      	ldr	r4, [pc, #32]	; (8000dc0 <xsprintf+0x28>)
void xsprintf (			/* Put a formatted string to the memory */
	char* buff,			/* Pointer to the output buffer */
	const char*	fmt,	/* Pointer to the format string */
	...					/* Optional arguments */
)
{
 8000da0:	f851 3b04 	ldr.w	r3, [r1], #4
	va_list arp;


	outptr = buff;		/* Switch destination for memory */
 8000da4:	6020      	str	r0, [r4, #0]

	va_start(arp, fmt);
	xvprintf(fmt, arp);
 8000da6:	4618      	mov	r0, r3
	va_list arp;


	outptr = buff;		/* Switch destination for memory */

	va_start(arp, fmt);
 8000da8:	9101      	str	r1, [sp, #4]
	xvprintf(fmt, arp);
 8000daa:	f7ff ff14 	bl	8000bd6 <xvprintf>
	va_end(arp);

	*outptr = 0;		/* Terminate output string with a \0 */
 8000dae:	6822      	ldr	r2, [r4, #0]
 8000db0:	2300      	movs	r3, #0
 8000db2:	7013      	strb	r3, [r2, #0]
	outptr = 0;			/* Switch destination for device */
 8000db4:	6023      	str	r3, [r4, #0]
}
 8000db6:	b003      	add	sp, #12
 8000db8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8000dbc:	b003      	add	sp, #12
 8000dbe:	4770      	bx	lr
 8000dc0:	20001ddc 	.word	0x20001ddc

08000dc4 <ili9341_Init>:
  * @brief  Power on the LCD.
  * @param  None
  * @retval None
  */
void ili9341_Init(void)
{
 8000dc4:	b508      	push	{r3, lr}
  /* Initialize ILI9341 low level bus layer ----------------------------------*/
  LCD_IO_Init();
 8000dc6:	f000 fbaf 	bl	8001528 <LCD_IO_Init>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000dca:	20ca      	movs	r0, #202	; 0xca
 8000dcc:	f000 fc24 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000dd0:	20c3      	movs	r0, #195	; 0xc3
 8000dd2:	f000 fc05 	bl	80015e0 <LCD_IO_WriteData>
 8000dd6:	2008      	movs	r0, #8
 8000dd8:	f000 fc02 	bl	80015e0 <LCD_IO_WriteData>
 8000ddc:	2050      	movs	r0, #80	; 0x50
 8000dde:	f000 fbff 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000de2:	20cf      	movs	r0, #207	; 0xcf
 8000de4:	f000 fc18 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000de8:	2000      	movs	r0, #0
 8000dea:	f000 fbf9 	bl	80015e0 <LCD_IO_WriteData>
 8000dee:	20c1      	movs	r0, #193	; 0xc1
 8000df0:	f000 fbf6 	bl	80015e0 <LCD_IO_WriteData>
 8000df4:	2030      	movs	r0, #48	; 0x30
 8000df6:	f000 fbf3 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000dfa:	20ed      	movs	r0, #237	; 0xed
 8000dfc:	f000 fc0c 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e00:	2064      	movs	r0, #100	; 0x64
 8000e02:	f000 fbed 	bl	80015e0 <LCD_IO_WriteData>
 8000e06:	2003      	movs	r0, #3
 8000e08:	f000 fbea 	bl	80015e0 <LCD_IO_WriteData>
 8000e0c:	2012      	movs	r0, #18
 8000e0e:	f000 fbe7 	bl	80015e0 <LCD_IO_WriteData>
 8000e12:	2081      	movs	r0, #129	; 0x81
 8000e14:	f000 fbe4 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e18:	20e8      	movs	r0, #232	; 0xe8
 8000e1a:	f000 fbfd 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e1e:	2085      	movs	r0, #133	; 0x85
 8000e20:	f000 fbde 	bl	80015e0 <LCD_IO_WriteData>
 8000e24:	2000      	movs	r0, #0
 8000e26:	f000 fbdb 	bl	80015e0 <LCD_IO_WriteData>
 8000e2a:	2078      	movs	r0, #120	; 0x78
 8000e2c:	f000 fbd8 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e30:	20cb      	movs	r0, #203	; 0xcb
 8000e32:	f000 fbf1 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e36:	2039      	movs	r0, #57	; 0x39
 8000e38:	f000 fbd2 	bl	80015e0 <LCD_IO_WriteData>
 8000e3c:	202c      	movs	r0, #44	; 0x2c
 8000e3e:	f000 fbcf 	bl	80015e0 <LCD_IO_WriteData>
 8000e42:	2000      	movs	r0, #0
 8000e44:	f000 fbcc 	bl	80015e0 <LCD_IO_WriteData>
 8000e48:	2034      	movs	r0, #52	; 0x34
 8000e4a:	f000 fbc9 	bl	80015e0 <LCD_IO_WriteData>
 8000e4e:	2002      	movs	r0, #2
 8000e50:	f000 fbc6 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e54:	20f7      	movs	r0, #247	; 0xf7
 8000e56:	f000 fbdf 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e5a:	2020      	movs	r0, #32
 8000e5c:	f000 fbc0 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e60:	20ea      	movs	r0, #234	; 0xea
 8000e62:	f000 fbd9 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e66:	2000      	movs	r0, #0
 8000e68:	f000 fbba 	bl	80015e0 <LCD_IO_WriteData>
 8000e6c:	2000      	movs	r0, #0
 8000e6e:	f000 fbb7 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e72:	20b1      	movs	r0, #177	; 0xb1
 8000e74:	f000 fbd0 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e78:	2000      	movs	r0, #0
 8000e7a:	f000 fbb1 	bl	80015e0 <LCD_IO_WriteData>
 8000e7e:	201b      	movs	r0, #27
 8000e80:	f000 fbae 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e84:	20b6      	movs	r0, #182	; 0xb6
 8000e86:	f000 fbc7 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e8a:	200a      	movs	r0, #10
 8000e8c:	f000 fba8 	bl	80015e0 <LCD_IO_WriteData>
 8000e90:	20a2      	movs	r0, #162	; 0xa2
 8000e92:	f000 fba5 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000e96:	20c0      	movs	r0, #192	; 0xc0
 8000e98:	f000 fbbe 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000e9c:	2010      	movs	r0, #16
 8000e9e:	f000 fb9f 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000ea2:	20c1      	movs	r0, #193	; 0xc1
 8000ea4:	f000 fbb8 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000ea8:	2010      	movs	r0, #16
 8000eaa:	f000 fb99 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000eae:	20c5      	movs	r0, #197	; 0xc5
 8000eb0:	f000 fbb2 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000eb4:	2045      	movs	r0, #69	; 0x45
 8000eb6:	f000 fb93 	bl	80015e0 <LCD_IO_WriteData>
 8000eba:	2015      	movs	r0, #21
 8000ebc:	f000 fb90 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000ec0:	20c7      	movs	r0, #199	; 0xc7
 8000ec2:	f000 fba9 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000ec6:	2090      	movs	r0, #144	; 0x90
 8000ec8:	f000 fb8a 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000ecc:	2036      	movs	r0, #54	; 0x36
 8000ece:	f000 fba3 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000ed2:	20c8      	movs	r0, #200	; 0xc8
 8000ed4:	f000 fb84 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000ed8:	20f2      	movs	r0, #242	; 0xf2
 8000eda:	f000 fb9d 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000ede:	2000      	movs	r0, #0
 8000ee0:	f000 fb7e 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000ee4:	20b0      	movs	r0, #176	; 0xb0
 8000ee6:	f000 fb97 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000eea:	20c2      	movs	r0, #194	; 0xc2
 8000eec:	f000 fb78 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000ef0:	20b6      	movs	r0, #182	; 0xb6
 8000ef2:	f000 fb91 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000ef6:	200a      	movs	r0, #10
 8000ef8:	f000 fb72 	bl	80015e0 <LCD_IO_WriteData>
 8000efc:	20a7      	movs	r0, #167	; 0xa7
 8000efe:	f000 fb6f 	bl	80015e0 <LCD_IO_WriteData>
 8000f02:	2027      	movs	r0, #39	; 0x27
 8000f04:	f000 fb6c 	bl	80015e0 <LCD_IO_WriteData>
 8000f08:	2004      	movs	r0, #4
 8000f0a:	f000 fb69 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000f0e:	202a      	movs	r0, #42	; 0x2a
 8000f10:	f000 fb82 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000f14:	2000      	movs	r0, #0
 8000f16:	f000 fb63 	bl	80015e0 <LCD_IO_WriteData>
 8000f1a:	2000      	movs	r0, #0
 8000f1c:	f000 fb60 	bl	80015e0 <LCD_IO_WriteData>
 8000f20:	2000      	movs	r0, #0
 8000f22:	f000 fb5d 	bl	80015e0 <LCD_IO_WriteData>
 8000f26:	20ef      	movs	r0, #239	; 0xef
 8000f28:	f000 fb5a 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000f2c:	202b      	movs	r0, #43	; 0x2b
 8000f2e:	f000 fb73 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000f32:	2000      	movs	r0, #0
 8000f34:	f000 fb54 	bl	80015e0 <LCD_IO_WriteData>
 8000f38:	2000      	movs	r0, #0
 8000f3a:	f000 fb51 	bl	80015e0 <LCD_IO_WriteData>
 8000f3e:	2001      	movs	r0, #1
 8000f40:	f000 fb4e 	bl	80015e0 <LCD_IO_WriteData>
 8000f44:	203f      	movs	r0, #63	; 0x3f
 8000f46:	f000 fb4b 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000f4a:	20f6      	movs	r0, #246	; 0xf6
 8000f4c:	f000 fb64 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000f50:	2001      	movs	r0, #1
 8000f52:	f000 fb45 	bl	80015e0 <LCD_IO_WriteData>
 8000f56:	2000      	movs	r0, #0
 8000f58:	f000 fb42 	bl	80015e0 <LCD_IO_WriteData>
 8000f5c:	2006      	movs	r0, #6
 8000f5e:	f000 fb3f 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000f62:	202c      	movs	r0, #44	; 0x2c
 8000f64:	f000 fb58 	bl	8001618 <LCD_IO_WriteReg>
  ili9341_WriteData(0x01);
  ili9341_WriteData(0x00);
  ili9341_WriteData(0x06);
  
  ili9341_WriteReg(LCD_GRAM);
  LCD_Delay(200);
 8000f68:	20c8      	movs	r0, #200	; 0xc8
 8000f6a:	f000 fb71 	bl	8001650 <LCD_Delay>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000f6e:	2026      	movs	r0, #38	; 0x26
 8000f70:	f000 fb52 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000f74:	2001      	movs	r0, #1
 8000f76:	f000 fb33 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000f7a:	20e0      	movs	r0, #224	; 0xe0
 8000f7c:	f000 fb4c 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000f80:	200f      	movs	r0, #15
 8000f82:	f000 fb2d 	bl	80015e0 <LCD_IO_WriteData>
 8000f86:	2029      	movs	r0, #41	; 0x29
 8000f88:	f000 fb2a 	bl	80015e0 <LCD_IO_WriteData>
 8000f8c:	2024      	movs	r0, #36	; 0x24
 8000f8e:	f000 fb27 	bl	80015e0 <LCD_IO_WriteData>
 8000f92:	200c      	movs	r0, #12
 8000f94:	f000 fb24 	bl	80015e0 <LCD_IO_WriteData>
 8000f98:	200e      	movs	r0, #14
 8000f9a:	f000 fb21 	bl	80015e0 <LCD_IO_WriteData>
 8000f9e:	2009      	movs	r0, #9
 8000fa0:	f000 fb1e 	bl	80015e0 <LCD_IO_WriteData>
 8000fa4:	204e      	movs	r0, #78	; 0x4e
 8000fa6:	f000 fb1b 	bl	80015e0 <LCD_IO_WriteData>
 8000faa:	2078      	movs	r0, #120	; 0x78
 8000fac:	f000 fb18 	bl	80015e0 <LCD_IO_WriteData>
 8000fb0:	203c      	movs	r0, #60	; 0x3c
 8000fb2:	f000 fb15 	bl	80015e0 <LCD_IO_WriteData>
 8000fb6:	2009      	movs	r0, #9
 8000fb8:	f000 fb12 	bl	80015e0 <LCD_IO_WriteData>
 8000fbc:	2013      	movs	r0, #19
 8000fbe:	f000 fb0f 	bl	80015e0 <LCD_IO_WriteData>
 8000fc2:	2005      	movs	r0, #5
 8000fc4:	f000 fb0c 	bl	80015e0 <LCD_IO_WriteData>
 8000fc8:	2017      	movs	r0, #23
 8000fca:	f000 fb09 	bl	80015e0 <LCD_IO_WriteData>
 8000fce:	2011      	movs	r0, #17
 8000fd0:	f000 fb06 	bl	80015e0 <LCD_IO_WriteData>
 8000fd4:	2000      	movs	r0, #0
 8000fd6:	f000 fb03 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8000fda:	20e1      	movs	r0, #225	; 0xe1
 8000fdc:	f000 fb1c 	bl	8001618 <LCD_IO_WriteReg>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteData(uint16_t RegValue)
{
  LCD_IO_WriteData(RegValue);
 8000fe0:	2000      	movs	r0, #0
 8000fe2:	f000 fafd 	bl	80015e0 <LCD_IO_WriteData>
 8000fe6:	2016      	movs	r0, #22
 8000fe8:	f000 fafa 	bl	80015e0 <LCD_IO_WriteData>
 8000fec:	201b      	movs	r0, #27
 8000fee:	f000 faf7 	bl	80015e0 <LCD_IO_WriteData>
 8000ff2:	2004      	movs	r0, #4
 8000ff4:	f000 faf4 	bl	80015e0 <LCD_IO_WriteData>
 8000ff8:	2011      	movs	r0, #17
 8000ffa:	f000 faf1 	bl	80015e0 <LCD_IO_WriteData>
 8000ffe:	2007      	movs	r0, #7
 8001000:	f000 faee 	bl	80015e0 <LCD_IO_WriteData>
 8001004:	2031      	movs	r0, #49	; 0x31
 8001006:	f000 faeb 	bl	80015e0 <LCD_IO_WriteData>
 800100a:	2033      	movs	r0, #51	; 0x33
 800100c:	f000 fae8 	bl	80015e0 <LCD_IO_WriteData>
 8001010:	2042      	movs	r0, #66	; 0x42
 8001012:	f000 fae5 	bl	80015e0 <LCD_IO_WriteData>
 8001016:	2005      	movs	r0, #5
 8001018:	f000 fae2 	bl	80015e0 <LCD_IO_WriteData>
 800101c:	200c      	movs	r0, #12
 800101e:	f000 fadf 	bl	80015e0 <LCD_IO_WriteData>
 8001022:	200a      	movs	r0, #10
 8001024:	f000 fadc 	bl	80015e0 <LCD_IO_WriteData>
 8001028:	2028      	movs	r0, #40	; 0x28
 800102a:	f000 fad9 	bl	80015e0 <LCD_IO_WriteData>
 800102e:	202f      	movs	r0, #47	; 0x2f
 8001030:	f000 fad6 	bl	80015e0 <LCD_IO_WriteData>
 8001034:	200f      	movs	r0, #15
 8001036:	f000 fad3 	bl	80015e0 <LCD_IO_WriteData>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 800103a:	2011      	movs	r0, #17
 800103c:	f000 faec 	bl	8001618 <LCD_IO_WriteReg>
  ili9341_WriteData(0x28);
  ili9341_WriteData(0x2F);
  ili9341_WriteData(0x0F);
  
  ili9341_WriteReg(LCD_SLEEP_OUT);
  LCD_Delay(200);
 8001040:	20c8      	movs	r0, #200	; 0xc8
 8001042:	f000 fb05 	bl	8001650 <LCD_Delay>
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8001046:	2029      	movs	r0, #41	; 0x29
 8001048:	f000 fae6 	bl	8001618 <LCD_IO_WriteReg>
 800104c:	202c      	movs	r0, #44	; 0x2c
  ili9341_WriteReg(LCD_SLEEP_OUT);
  LCD_Delay(200);
  ili9341_WriteReg(LCD_DISPLAY_ON);
  /* GRAM start writing */
  ili9341_WriteReg(LCD_GRAM);
}
 800104e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  * @param  LCD_Reg: address of the selected register.
  * @retval None
  */
void ili9341_WriteReg(uint8_t LCD_Reg)
{
  LCD_IO_WriteReg(LCD_Reg);
 8001052:	f000 bae1 	b.w	8001618 <LCD_IO_WriteReg>

08001056 <stmpe811_Reset>:
  * @brief  Reset the stmpe811 by Software.
  * @param  DeviceAddr: Device address on communication Bus.  
  * @retval None
  */
void stmpe811_Reset(uint16_t DeviceAddr)
{
 8001056:	b510      	push	{r4, lr}
  /* Power Down the stmpe811 */  
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL1, 2);
 8001058:	b2c4      	uxtb	r4, r0
 800105a:	2202      	movs	r2, #2
 800105c:	2103      	movs	r1, #3
 800105e:	4620      	mov	r0, r4
 8001060:	f000 fb24 	bl	80016ac <IOE_Write>

  /* Wait for a delay to ensure registers erasing */
  IOE_Delay(10); 
 8001064:	200a      	movs	r0, #10
 8001066:	f000 fb6d 	bl	8001744 <IOE_Delay>
  
  /* Power On the Codec after the power off => all registers are reinitialized */
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL1, 0);
 800106a:	4620      	mov	r0, r4
 800106c:	2200      	movs	r2, #0
 800106e:	2103      	movs	r1, #3
 8001070:	f000 fb1c 	bl	80016ac <IOE_Write>
  
  /* Wait for a delay to ensure registers erasing */
  IOE_Delay(2); 
 8001074:	2002      	movs	r0, #2
}
 8001076:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  
  /* Power On the Codec after the power off => all registers are reinitialized */
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL1, 0);
  
  /* Wait for a delay to ensure registers erasing */
  IOE_Delay(2); 
 800107a:	f000 bb63 	b.w	8001744 <IOE_Delay>

0800107e <stmpe811_ReadID>:
  * @brief  Read the stmpe811 IO Expander device ID.
  * @param  DeviceAddr: Device address on communication Bus.  
  * @retval The Device ID (two bytes).
  */
uint16_t stmpe811_ReadID(uint16_t DeviceAddr)
{
 800107e:	b538      	push	{r3, r4, r5, lr}
 8001080:	4604      	mov	r4, r0
  /* Initialize IO BUS layer */
  IOE_Init(); 
  
  /* Return the device ID value */
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 8001082:	b2e4      	uxtb	r4, r4
  * @retval The Device ID (two bytes).
  */
uint16_t stmpe811_ReadID(uint16_t DeviceAddr)
{
  /* Initialize IO BUS layer */
  IOE_Init(); 
 8001084:	f000 fae6 	bl	8001654 <IOE_Init>
  
  /* Return the device ID value */
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 8001088:	2100      	movs	r1, #0
 800108a:	4620      	mov	r0, r4
 800108c:	f000 fb28 	bl	80016e0 <IOE_Read>
          (IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_MSB)));
 8001090:	2101      	movs	r1, #1
{
  /* Initialize IO BUS layer */
  IOE_Init(); 
  
  /* Return the device ID value */
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 8001092:	4605      	mov	r5, r0
          (IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_MSB)));
 8001094:	4620      	mov	r0, r4
 8001096:	f000 fb23 	bl	80016e0 <IOE_Read>
{
  /* Initialize IO BUS layer */
  IOE_Init(); 
  
  /* Return the device ID value */
  return ((IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_LSB) << 8) |\
 800109a:	ea40 2005 	orr.w	r0, r0, r5, lsl #8
          (IOE_Read(DeviceAddr, STMPE811_REG_CHP_ID_MSB)));
}
 800109e:	b280      	uxth	r0, r0
 80010a0:	bd38      	pop	{r3, r4, r5, pc}

080010a2 <stmpe811_TS_DetectTouch>:
  * @brief  Return if there is touch detected or not.
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval Touch detected state.
  */
uint8_t stmpe811_TS_DetectTouch(uint16_t DeviceAddr)
{
 80010a2:	b510      	push	{r4, lr}
  uint8_t state;
  uint8_t ret = 0;
  
  state = ((IOE_Read(DeviceAddr, STMPE811_REG_TSC_CTRL) & (uint8_t)STMPE811_TS_CTRL_STATUS) == (uint8_t)0x80);
 80010a4:	b2c4      	uxtb	r4, r0
 80010a6:	2140      	movs	r1, #64	; 0x40
 80010a8:	4620      	mov	r0, r4
 80010aa:	f000 fb19 	bl	80016e0 <IOE_Read>
  
  if(state > 0)
 80010ae:	0603      	lsls	r3, r0, #24
 80010b0:	d507      	bpl.n	80010c2 <stmpe811_TS_DetectTouch+0x20>
  {
    if(IOE_Read(DeviceAddr, STMPE811_REG_FIFO_SIZE) > 0)
 80010b2:	214c      	movs	r1, #76	; 0x4c
 80010b4:	4620      	mov	r0, r4
 80010b6:	f000 fb13 	bl	80016e0 <IOE_Read>
    {
      ret = 1;
 80010ba:	3000      	adds	r0, #0
 80010bc:	bf18      	it	ne
 80010be:	2001      	movne	r0, #1
 80010c0:	bd10      	pop	{r4, pc}
    }
  }
  else
  {
    /* Reset FIFO */
    IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 80010c2:	4620      	mov	r0, r4
 80010c4:	2201      	movs	r2, #1
 80010c6:	214b      	movs	r1, #75	; 0x4b
 80010c8:	f000 faf0 	bl	80016ac <IOE_Write>
    /* Enable the FIFO again */
    IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 80010cc:	4620      	mov	r0, r4
 80010ce:	2200      	movs	r2, #0
 80010d0:	214b      	movs	r1, #75	; 0x4b
 80010d2:	f000 faeb 	bl	80016ac <IOE_Write>
  * @retval Touch detected state.
  */
uint8_t stmpe811_TS_DetectTouch(uint16_t DeviceAddr)
{
  uint8_t state;
  uint8_t ret = 0;
 80010d6:	2000      	movs	r0, #0
    /* Enable the FIFO again */
    IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
  }
  
  return ret;
}
 80010d8:	bd10      	pop	{r4, pc}

080010da <stmpe811_TS_GetXY>:
  * @param  X: Pointer to X position value
  * @param  Y: Pointer to Y position value   
  * @retval None.
  */
void stmpe811_TS_GetXY(uint16_t DeviceAddr, uint16_t *X, uint16_t *Y)
{
 80010da:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint8_t  dataXYZ[4];
  uint32_t uldataXYZ;
  
  IOE_ReadMultiple(DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC, dataXYZ, sizeof(dataXYZ)) ;
 80010dc:	2304      	movs	r3, #4
 80010de:	b2c4      	uxtb	r4, r0
  * @param  X: Pointer to X position value
  * @param  Y: Pointer to Y position value   
  * @retval None.
  */
void stmpe811_TS_GetXY(uint16_t DeviceAddr, uint16_t *X, uint16_t *Y)
{
 80010e0:	460e      	mov	r6, r1
 80010e2:	4615      	mov	r5, r2
  uint8_t  dataXYZ[4];
  uint32_t uldataXYZ;
  
  IOE_ReadMultiple(DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC, dataXYZ, sizeof(dataXYZ)) ;
 80010e4:	21d7      	movs	r1, #215	; 0xd7
 80010e6:	eb0d 0203 	add.w	r2, sp, r3
 80010ea:	4620      	mov	r0, r4
 80010ec:	f000 fb14 	bl	8001718 <IOE_ReadMultiple>
 80010f0:	9b01      	ldr	r3, [sp, #4]
 80010f2:	ba1b      	rev	r3, r3
  
  /* Calculate positions values */
  uldataXYZ = (dataXYZ[0] << 24)|(dataXYZ[1] << 16)|(dataXYZ[2] << 8)|(dataXYZ[3] << 0);     
  *X = (uldataXYZ >> 20) & 0x00000FFF;     
 80010f4:	0d1a      	lsrs	r2, r3, #20
  *Y = (uldataXYZ >>  8) & 0x00000FFF;     
 80010f6:	f3c3 230b 	ubfx	r3, r3, #8, #12
  
  IOE_ReadMultiple(DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC, dataXYZ, sizeof(dataXYZ)) ;
  
  /* Calculate positions values */
  uldataXYZ = (dataXYZ[0] << 24)|(dataXYZ[1] << 16)|(dataXYZ[2] << 8)|(dataXYZ[3] << 0);     
  *X = (uldataXYZ >> 20) & 0x00000FFF;     
 80010fa:	8032      	strh	r2, [r6, #0]
  *Y = (uldataXYZ >>  8) & 0x00000FFF;     
  
  /* Reset FIFO */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 80010fc:	4620      	mov	r0, r4
  IOE_ReadMultiple(DeviceAddr, STMPE811_REG_TSC_DATA_NON_INC, dataXYZ, sizeof(dataXYZ)) ;
  
  /* Calculate positions values */
  uldataXYZ = (dataXYZ[0] << 24)|(dataXYZ[1] << 16)|(dataXYZ[2] << 8)|(dataXYZ[3] << 0);     
  *X = (uldataXYZ >> 20) & 0x00000FFF;     
  *Y = (uldataXYZ >>  8) & 0x00000FFF;     
 80010fe:	802b      	strh	r3, [r5, #0]
  
  /* Reset FIFO */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 8001100:	2201      	movs	r2, #1
 8001102:	214b      	movs	r1, #75	; 0x4b
 8001104:	f000 fad2 	bl	80016ac <IOE_Write>
  /* Enable the FIFO again */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 8001108:	2200      	movs	r2, #0
 800110a:	214b      	movs	r1, #75	; 0x4b
 800110c:	4620      	mov	r0, r4
 800110e:	f000 facd 	bl	80016ac <IOE_Write>
}
 8001112:	b002      	add	sp, #8
 8001114:	bd70      	pop	{r4, r5, r6, pc}
	...

08001118 <stmpe811_Init>:
  * @brief  Initialize the stmpe811 and configure the needed hardware resources
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval None
  */
void stmpe811_Init(uint16_t DeviceAddr)
{
 8001118:	b510      	push	{r4, lr}
  uint8_t idx = 0;
  
  /* Check all the registered instances */
  for(idx = 0; idx < STMPE811_MAX_INSTANCE ; idx ++)
  {
    if(stmpe811[idx] == DeviceAddr)
 800111a:	4b0a      	ldr	r3, [pc, #40]	; (8001144 <stmpe811_Init+0x2c>)
 800111c:	781a      	ldrb	r2, [r3, #0]
 800111e:	4290      	cmp	r0, r2
  * @brief  Initialize the stmpe811 and configure the needed hardware resources
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval None
  */
void stmpe811_Init(uint16_t DeviceAddr)
{
 8001120:	4604      	mov	r4, r0
  uint8_t idx = 0;
  
  /* Check all the registered instances */
  for(idx = 0; idx < STMPE811_MAX_INSTANCE ; idx ++)
  {
    if(stmpe811[idx] == DeviceAddr)
 8001122:	d00e      	beq.n	8001142 <stmpe811_Init+0x2a>
 8001124:	7859      	ldrb	r1, [r3, #1]
 8001126:	4288      	cmp	r0, r1
 8001128:	d100      	bne.n	800112c <stmpe811_Init+0x14>
 800112a:	bd10      	pop	{r4, pc}
 800112c:	b10a      	cbz	r2, 8001132 <stmpe811_Init+0x1a>
 800112e:	b941      	cbnz	r1, 8001142 <stmpe811_Init+0x2a>
static uint8_t stmpe811_GetInstance(uint16_t DeviceAddr)
{
  uint8_t idx = 0;
  
  /* Check all the registered instances */
  for(idx = 0; idx < STMPE811_MAX_INSTANCE ; idx ++)
 8001130:	2201      	movs	r2, #1
    empty = stmpe811_GetInstance(0);
    
    if(empty < STMPE811_MAX_INSTANCE)
    {
      /* Register the current device instance */
      stmpe811[empty] = DeviceAddr;
 8001132:	549c      	strb	r4, [r3, r2]
      
      /* Initialize IO BUS layer */
      IOE_Init(); 
 8001134:	f000 fa8e 	bl	8001654 <IOE_Init>
      
      /* Generate stmpe811 Software reset */
      stmpe811_Reset(DeviceAddr);
 8001138:	4620      	mov	r0, r4
    }
  }
}
 800113a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      
      /* Initialize IO BUS layer */
      IOE_Init(); 
      
      /* Generate stmpe811 Software reset */
      stmpe811_Reset(DeviceAddr);
 800113e:	f7ff bf8a 	b.w	8001056 <stmpe811_Reset>
 8001142:	bd10      	pop	{r4, pc}
 8001144:	20001de0 	.word	0x20001de0

08001148 <stmpe811_EnableGlobalIT>:
  * @brief  Enable the Global interrupt.
  * @param  DeviceAddr: Device address on communication Bus.       
  * @retval None
  */
void stmpe811_EnableGlobalIT(uint16_t DeviceAddr)
{
 8001148:	b510      	push	{r4, lr}
  uint8_t tmp = 0;
  
  /* Read the Interrupt Control register  */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_CTRL);
 800114a:	b2c4      	uxtb	r4, r0
 800114c:	2109      	movs	r1, #9
 800114e:	4620      	mov	r0, r4
 8001150:	f000 fac6 	bl	80016e0 <IOE_Read>
  
  /* Set the global interrupts to be Enabled */    
  tmp |= (uint8_t)STMPE811_GIT_EN;
  
  /* Write Back the Interrupt Control register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp); 
 8001154:	f040 0201 	orr.w	r2, r0, #1
 8001158:	b2d2      	uxtb	r2, r2
 800115a:	4620      	mov	r0, r4
 800115c:	2109      	movs	r1, #9
}
 800115e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  
  /* Set the global interrupts to be Enabled */    
  tmp |= (uint8_t)STMPE811_GIT_EN;
  
  /* Write Back the Interrupt Control register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp); 
 8001162:	f000 baa3 	b.w	80016ac <IOE_Write>

08001166 <stmpe811_DisableGlobalIT>:
  * @brief  Disable the Global interrupt.
  * @param  DeviceAddr: Device address on communication Bus.      
  * @retval None
  */
void stmpe811_DisableGlobalIT(uint16_t DeviceAddr)
{
 8001166:	b510      	push	{r4, lr}
  uint8_t tmp = 0;
  
  /* Read the Interrupt Control register  */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_CTRL);
 8001168:	b2c4      	uxtb	r4, r0
 800116a:	2109      	movs	r1, #9
 800116c:	4620      	mov	r0, r4
 800116e:	f000 fab7 	bl	80016e0 <IOE_Read>

  /* Set the global interrupts to be Disabled */    
  tmp &= ~(uint8_t)STMPE811_GIT_EN;
 
  /* Write Back the Interrupt Control register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp);
 8001172:	2109      	movs	r1, #9
 8001174:	f000 02fe 	and.w	r2, r0, #254	; 0xfe
 8001178:	4620      	mov	r0, r4
    
}
 800117a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  /* Set the global interrupts to be Disabled */    
  tmp &= ~(uint8_t)STMPE811_GIT_EN;
 
  /* Write Back the Interrupt Control register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_CTRL, tmp);
 800117e:	f000 ba95 	b.w	80016ac <IOE_Write>

08001182 <stmpe811_EnableITSource>:
  *   @arg  STMPE811_GIT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  STMPE811_GIT_TOUCH : Touch Screen Controller Touch Detected interrupt  
  * @retval None
  */
void stmpe811_EnableITSource(uint16_t DeviceAddr, uint8_t Source)
{
 8001182:	b538      	push	{r3, r4, r5, lr}
  uint8_t tmp = 0;
  
  /* Get the current value of the INT_EN register */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 8001184:	b2c5      	uxtb	r5, r0
  *   @arg  STMPE811_GIT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  STMPE811_GIT_TOUCH : Touch Screen Controller Touch Detected interrupt  
  * @retval None
  */
void stmpe811_EnableITSource(uint16_t DeviceAddr, uint8_t Source)
{
 8001186:	460c      	mov	r4, r1
  uint8_t tmp = 0;
  
  /* Get the current value of the INT_EN register */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 8001188:	4628      	mov	r0, r5
 800118a:	210a      	movs	r1, #10
 800118c:	f000 faa8 	bl	80016e0 <IOE_Read>

  /* Set the interrupts to be Enabled */    
  tmp |= Source; 
  
  /* Set the register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 8001190:	ea40 0204 	orr.w	r2, r0, r4
 8001194:	b2d2      	uxtb	r2, r2
 8001196:	4628      	mov	r0, r5
 8001198:	210a      	movs	r1, #10
}
 800119a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Set the interrupts to be Enabled */    
  tmp |= Source; 
  
  /* Set the register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 800119e:	f000 ba85 	b.w	80016ac <IOE_Write>

080011a2 <stmpe811_TS_EnableIT>:
  * @brief  Configure the selected source to generate a global interrupt or not
  * @param  DeviceAddr: Device address on communication Bus.  
  * @retval None
  */
void stmpe811_TS_EnableIT(uint16_t DeviceAddr)
{
 80011a2:	b510      	push	{r4, lr}
 80011a4:	4604      	mov	r4, r0
  IOE_ITConfig();
 80011a6:	f000 fa57 	bl	8001658 <IOE_ITConfig>
  
  /* Enable global TS IT source */
  stmpe811_EnableITSource(DeviceAddr, STMPE811_TS_IT); 
 80011aa:	4620      	mov	r0, r4
 80011ac:	211f      	movs	r1, #31
 80011ae:	f7ff ffe8 	bl	8001182 <stmpe811_EnableITSource>
  
  /* Enable global interrupt */
  stmpe811_EnableGlobalIT(DeviceAddr);
 80011b2:	4620      	mov	r0, r4
}
 80011b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  
  /* Enable global TS IT source */
  stmpe811_EnableITSource(DeviceAddr, STMPE811_TS_IT); 
  
  /* Enable global interrupt */
  stmpe811_EnableGlobalIT(DeviceAddr);
 80011b8:	f7ff bfc6 	b.w	8001148 <stmpe811_EnableGlobalIT>

080011bc <stmpe811_DisableITSource>:
  *   @arg  STMPE811_GIT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  STMPE811_GIT_TOUCH : Touch Screen Controller Touch Detected interrupt  
  * @retval None
  */
void stmpe811_DisableITSource(uint16_t DeviceAddr, uint8_t Source)
{
 80011bc:	b538      	push	{r3, r4, r5, lr}
  uint8_t tmp = 0;
  
  /* Get the current value of the INT_EN register */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 80011be:	b2c5      	uxtb	r5, r0
  *   @arg  STMPE811_GIT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  STMPE811_GIT_TOUCH : Touch Screen Controller Touch Detected interrupt  
  * @retval None
  */
void stmpe811_DisableITSource(uint16_t DeviceAddr, uint8_t Source)
{
 80011c0:	460c      	mov	r4, r1
  uint8_t tmp = 0;
  
  /* Get the current value of the INT_EN register */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_INT_EN);
 80011c2:	4628      	mov	r0, r5
 80011c4:	210a      	movs	r1, #10
 80011c6:	f000 fa8b 	bl	80016e0 <IOE_Read>

  /* Set the interrupts to be Enabled */    
  tmp &= ~Source; 
 80011ca:	ea20 0204 	bic.w	r2, r0, r4
  
  /* Set the register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 80011ce:	b2d2      	uxtb	r2, r2
 80011d0:	4628      	mov	r0, r5
 80011d2:	210a      	movs	r1, #10
}
 80011d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Set the interrupts to be Enabled */    
  tmp &= ~Source; 
  
  /* Set the register */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_EN, tmp);   
 80011d8:	f000 ba68 	b.w	80016ac <IOE_Write>

080011dc <stmpe811_TS_DisableIT>:
  * @brief  Configure the selected source to generate a global interrupt or not
  * @param  DeviceAddr: Device address on communication Bus.    
  * @retval None
  */
void stmpe811_TS_DisableIT(uint16_t DeviceAddr)
{
 80011dc:	b510      	push	{r4, lr}
 80011de:	4604      	mov	r4, r0
  /* Disable global interrupt */
  stmpe811_DisableGlobalIT(DeviceAddr);
 80011e0:	f7ff ffc1 	bl	8001166 <stmpe811_DisableGlobalIT>
  
  /* Disable global TS IT source */
  stmpe811_DisableITSource(DeviceAddr, STMPE811_TS_IT); 
 80011e4:	4620      	mov	r0, r4
 80011e6:	211f      	movs	r1, #31
}
 80011e8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
  /* Disable global interrupt */
  stmpe811_DisableGlobalIT(DeviceAddr);
  
  /* Disable global TS IT source */
  stmpe811_DisableITSource(DeviceAddr, STMPE811_TS_IT); 
 80011ec:	f7ff bfe6 	b.w	80011bc <stmpe811_DisableITSource>

080011f0 <stmpe811_ReadGITStatus>:
  *   @arg  STMPE811_GIT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  STMPE811_GIT_TOUCH : Touch Screen Controller Touch Detected interrupt      
  * @retval The checked Global interrupt source status.
  */
uint8_t stmpe811_ReadGITStatus(uint16_t DeviceAddr, uint8_t Source)
{
 80011f0:	b510      	push	{r4, lr}
  /* Return the global IT source status */
  return((IOE_Read(DeviceAddr, STMPE811_REG_INT_STA) & Source));
 80011f2:	b2c0      	uxtb	r0, r0
  *   @arg  STMPE811_GIT_FTH : Touch Screen Controller FIFO Threshold interrupt   
  *   @arg  STMPE811_GIT_TOUCH : Touch Screen Controller Touch Detected interrupt      
  * @retval The checked Global interrupt source status.
  */
uint8_t stmpe811_ReadGITStatus(uint16_t DeviceAddr, uint8_t Source)
{
 80011f4:	460c      	mov	r4, r1
  /* Return the global IT source status */
  return((IOE_Read(DeviceAddr, STMPE811_REG_INT_STA) & Source));
 80011f6:	210b      	movs	r1, #11
 80011f8:	f000 fa72 	bl	80016e0 <IOE_Read>
}
 80011fc:	4020      	ands	r0, r4
 80011fe:	bd10      	pop	{r4, pc}

08001200 <stmpe811_TS_ITStatus>:
  * @retval TS interrupts status
  */
uint8_t stmpe811_TS_ITStatus(uint16_t DeviceAddr)
{
  /* Return TS interrupts status */
  return(stmpe811_ReadGITStatus(DeviceAddr, STMPE811_TS_IT));
 8001200:	211f      	movs	r1, #31
 8001202:	f7ff bff5 	b.w	80011f0 <stmpe811_ReadGITStatus>

08001206 <stmpe811_ClearGlobalIT>:
  * @retval None
  */
void stmpe811_ClearGlobalIT(uint16_t DeviceAddr, uint8_t Source)
{
  /* Write 1 to the bits that have to be cleared */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_STA, Source);
 8001206:	460a      	mov	r2, r1
 8001208:	b2c0      	uxtb	r0, r0
 800120a:	210b      	movs	r1, #11
 800120c:	f000 ba4e 	b.w	80016ac <IOE_Write>

08001210 <stmpe811_TS_ClearIT>:
  * @retval None
  */
void stmpe811_TS_ClearIT(uint16_t DeviceAddr)
{
  /* Clear the global TS IT source */
  stmpe811_ClearGlobalIT(DeviceAddr, STMPE811_TS_IT);
 8001210:	211f      	movs	r1, #31
 8001212:	f7ff bff8 	b.w	8001206 <stmpe811_ClearGlobalIT>

08001216 <stmpe811_IO_EnableAF>:
  *         combination of the following values:
  *   @arg  STMPE811_PIN_x: Where x can be from 0 to 7.       
  * @retval None
  */
void stmpe811_IO_EnableAF(uint16_t DeviceAddr, uint32_t IO_Pin)
{
 8001216:	b538      	push	{r3, r4, r5, lr}
  uint8_t tmp = 0;
  
  /* Get the current register value */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_IO_AF);
 8001218:	b2c5      	uxtb	r5, r0
  *         combination of the following values:
  *   @arg  STMPE811_PIN_x: Where x can be from 0 to 7.       
  * @retval None
  */
void stmpe811_IO_EnableAF(uint16_t DeviceAddr, uint32_t IO_Pin)
{
 800121a:	460c      	mov	r4, r1
  uint8_t tmp = 0;
  
  /* Get the current register value */
  tmp = IOE_Read(DeviceAddr, STMPE811_REG_IO_AF);
 800121c:	4628      	mov	r0, r5
 800121e:	2117      	movs	r1, #23
 8001220:	f000 fa5e 	bl	80016e0 <IOE_Read>

  /* Enable the selected pins alternate function */   
  tmp &= ~(uint8_t)IO_Pin;   
 8001224:	ea20 0204 	bic.w	r2, r0, r4
  
  /* Write back the new register value */
  IOE_Write(DeviceAddr, STMPE811_REG_IO_AF, tmp); 
 8001228:	b2d2      	uxtb	r2, r2
 800122a:	4628      	mov	r0, r5
 800122c:	2117      	movs	r1, #23
}
 800122e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  /* Enable the selected pins alternate function */   
  tmp &= ~(uint8_t)IO_Pin;   
  
  /* Write back the new register value */
  IOE_Write(DeviceAddr, STMPE811_REG_IO_AF, tmp); 
 8001232:	f000 ba3b 	b.w	80016ac <IOE_Write>

08001236 <stmpe811_TS_Start>:
  * @brief  Configures the touch Screen Controller (Single point detection)
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval None.
  */
void stmpe811_TS_Start(uint16_t DeviceAddr)
{
 8001236:	b570      	push	{r4, r5, r6, lr}
  uint8_t mode;
  
  /* Get the current register value */
  mode = IOE_Read(DeviceAddr, STMPE811_REG_SYS_CTRL2);
 8001238:	b2c4      	uxtb	r4, r0
  * @brief  Configures the touch Screen Controller (Single point detection)
  * @param  DeviceAddr: Device address on communication Bus.
  * @retval None.
  */
void stmpe811_TS_Start(uint16_t DeviceAddr)
{
 800123a:	4606      	mov	r6, r0
  uint8_t mode;
  
  /* Get the current register value */
  mode = IOE_Read(DeviceAddr, STMPE811_REG_SYS_CTRL2);
 800123c:	2104      	movs	r1, #4
 800123e:	4620      	mov	r0, r4
 8001240:	f000 fa4e 	bl	80016e0 <IOE_Read>
  
  /* Set the Functionalities to be Enabled */    
  mode &= ~(STMPE811_IO_FCT);  
  
  /* Write the new register value */  
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL2, mode); 
 8001244:	2104      	movs	r1, #4
 8001246:	f000 02fb 	and.w	r2, r0, #251	; 0xfb
void stmpe811_TS_Start(uint16_t DeviceAddr)
{
  uint8_t mode;
  
  /* Get the current register value */
  mode = IOE_Read(DeviceAddr, STMPE811_REG_SYS_CTRL2);
 800124a:	4605      	mov	r5, r0
  
  /* Set the Functionalities to be Enabled */    
  mode &= ~(STMPE811_IO_FCT);  
  
  /* Write the new register value */  
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL2, mode); 
 800124c:	4620      	mov	r0, r4
 800124e:	f000 fa2d 	bl	80016ac <IOE_Write>

  /* Select TSC pins in TSC alternate mode */  
  stmpe811_IO_EnableAF(DeviceAddr, STMPE811_TOUCH_IO_ALL);
 8001252:	4630      	mov	r0, r6
 8001254:	21f0      	movs	r1, #240	; 0xf0
 8001256:	f7ff ffde 	bl	8001216 <stmpe811_IO_EnableAF>
  
  /* Set the Functionalities to be Enabled */    
  mode &= ~(STMPE811_TS_FCT | STMPE811_ADC_FCT);  
  
  /* Set the new register value */  
  IOE_Write(DeviceAddr, STMPE811_REG_SYS_CTRL2, mode); 
 800125a:	f005 02f8 	and.w	r2, r5, #248	; 0xf8
 800125e:	4620      	mov	r0, r4
 8001260:	2104      	movs	r1, #4
 8001262:	f000 fa23 	bl	80016ac <IOE_Write>
  
  /* Select Sample Time, bit number and ADC Reference */
  IOE_Write(DeviceAddr, STMPE811_REG_ADC_CTRL1, 0x49);
 8001266:	2249      	movs	r2, #73	; 0x49
 8001268:	2120      	movs	r1, #32
 800126a:	4620      	mov	r0, r4
 800126c:	f000 fa1e 	bl	80016ac <IOE_Write>
  
  /* Wait for 2 ms */
  IOE_Delay(2); 
 8001270:	2002      	movs	r0, #2
 8001272:	f000 fa67 	bl	8001744 <IOE_Delay>
  
  /* Select the ADC clock speed: 3.25 MHz */
  IOE_Write(DeviceAddr, STMPE811_REG_ADC_CTRL2, 0x01);
 8001276:	4620      	mov	r0, r4
 8001278:	2201      	movs	r2, #1
 800127a:	2121      	movs	r1, #33	; 0x21
 800127c:	f000 fa16 	bl	80016ac <IOE_Write>
  /* Configuration: 
     - Touch average control    : 4 samples
     - Touch delay time         : 500 uS
     - Panel driver setting time: 500 uS 
  */
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_CFG, 0x9A); 
 8001280:	4620      	mov	r0, r4
 8001282:	229a      	movs	r2, #154	; 0x9a
 8001284:	2141      	movs	r1, #65	; 0x41
 8001286:	f000 fa11 	bl	80016ac <IOE_Write>
  
  /* Configure the Touch FIFO threshold: single point reading */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_TH, 0x01);
 800128a:	4620      	mov	r0, r4
 800128c:	2201      	movs	r2, #1
 800128e:	214a      	movs	r1, #74	; 0x4a
 8001290:	f000 fa0c 	bl	80016ac <IOE_Write>
  
  /* Clear the FIFO memory content. */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x01);
 8001294:	4620      	mov	r0, r4
 8001296:	2201      	movs	r2, #1
 8001298:	214b      	movs	r1, #75	; 0x4b
 800129a:	f000 fa07 	bl	80016ac <IOE_Write>
  
  /* Put the FIFO back into operation mode  */
  IOE_Write(DeviceAddr, STMPE811_REG_FIFO_STA, 0x00);
 800129e:	4620      	mov	r0, r4
 80012a0:	2200      	movs	r2, #0
 80012a2:	214b      	movs	r1, #75	; 0x4b
 80012a4:	f000 fa02 	bl	80016ac <IOE_Write>
  
  /* Set the range and accuracy pf the pressure measurement (Z) : 
     - Fractional part :7 
     - Whole part      :1 
  */
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_FRACT_XYZ, 0x01);
 80012a8:	4620      	mov	r0, r4
 80012aa:	2201      	movs	r2, #1
 80012ac:	2156      	movs	r1, #86	; 0x56
 80012ae:	f000 f9fd 	bl	80016ac <IOE_Write>
  
  /* Set the driving capability (limit) of the device for TSC pins: 50mA */
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_I_DRIVE, 0x01);
 80012b2:	4620      	mov	r0, r4
 80012b4:	2201      	movs	r2, #1
 80012b6:	2158      	movs	r1, #88	; 0x58
 80012b8:	f000 f9f8 	bl	80016ac <IOE_Write>
  
  /* Touch screen control configuration (enable TSC):
     - No window tracking index
     - XYZ acquisition mode
   */
  IOE_Write(DeviceAddr, STMPE811_REG_TSC_CTRL, 0x01);
 80012bc:	4620      	mov	r0, r4
 80012be:	2201      	movs	r2, #1
 80012c0:	2140      	movs	r1, #64	; 0x40
 80012c2:	f000 f9f3 	bl	80016ac <IOE_Write>
  
  /*  Clear all the status pending bits if any */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_STA, 0xFF);
 80012c6:	4620      	mov	r0, r4
 80012c8:	22ff      	movs	r2, #255	; 0xff
 80012ca:	210b      	movs	r1, #11
 80012cc:	f000 f9ee 	bl	80016ac <IOE_Write>

  /* Wait for 2 ms delay */
  IOE_Delay(2); 
 80012d0:	2002      	movs	r0, #2
}
 80012d2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  
  /*  Clear all the status pending bits if any */
  IOE_Write(DeviceAddr, STMPE811_REG_INT_STA, 0xFF);

  /* Wait for 2 ms delay */
  IOE_Delay(2); 
 80012d6:	f000 ba35 	b.w	8001744 <IOE_Delay>
	...

080012dc <SPIx_Init>:

/**
  * @brief  SPIx Bus initialization
  */
static void SPIx_Init(void)
{
 80012dc:	b510      	push	{r4, lr}
  if(HAL_SPI_GetState(&SpiHandle) == HAL_SPI_STATE_RESET)
 80012de:	4c21      	ldr	r4, [pc, #132]	; (8001364 <SPIx_Init+0x88>)

/**
  * @brief  SPIx Bus initialization
  */
static void SPIx_Init(void)
{
 80012e0:	b088      	sub	sp, #32
  if(HAL_SPI_GetState(&SpiHandle) == HAL_SPI_STATE_RESET)
 80012e2:	4620      	mov	r0, r4
 80012e4:	f002 fb49 	bl	800397a <HAL_SPI_GetState>
 80012e8:	2800      	cmp	r0, #0
 80012ea:	d138      	bne.n	800135e <SPIx_Init+0x82>
  {
    /* SPI configuration -----------------------------------------------------*/
    SpiHandle.Instance = DISCOVERY_SPIx;
 80012ec:	4b1e      	ldr	r3, [pc, #120]	; (8001368 <SPIx_Init+0x8c>)
 80012ee:	6023      	str	r3, [r4, #0]
       to verify these constraints:
       - ILI9341 LCD SPI interface max baudrate is 10MHz for write and 6.66MHz for read
       - l3gd20 SPI interface max baudrate is 10MHz for write/read
       - PCLK2 frequency is set to 90 MHz 
    */  
    SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
 80012f0:	2318      	movs	r3, #24
 80012f2:	61e3      	str	r3, [r4, #28]
    /* Note: To read a register a LCD, SPI_DIRECTION_1LINE should be set */
    SpiHandle.Init.Direction      = SPI_DIRECTION_2LINES;
    SpiHandle.Init.CLKPhase       = SPI_PHASE_1EDGE;
    SpiHandle.Init.CLKPolarity    = SPI_POLARITY_LOW;
    SpiHandle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
    SpiHandle.Init.CRCPolynomial  = 7;
 80012f4:	2307      	movs	r3, #7
 80012f6:	62e3      	str	r3, [r4, #44]	; 0x2c
    SpiHandle.Init.DataSize       = SPI_DATASIZE_8BIT;
    SpiHandle.Init.FirstBit       = SPI_FIRSTBIT_MSB;
    SpiHandle.Init.NSS            = SPI_NSS_SOFT;
 80012f8:	f44f 7300 	mov.w	r3, #512	; 0x200
 80012fc:	61a3      	str	r3, [r4, #24]
    SpiHandle.Init.TIMode         = SPI_TIMODE_DISABLED;
    SpiHandle.Init.Mode           = SPI_MODE_MASTER;
 80012fe:	f44f 7382 	mov.w	r3, #260	; 0x104
 8001302:	6063      	str	r3, [r4, #4]
static void SPIx_MspInit(SPI_HandleTypeDef *hspi)
{
  GPIO_InitTypeDef   GPIO_InitStructure;

  /* Enable SPIx clock */
  DISCOVERY_SPIx_CLK_ENABLE();
 8001304:	4b19      	ldr	r3, [pc, #100]	; (800136c <SPIx_Init+0x90>)
 8001306:	9001      	str	r0, [sp, #4]
    SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;

    /* On STM32F429I-Discovery, LCD ID cannot be read then keep a common configuration */
    /* for LCD and GYRO (SPI_DIRECTION_2LINES) */
    /* Note: To read a register a LCD, SPI_DIRECTION_1LINE should be set */
    SpiHandle.Init.Direction      = SPI_DIRECTION_2LINES;
 8001308:	60a0      	str	r0, [r4, #8]
    SpiHandle.Init.CLKPhase       = SPI_PHASE_1EDGE;
 800130a:	6160      	str	r0, [r4, #20]
    SpiHandle.Init.CLKPolarity    = SPI_POLARITY_LOW;
 800130c:	6120      	str	r0, [r4, #16]
    SpiHandle.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLED;
 800130e:	62a0      	str	r0, [r4, #40]	; 0x28
    SpiHandle.Init.CRCPolynomial  = 7;
    SpiHandle.Init.DataSize       = SPI_DATASIZE_8BIT;
 8001310:	60e0      	str	r0, [r4, #12]
    SpiHandle.Init.FirstBit       = SPI_FIRSTBIT_MSB;
 8001312:	6220      	str	r0, [r4, #32]
    SpiHandle.Init.NSS            = SPI_NSS_SOFT;
    SpiHandle.Init.TIMode         = SPI_TIMODE_DISABLED;
 8001314:	6260      	str	r0, [r4, #36]	; 0x24
static void SPIx_MspInit(SPI_HandleTypeDef *hspi)
{
  GPIO_InitTypeDef   GPIO_InitStructure;

  /* Enable SPIx clock */
  DISCOVERY_SPIx_CLK_ENABLE();
 8001316:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001318:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800131c:	645a      	str	r2, [r3, #68]	; 0x44
 800131e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001320:	f402 1280 	and.w	r2, r2, #1048576	; 0x100000
 8001324:	9201      	str	r2, [sp, #4]
 8001326:	9a01      	ldr	r2, [sp, #4]

  /* Enable DISCOVERY_SPI GPIO clock */
  DISCOVERY_SPIx_GPIO_CLK_ENABLE();
 8001328:	9002      	str	r0, [sp, #8]
 800132a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  GPIO_InitStructure.Pin    = (DISCOVERY_SPIx_SCK_PIN | DISCOVERY_SPIx_MOSI_PIN | DISCOVERY_SPIx_MISO_PIN);
  GPIO_InitStructure.Mode   = GPIO_MODE_AF_PP;
  GPIO_InitStructure.Pull   = GPIO_PULLDOWN;
  GPIO_InitStructure.Speed  = GPIO_SPEED_MEDIUM;
  GPIO_InitStructure.Alternate = DISCOVERY_SPIx_AF;
  HAL_GPIO_Init(DISCOVERY_SPIx_GPIO_PORT, &GPIO_InitStructure);      
 800132c:	4810      	ldr	r0, [pc, #64]	; (8001370 <SPIx_Init+0x94>)

  /* Enable SPIx clock */
  DISCOVERY_SPIx_CLK_ENABLE();

  /* Enable DISCOVERY_SPI GPIO clock */
  DISCOVERY_SPIx_GPIO_CLK_ENABLE();
 800132e:	f042 0220 	orr.w	r2, r2, #32
 8001332:	631a      	str	r2, [r3, #48]	; 0x30
 8001334:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001336:	f003 0320 	and.w	r3, r3, #32
 800133a:	9302      	str	r3, [sp, #8]
 800133c:	9b02      	ldr	r3, [sp, #8]

  /* configure SPI SCK, MOSI and MISO */    
  GPIO_InitStructure.Pin    = (DISCOVERY_SPIx_SCK_PIN | DISCOVERY_SPIx_MOSI_PIN | DISCOVERY_SPIx_MISO_PIN);
 800133e:	f44f 7360 	mov.w	r3, #896	; 0x380
 8001342:	9303      	str	r3, [sp, #12]
  GPIO_InitStructure.Mode   = GPIO_MODE_AF_PP;
 8001344:	2302      	movs	r3, #2
 8001346:	9304      	str	r3, [sp, #16]
  GPIO_InitStructure.Pull   = GPIO_PULLDOWN;
 8001348:	9305      	str	r3, [sp, #20]
  GPIO_InitStructure.Speed  = GPIO_SPEED_MEDIUM;
 800134a:	2301      	movs	r3, #1
 800134c:	9306      	str	r3, [sp, #24]
  GPIO_InitStructure.Alternate = DISCOVERY_SPIx_AF;
  HAL_GPIO_Init(DISCOVERY_SPIx_GPIO_PORT, &GPIO_InitStructure);      
 800134e:	a903      	add	r1, sp, #12
  /* configure SPI SCK, MOSI and MISO */    
  GPIO_InitStructure.Pin    = (DISCOVERY_SPIx_SCK_PIN | DISCOVERY_SPIx_MOSI_PIN | DISCOVERY_SPIx_MISO_PIN);
  GPIO_InitStructure.Mode   = GPIO_MODE_AF_PP;
  GPIO_InitStructure.Pull   = GPIO_PULLDOWN;
  GPIO_InitStructure.Speed  = GPIO_SPEED_MEDIUM;
  GPIO_InitStructure.Alternate = DISCOVERY_SPIx_AF;
 8001350:	2305      	movs	r3, #5
 8001352:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(DISCOVERY_SPIx_GPIO_PORT, &GPIO_InitStructure);      
 8001354:	f000 fd36 	bl	8001dc4 <HAL_GPIO_Init>
    SpiHandle.Init.NSS            = SPI_NSS_SOFT;
    SpiHandle.Init.TIMode         = SPI_TIMODE_DISABLED;
    SpiHandle.Init.Mode           = SPI_MODE_MASTER;
  
    SPIx_MspInit(&SpiHandle);
    HAL_SPI_Init(&SpiHandle);
 8001358:	4620      	mov	r0, r4
 800135a:	f002 fa0d 	bl	8003778 <HAL_SPI_Init>
  } 
}
 800135e:	b008      	add	sp, #32
 8001360:	bd10      	pop	{r4, pc}
 8001362:	bf00      	nop
 8001364:	20001de4 	.word	0x20001de4
 8001368:	40015000 	.word	0x40015000
 800136c:	40023800 	.word	0x40023800
 8001370:	40021400 	.word	0x40021400

08001374 <I2Cx_Init>:

/**
  * @brief  I2Cx Bus initialization.
  */
static void I2Cx_Init(void)
{
 8001374:	b570      	push	{r4, r5, r6, lr}
  if(HAL_I2C_GetState(&I2cHandle) == HAL_I2C_STATE_RESET)
 8001376:	4e33      	ldr	r6, [pc, #204]	; (8001444 <I2Cx_Init+0xd0>)

/**
  * @brief  I2Cx Bus initialization.
  */
static void I2Cx_Init(void)
{
 8001378:	b088      	sub	sp, #32
  if(HAL_I2C_GetState(&I2cHandle) == HAL_I2C_STATE_RESET)
 800137a:	4630      	mov	r0, r6
 800137c:	f001 fa88 	bl	8002890 <HAL_I2C_GetState>
 8001380:	4604      	mov	r4, r0
 8001382:	2800      	cmp	r0, #0
 8001384:	d15b      	bne.n	800143e <I2Cx_Init+0xca>
  {
    I2cHandle.Instance              = DISCOVERY_I2Cx;
    I2cHandle.Init.ClockSpeed       = BSP_I2C_SPEED;
 8001386:	4a30      	ldr	r2, [pc, #192]	; (8001448 <I2Cx_Init+0xd4>)
 8001388:	4b30      	ldr	r3, [pc, #192]	; (800144c <I2Cx_Init+0xd8>)

  if (hi2c->Instance == DISCOVERY_I2Cx)
  {
    /* Configure the GPIOs ---------------------------------------------------*/ 
    /* Enable GPIO clock */
    DISCOVERY_I2Cx_SDA_GPIO_CLK_ENABLE();
 800138a:	4d31      	ldr	r5, [pc, #196]	; (8001450 <I2Cx_Init+0xdc>)
 800138c:	9000      	str	r0, [sp, #0]
static void I2Cx_Init(void)
{
  if(HAL_I2C_GetState(&I2cHandle) == HAL_I2C_STATE_RESET)
  {
    I2cHandle.Instance              = DISCOVERY_I2Cx;
    I2cHandle.Init.ClockSpeed       = BSP_I2C_SPEED;
 800138e:	e886 000c 	stmia.w	r6, {r2, r3}
    I2cHandle.Init.DutyCycle        = I2C_DUTYCYCLE_2;
    I2cHandle.Init.OwnAddress1      = 0;
    I2cHandle.Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8001392:	f44f 4380 	mov.w	r3, #16384	; 0x4000
{
  if(HAL_I2C_GetState(&I2cHandle) == HAL_I2C_STATE_RESET)
  {
    I2cHandle.Instance              = DISCOVERY_I2Cx;
    I2cHandle.Init.ClockSpeed       = BSP_I2C_SPEED;
    I2cHandle.Init.DutyCycle        = I2C_DUTYCYCLE_2;
 8001396:	60b0      	str	r0, [r6, #8]
    I2cHandle.Init.OwnAddress1      = 0;
 8001398:	60f0      	str	r0, [r6, #12]
    I2cHandle.Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
    I2cHandle.Init.DualAddressMode  = I2C_DUALADDRESS_DISABLED;
 800139a:	6170      	str	r0, [r6, #20]
    I2cHandle.Init.OwnAddress2      = 0;
 800139c:	61b0      	str	r0, [r6, #24]
    I2cHandle.Init.GeneralCallMode  = I2C_GENERALCALL_DISABLED;
 800139e:	61f0      	str	r0, [r6, #28]
    I2cHandle.Init.NoStretchMode    = I2C_NOSTRETCH_DISABLED;  
 80013a0:	6230      	str	r0, [r6, #32]
  {
    I2cHandle.Instance              = DISCOVERY_I2Cx;
    I2cHandle.Init.ClockSpeed       = BSP_I2C_SPEED;
    I2cHandle.Init.DutyCycle        = I2C_DUTYCYCLE_2;
    I2cHandle.Init.OwnAddress1      = 0;
    I2cHandle.Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 80013a2:	6133      	str	r3, [r6, #16]

  if (hi2c->Instance == DISCOVERY_I2Cx)
  {
    /* Configure the GPIOs ---------------------------------------------------*/ 
    /* Enable GPIO clock */
    DISCOVERY_I2Cx_SDA_GPIO_CLK_ENABLE();
 80013a4:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013a6:	f043 0304 	orr.w	r3, r3, #4
 80013aa:	632b      	str	r3, [r5, #48]	; 0x30
 80013ac:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013ae:	f003 0304 	and.w	r3, r3, #4
 80013b2:	9300      	str	r3, [sp, #0]
 80013b4:	9b00      	ldr	r3, [sp, #0]
    DISCOVERY_I2Cx_SCL_GPIO_CLK_ENABLE();
 80013b6:	9001      	str	r0, [sp, #4]
 80013b8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80013ba:	f043 0301 	orr.w	r3, r3, #1
 80013be:	632b      	str	r3, [r5, #48]	; 0x30
 80013c0:	6b2b      	ldr	r3, [r5, #48]	; 0x30
      
    /* Configure I2C Tx as alternate function  */
    GPIO_InitStruct.Pin       = DISCOVERY_I2Cx_SCL_PIN;
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull      = GPIO_NOPULL;
 80013c2:	9005      	str	r0, [sp, #20]
  if (hi2c->Instance == DISCOVERY_I2Cx)
  {
    /* Configure the GPIOs ---------------------------------------------------*/ 
    /* Enable GPIO clock */
    DISCOVERY_I2Cx_SDA_GPIO_CLK_ENABLE();
    DISCOVERY_I2Cx_SCL_GPIO_CLK_ENABLE();
 80013c4:	f003 0301 	and.w	r3, r3, #1
 80013c8:	9301      	str	r3, [sp, #4]
 80013ca:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStruct.Pin       = DISCOVERY_I2Cx_SCL_PIN;
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull      = GPIO_NOPULL;
    GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
    GPIO_InitStruct.Alternate = DISCOVERY_I2Cx_SCL_SDA_AF;
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 80013cc:	4821      	ldr	r0, [pc, #132]	; (8001454 <I2Cx_Init+0xe0>)
    /* Enable GPIO clock */
    DISCOVERY_I2Cx_SDA_GPIO_CLK_ENABLE();
    DISCOVERY_I2Cx_SCL_GPIO_CLK_ENABLE();
      
    /* Configure I2C Tx as alternate function  */
    GPIO_InitStruct.Pin       = DISCOVERY_I2Cx_SCL_PIN;
 80013ce:	f44f 7380 	mov.w	r3, #256	; 0x100
 80013d2:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
 80013d4:	2312      	movs	r3, #18
 80013d6:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull      = GPIO_NOPULL;
    GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
 80013d8:	2302      	movs	r3, #2
 80013da:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = DISCOVERY_I2Cx_SCL_SDA_AF;
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 80013dc:	a903      	add	r1, sp, #12
    /* Configure I2C Tx as alternate function  */
    GPIO_InitStruct.Pin       = DISCOVERY_I2Cx_SCL_PIN;
    GPIO_InitStruct.Mode      = GPIO_MODE_AF_OD;
    GPIO_InitStruct.Pull      = GPIO_NOPULL;
    GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
    GPIO_InitStruct.Alternate = DISCOVERY_I2Cx_SCL_SDA_AF;
 80013de:	2304      	movs	r3, #4
 80013e0:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
 80013e2:	f000 fcef 	bl	8001dc4 <HAL_GPIO_Init>
      
    /* Configure I2C Rx as alternate function  */
    GPIO_InitStruct.Pin = DISCOVERY_I2Cx_SDA_PIN;
 80013e6:	f44f 7300 	mov.w	r3, #512	; 0x200
    HAL_GPIO_Init(DISCOVERY_I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
 80013ea:	a903      	add	r1, sp, #12
 80013ec:	481a      	ldr	r0, [pc, #104]	; (8001458 <I2Cx_Init+0xe4>)
    GPIO_InitStruct.Speed     = GPIO_SPEED_FAST;
    GPIO_InitStruct.Alternate = DISCOVERY_I2Cx_SCL_SDA_AF;
    HAL_GPIO_Init(DISCOVERY_I2Cx_SCL_GPIO_PORT, &GPIO_InitStruct);
      
    /* Configure I2C Rx as alternate function  */
    GPIO_InitStruct.Pin = DISCOVERY_I2Cx_SDA_PIN;
 80013ee:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(DISCOVERY_I2Cx_SDA_GPIO_PORT, &GPIO_InitStruct);
 80013f0:	f000 fce8 	bl	8001dc4 <HAL_GPIO_Init>
    
    
    /* Configure the Discovery I2Cx peripheral -------------------------------*/ 
    /* Enable I2C3 clock */
    DISCOVERY_I2Cx_CLOCK_ENABLE();
 80013f4:	9402      	str	r4, [sp, #8]
 80013f6:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80013f8:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 80013fc:	642b      	str	r3, [r5, #64]	; 0x40
 80013fe:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8001400:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8001404:	9302      	str	r3, [sp, #8]
 8001406:	9b02      	ldr	r3, [sp, #8]
    
    /* Force the I2C Peripheral Clock Reset */  
    DISCOVERY_I2Cx_FORCE_RESET();
 8001408:	6a2b      	ldr	r3, [r5, #32]
 800140a:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 800140e:	622b      	str	r3, [r5, #32]
      
    /* Release the I2C Peripheral Clock Reset */  
    DISCOVERY_I2Cx_RELEASE_RESET(); 
 8001410:	6a2b      	ldr	r3, [r5, #32]
 8001412:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8001416:	622b      	str	r3, [r5, #32]
    
    /* Enable and set Discovery I2Cx Interrupt to the highest priority */
    HAL_NVIC_SetPriority(DISCOVERY_I2Cx_EV_IRQn, 0x00, 0);
 8001418:	4622      	mov	r2, r4
 800141a:	4621      	mov	r1, r4
 800141c:	2048      	movs	r0, #72	; 0x48
 800141e:	f000 fb79 	bl	8001b14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_I2Cx_EV_IRQn);
 8001422:	2048      	movs	r0, #72	; 0x48
 8001424:	f000 fbaa 	bl	8001b7c <HAL_NVIC_EnableIRQ>
    
    /* Enable and set Discovery I2Cx Interrupt to the highest priority */
    HAL_NVIC_SetPriority(DISCOVERY_I2Cx_ER_IRQn, 0x00, 0);
 8001428:	4622      	mov	r2, r4
 800142a:	4621      	mov	r1, r4
 800142c:	2049      	movs	r0, #73	; 0x49
 800142e:	f000 fb71 	bl	8001b14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(DISCOVERY_I2Cx_ER_IRQn);  
 8001432:	2049      	movs	r0, #73	; 0x49
 8001434:	f000 fba2 	bl	8001b7c <HAL_NVIC_EnableIRQ>
    I2cHandle.Init.GeneralCallMode  = I2C_GENERALCALL_DISABLED;
    I2cHandle.Init.NoStretchMode    = I2C_NOSTRETCH_DISABLED;  
    
    /* Init the I2C */
    I2Cx_MspInit(&I2cHandle);
    HAL_I2C_Init(&I2cHandle);
 8001438:	4630      	mov	r0, r6
 800143a:	f001 f827 	bl	800248c <HAL_I2C_Init>
  }
}
 800143e:	b008      	add	sp, #32
 8001440:	bd70      	pop	{r4, r5, r6, pc}
 8001442:	bf00      	nop
 8001444:	20002188 	.word	0x20002188
 8001448:	40005c00 	.word	0x40005c00
 800144c:	000186a0 	.word	0x000186a0
 8001450:	40023800 	.word	0x40023800
 8001454:	40020000 	.word	0x40020000
 8001458:	40020800 	.word	0x40020800

0800145c <I2Cx_Error>:

/**
  * @brief  I2Cx error treatment function
  */
static void I2Cx_Error(void)
{
 800145c:	b508      	push	{r3, lr}
  /* De-initialize the SPI communication BUS */
  HAL_I2C_DeInit(&I2cHandle);
 800145e:	4803      	ldr	r0, [pc, #12]	; (800146c <I2Cx_Error+0x10>)
 8001460:	f001 f882 	bl	8002568 <HAL_I2C_DeInit>
  
  /* Re-Initialize the SPI communication BUS */
  I2Cx_Init();
}
 8001464:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
{
  /* De-initialize the SPI communication BUS */
  HAL_I2C_DeInit(&I2cHandle);
  
  /* Re-Initialize the SPI communication BUS */
  I2Cx_Init();
 8001468:	f7ff bf84 	b.w	8001374 <I2Cx_Init>
 800146c:	20002188 	.word	0x20002188

08001470 <SPIx_Write>:
/**
  * @brief  Writes a byte to device.
  * @param  Value: value to be written
  */
static void SPIx_Write(uint16_t Value)
{
 8001470:	b507      	push	{r0, r1, r2, lr}
  HAL_StatusTypeDef status = HAL_OK;
  
  status = HAL_SPI_Transmit(&SpiHandle, (uint8_t*) &Value, 1, SpixTimeout);
 8001472:	4b09      	ldr	r3, [pc, #36]	; (8001498 <SPIx_Write+0x28>)
/**
  * @brief  Writes a byte to device.
  * @param  Value: value to be written
  */
static void SPIx_Write(uint16_t Value)
{
 8001474:	a902      	add	r1, sp, #8
  HAL_StatusTypeDef status = HAL_OK;
  
  status = HAL_SPI_Transmit(&SpiHandle, (uint8_t*) &Value, 1, SpixTimeout);
 8001476:	681b      	ldr	r3, [r3, #0]
/**
  * @brief  Writes a byte to device.
  * @param  Value: value to be written
  */
static void SPIx_Write(uint16_t Value)
{
 8001478:	f821 0d02 	strh.w	r0, [r1, #-2]!
  HAL_StatusTypeDef status = HAL_OK;
  
  status = HAL_SPI_Transmit(&SpiHandle, (uint8_t*) &Value, 1, SpixTimeout);
 800147c:	2201      	movs	r2, #1
 800147e:	4807      	ldr	r0, [pc, #28]	; (800149c <SPIx_Write+0x2c>)
 8001480:	f002 f9ce 	bl	8003820 <HAL_SPI_Transmit>
  
  /* Check the communication status */
  if(status != HAL_OK)
 8001484:	b120      	cbz	r0, 8001490 <SPIx_Write+0x20>
  * @brief  SPIx error treatment function.
  */
static void SPIx_Error(void)
{
  /* De-initialize the SPI communication BUS */
  HAL_SPI_DeInit(&SpiHandle);
 8001486:	4805      	ldr	r0, [pc, #20]	; (800149c <SPIx_Write+0x2c>)
 8001488:	f002 f9b4 	bl	80037f4 <HAL_SPI_DeInit>
  
  /* Re- Initialize the SPI communication BUS */
  SPIx_Init();
 800148c:	f7ff ff26 	bl	80012dc <SPIx_Init>
  if(status != HAL_OK)
  {
    /* Re-Initialize the BUS */
    SPIx_Error();
  }
}
 8001490:	b003      	add	sp, #12
 8001492:	f85d fb04 	ldr.w	pc, [sp], #4
 8001496:	bf00      	nop
 8001498:	2000004c 	.word	0x2000004c
 800149c:	20001de4 	.word	0x20001de4

080014a0 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_GPIO: Button will be used as simple IO 
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability  
  */
void BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
 80014a0:	b510      	push	{r4, lr}
 80014a2:	b086      	sub	sp, #24
  GPIO_InitTypeDef GPIO_InitStruct;
  
  /* Enable the BUTTON Clock */
  BUTTONx_GPIO_CLK_ENABLE(Button);
 80014a4:	b950      	cbnz	r0, 80014bc <BSP_PB_Init+0x1c>
 80014a6:	4b18      	ldr	r3, [pc, #96]	; (8001508 <BSP_PB_Init+0x68>)
 80014a8:	9000      	str	r0, [sp, #0]
 80014aa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80014ac:	f042 0201 	orr.w	r2, r2, #1
 80014b0:	631a      	str	r2, [r3, #48]	; 0x30
 80014b2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80014b4:	f003 0301 	and.w	r3, r3, #1
 80014b8:	9300      	str	r3, [sp, #0]
 80014ba:	9b00      	ldr	r3, [sp, #0]
  
  if (ButtonMode == BUTTON_MODE_GPIO)
 80014bc:	b961      	cbnz	r1, 80014d8 <BSP_PB_Init+0x38>
  {
    /* Configure Button pin as input */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80014be:	2301      	movs	r3, #1
 80014c0:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80014c2:	2302      	movs	r3, #2
 80014c4:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
 80014c6:	9304      	str	r3, [sp, #16]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80014c8:	4b10      	ldr	r3, [pc, #64]	; (800150c <BSP_PB_Init+0x6c>)
  
  if (ButtonMode == BUTTON_MODE_GPIO)
  {
    /* Configure Button pin as input */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 80014ca:	9102      	str	r1, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_PULLDOWN;
    GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80014cc:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80014d0:	a901      	add	r1, sp, #4
 80014d2:	f000 fc77 	bl	8001dc4 <HAL_GPIO_Init>
 80014d6:	e014      	b.n	8001502 <BSP_PB_Init+0x62>
  }
  
  if (ButtonMode == BUTTON_MODE_EXTI)
 80014d8:	2901      	cmp	r1, #1
 80014da:	d112      	bne.n	8001502 <BSP_PB_Init+0x62>
  {
    /* Configure Button pin as input with External interrupt */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; 
 80014dc:	4b0c      	ldr	r3, [pc, #48]	; (8001510 <BSP_PB_Init+0x70>)
 80014de:	9302      	str	r3, [sp, #8]
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80014e0:	4b0a      	ldr	r3, [pc, #40]	; (800150c <BSP_PB_Init+0x6c>)
  }
  
  if (ButtonMode == BUTTON_MODE_EXTI)
  {
    /* Configure Button pin as input with External interrupt */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
 80014e2:	9101      	str	r1, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; 
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80014e4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
  
  if (ButtonMode == BUTTON_MODE_EXTI)
  {
    /* Configure Button pin as input with External interrupt */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014e8:	2400      	movs	r4, #0
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; 
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80014ea:	a901      	add	r1, sp, #4
  
  if (ButtonMode == BUTTON_MODE_EXTI)
  {
    /* Configure Button pin as input with External interrupt */
    GPIO_InitStruct.Pin = BUTTON_PIN[Button];
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80014ec:	9403      	str	r4, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; 
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_InitStruct);
 80014ee:	f000 fc69 	bl	8001dc4 <HAL_GPIO_Init>
    
    /* Enable and set Button EXTI Interrupt to the lowest priority */
    HAL_NVIC_SetPriority((IRQn_Type)(BUTTON_IRQn[Button]), 0x0F, 0x00);
 80014f2:	2006      	movs	r0, #6
 80014f4:	4622      	mov	r2, r4
 80014f6:	210f      	movs	r1, #15
 80014f8:	f000 fb0c 	bl	8001b14 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ((IRQn_Type)(BUTTON_IRQn[Button]));
 80014fc:	2006      	movs	r0, #6
 80014fe:	f000 fb3d 	bl	8001b7c <HAL_NVIC_EnableIRQ>
  }
}
 8001502:	b006      	add	sp, #24
 8001504:	bd10      	pop	{r4, pc}
 8001506:	bf00      	nop
 8001508:	40023800 	.word	0x40023800
 800150c:	20000050 	.word	0x20000050
 8001510:	10110000 	.word	0x10110000

08001514 <BSP_PB_GetState>:
  * @param  Button: Specifies the Button to be checked.
  *   This parameter should be: BUTTON_KEY  
  * @retval The Button GPIO pin value.
  */
uint32_t BSP_PB_GetState(Button_TypeDef Button)
{
 8001514:	b508      	push	{r3, lr}
  return HAL_GPIO_ReadPin(BUTTON_PORT[Button], BUTTON_PIN[Button]);
 8001516:	4b03      	ldr	r3, [pc, #12]	; (8001524 <BSP_PB_GetState+0x10>)
 8001518:	2101      	movs	r1, #1
 800151a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 800151e:	f000 fde3 	bl	80020e8 <HAL_GPIO_ReadPin>
}
 8001522:	bd08      	pop	{r3, pc}
 8001524:	20000050 	.word	0x20000050

08001528 <LCD_IO_Init>:

/**
  * @brief  Configures the LCD_SPI interface.
  */
void LCD_IO_Init(void)
{
 8001528:	b5f0      	push	{r4, r5, r6, r7, lr}
  GPIO_InitTypeDef GPIO_InitStructure;
  
  if(Is_LCD_IO_Initialized == 0)
 800152a:	4b29      	ldr	r3, [pc, #164]	; (80015d0 <LCD_IO_Init+0xa8>)
 800152c:	781d      	ldrb	r5, [r3, #0]

/**
  * @brief  Configures the LCD_SPI interface.
  */
void LCD_IO_Init(void)
{
 800152e:	b089      	sub	sp, #36	; 0x24
  GPIO_InitTypeDef GPIO_InitStructure;
  
  if(Is_LCD_IO_Initialized == 0)
 8001530:	2d00      	cmp	r5, #0
 8001532:	d14a      	bne.n	80015ca <LCD_IO_Init+0xa2>
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
 8001534:	4c27      	ldr	r4, [pc, #156]	; (80015d4 <LCD_IO_Init+0xac>)
 8001536:	9500      	str	r5, [sp, #0]
{
  GPIO_InitTypeDef GPIO_InitStructure;
  
  if(Is_LCD_IO_Initialized == 0)
  {
    Is_LCD_IO_Initialized = 1; 
 8001538:	2601      	movs	r6, #1
 800153a:	701e      	strb	r6, [r3, #0]
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
 800153c:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
 800153e:	4826      	ldr	r0, [pc, #152]	; (80015d8 <LCD_IO_Init+0xb0>)
  if(Is_LCD_IO_Initialized == 0)
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
 8001540:	f043 0308 	orr.w	r3, r3, #8
 8001544:	6323      	str	r3, [r4, #48]	; 0x30
 8001546:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
 8001548:	9604      	str	r6, [sp, #16]
  if(Is_LCD_IO_Initialized == 0)
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
 800154a:	f003 0308 	and.w	r3, r3, #8
 800154e:	9300      	str	r3, [sp, #0]
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 8001550:	2702      	movs	r7, #2
  if(Is_LCD_IO_Initialized == 0)
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
 8001552:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
 8001554:	9505      	str	r5, [sp, #20]
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
 8001556:	f44f 5300 	mov.w	r3, #8192	; 0x2000
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
 800155a:	a903      	add	r1, sp, #12
  {
    Is_LCD_IO_Initialized = 1; 
    
    /* Configure NCS in Output Push-Pull mode */
    LCD_WRX_GPIO_CLK_ENABLE();
    GPIO_InitStructure.Pin     = LCD_WRX_PIN;
 800155c:	9303      	str	r3, [sp, #12]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 800155e:	9706      	str	r7, [sp, #24]
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
 8001560:	f000 fc30 	bl	8001dc4 <HAL_GPIO_Init>
    
    LCD_RDX_GPIO_CLK_ENABLE();
 8001564:	9501      	str	r5, [sp, #4]
 8001566:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
 8001568:	481b      	ldr	r0, [pc, #108]	; (80015d8 <LCD_IO_Init+0xb0>)
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
    
    LCD_RDX_GPIO_CLK_ENABLE();
 800156a:	f043 0308 	orr.w	r3, r3, #8
 800156e:	6323      	str	r3, [r4, #48]	; 0x30
 8001570:	6b23      	ldr	r3, [r4, #48]	; 0x30
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
 8001572:	9604      	str	r6, [sp, #16]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
    
    LCD_RDX_GPIO_CLK_ENABLE();
 8001574:	f003 0308 	and.w	r3, r3, #8
 8001578:	9301      	str	r3, [sp, #4]
 800157a:	9b01      	ldr	r3, [sp, #4]
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
 800157c:	9505      	str	r5, [sp, #20]
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
    
    LCD_RDX_GPIO_CLK_ENABLE();
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
 800157e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
 8001582:	a903      	add	r1, sp, #12
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_WRX_GPIO_PORT, &GPIO_InitStructure);
    
    LCD_RDX_GPIO_CLK_ENABLE();
    GPIO_InitStructure.Pin     = LCD_RDX_PIN;
 8001584:	9303      	str	r3, [sp, #12]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 8001586:	9706      	str	r7, [sp, #24]
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
 8001588:	f000 fc1c 	bl	8001dc4 <HAL_GPIO_Init>
    
    /* Configure the LCD Control pins ----------------------------------------*/
    LCD_NCS_GPIO_CLK_ENABLE();
 800158c:	9502      	str	r5, [sp, #8]
 800158e:	6b23      	ldr	r3, [r4, #48]	; 0x30
    /* Configure NCS in Output Push-Pull mode */
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
 8001590:	4812      	ldr	r0, [pc, #72]	; (80015dc <LCD_IO_Init+0xb4>)
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
    
    /* Configure the LCD Control pins ----------------------------------------*/
    LCD_NCS_GPIO_CLK_ENABLE();
 8001592:	f043 0304 	orr.w	r3, r3, #4
 8001596:	6323      	str	r3, [r4, #48]	; 0x30
 8001598:	6b23      	ldr	r3, [r4, #48]	; 0x30
    
    /* Configure NCS in Output Push-Pull mode */
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
 800159a:	9604      	str	r6, [sp, #16]
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
    
    /* Configure the LCD Control pins ----------------------------------------*/
    LCD_NCS_GPIO_CLK_ENABLE();
 800159c:	f003 0304 	and.w	r3, r3, #4
    
    /* Configure NCS in Output Push-Pull mode */
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
 80015a0:	2404      	movs	r4, #4
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
    
    /* Configure the LCD Control pins ----------------------------------------*/
    LCD_NCS_GPIO_CLK_ENABLE();
 80015a2:	9302      	str	r3, [sp, #8]
    /* Configure NCS in Output Push-Pull mode */
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
 80015a4:	a903      	add	r1, sp, #12
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
    HAL_GPIO_Init(LCD_RDX_GPIO_PORT, &GPIO_InitStructure);
    
    /* Configure the LCD Control pins ----------------------------------------*/
    LCD_NCS_GPIO_CLK_ENABLE();
 80015a6:	9b02      	ldr	r3, [sp, #8]
    
    /* Configure NCS in Output Push-Pull mode */
    GPIO_InitStructure.Pin     = LCD_NCS_PIN;
 80015a8:	9403      	str	r4, [sp, #12]
    GPIO_InitStructure.Mode    = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStructure.Pull    = GPIO_NOPULL;
 80015aa:	9505      	str	r5, [sp, #20]
    GPIO_InitStructure.Speed   = GPIO_SPEED_FAST;
 80015ac:	9706      	str	r7, [sp, #24]
    HAL_GPIO_Init(LCD_NCS_GPIO_PORT, &GPIO_InitStructure);
 80015ae:	f000 fc09 	bl	8001dc4 <HAL_GPIO_Init>
    
    /* Set or Reset the control line */
    LCD_CS_LOW();
 80015b2:	462a      	mov	r2, r5
 80015b4:	4621      	mov	r1, r4
 80015b6:	4809      	ldr	r0, [pc, #36]	; (80015dc <LCD_IO_Init+0xb4>)
 80015b8:	f000 fd9c 	bl	80020f4 <HAL_GPIO_WritePin>
    LCD_CS_HIGH();
 80015bc:	4632      	mov	r2, r6
 80015be:	4621      	mov	r1, r4
 80015c0:	4806      	ldr	r0, [pc, #24]	; (80015dc <LCD_IO_Init+0xb4>)
 80015c2:	f000 fd97 	bl	80020f4 <HAL_GPIO_WritePin>
    
    SPIx_Init();
 80015c6:	f7ff fe89 	bl	80012dc <SPIx_Init>
  }
}
 80015ca:	b009      	add	sp, #36	; 0x24
 80015cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80015ce:	bf00      	nop
 80015d0:	20001e3c 	.word	0x20001e3c
 80015d4:	40023800 	.word	0x40023800
 80015d8:	40020c00 	.word	0x40020c00
 80015dc:	40020800 	.word	0x40020800

080015e0 <LCD_IO_WriteData>:

/**
  * @brief  Writes register value.
  */
void LCD_IO_WriteData(uint16_t RegValue) 
{
 80015e0:	b538      	push	{r3, r4, r5, lr}
  /* Set WRX to send data */
  LCD_WRX_HIGH();
  
  /* Reset LCD control line(/CS) and Send data */  
  LCD_CS_LOW();
 80015e2:	4c0b      	ldr	r4, [pc, #44]	; (8001610 <LCD_IO_WriteData+0x30>)

/**
  * @brief  Writes register value.
  */
void LCD_IO_WriteData(uint16_t RegValue) 
{
 80015e4:	4605      	mov	r5, r0
  /* Set WRX to send data */
  LCD_WRX_HIGH();
 80015e6:	2201      	movs	r2, #1
 80015e8:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 80015ec:	4809      	ldr	r0, [pc, #36]	; (8001614 <LCD_IO_WriteData+0x34>)
 80015ee:	f000 fd81 	bl	80020f4 <HAL_GPIO_WritePin>
  
  /* Reset LCD control line(/CS) and Send data */  
  LCD_CS_LOW();
 80015f2:	2200      	movs	r2, #0
 80015f4:	2104      	movs	r1, #4
 80015f6:	4620      	mov	r0, r4
 80015f8:	f000 fd7c 	bl	80020f4 <HAL_GPIO_WritePin>
  SPIx_Write(RegValue);
 80015fc:	4628      	mov	r0, r5
 80015fe:	f7ff ff37 	bl	8001470 <SPIx_Write>
  
  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 8001602:	4620      	mov	r0, r4
 8001604:	2201      	movs	r2, #1
 8001606:	2104      	movs	r1, #4
}
 8001608:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Reset LCD control line(/CS) and Send data */  
  LCD_CS_LOW();
  SPIx_Write(RegValue);
  
  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 800160c:	f000 bd72 	b.w	80020f4 <HAL_GPIO_WritePin>
 8001610:	40020800 	.word	0x40020800
 8001614:	40020c00 	.word	0x40020c00

08001618 <LCD_IO_WriteReg>:

/**
  * @brief  Writes register address.
  */
void LCD_IO_WriteReg(uint8_t Reg) 
{
 8001618:	b538      	push	{r3, r4, r5, lr}
  /* Reset WRX to send command */
  LCD_WRX_LOW();
  
  /* Reset LCD control line(/CS) and Send command */
  LCD_CS_LOW();
 800161a:	4c0b      	ldr	r4, [pc, #44]	; (8001648 <LCD_IO_WriteReg+0x30>)

/**
  * @brief  Writes register address.
  */
void LCD_IO_WriteReg(uint8_t Reg) 
{
 800161c:	4605      	mov	r5, r0
  /* Reset WRX to send command */
  LCD_WRX_LOW();
 800161e:	2200      	movs	r2, #0
 8001620:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 8001624:	4809      	ldr	r0, [pc, #36]	; (800164c <LCD_IO_WriteReg+0x34>)
 8001626:	f000 fd65 	bl	80020f4 <HAL_GPIO_WritePin>
  
  /* Reset LCD control line(/CS) and Send command */
  LCD_CS_LOW();
 800162a:	2200      	movs	r2, #0
 800162c:	2104      	movs	r1, #4
 800162e:	4620      	mov	r0, r4
 8001630:	f000 fd60 	bl	80020f4 <HAL_GPIO_WritePin>
  SPIx_Write(Reg);
 8001634:	4628      	mov	r0, r5
 8001636:	f7ff ff1b 	bl	8001470 <SPIx_Write>
  
  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 800163a:	4620      	mov	r0, r4
 800163c:	2201      	movs	r2, #1
 800163e:	2104      	movs	r1, #4
}
 8001640:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Reset LCD control line(/CS) and Send command */
  LCD_CS_LOW();
  SPIx_Write(Reg);
  
  /* Deselect: Chip Select high */
  LCD_CS_HIGH();
 8001644:	f000 bd56 	b.w	80020f4 <HAL_GPIO_WritePin>
 8001648:	40020800 	.word	0x40020800
 800164c:	40020c00 	.word	0x40020c00

08001650 <LCD_Delay>:
 8001650:	f000 ba40 	b.w	8001ad4 <HAL_Delay>

08001654 <IOE_Init>:
/**
  * @brief  IOE Low Level Initialization.
  */
void IOE_Init(void) 
{
  I2Cx_Init();
 8001654:	f7ff be8e 	b.w	8001374 <I2Cx_Init>

08001658 <IOE_ITConfig>:

/**
  * @brief  IOE Low Level Interrupt configuration.
  */
void IOE_ITConfig(void)
{
 8001658:	b510      	push	{r4, lr}
 800165a:	b086      	sub	sp, #24
static void I2Cx_ITConfig(void)
{
  GPIO_InitTypeDef  GPIO_InitStruct;
    
  /* Enable the GPIO EXTI Clock */
  STMPE811_INT_CLK_ENABLE();
 800165c:	2400      	movs	r4, #0
 800165e:	4b10      	ldr	r3, [pc, #64]	; (80016a0 <IOE_ITConfig+0x48>)
 8001660:	9400      	str	r4, [sp, #0]
 8001662:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  
  GPIO_InitStruct.Pin   = STMPE811_INT_PIN;
  GPIO_InitStruct.Pull  = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  GPIO_InitStruct.Mode  = GPIO_MODE_IT_FALLING;
  HAL_GPIO_Init(STMPE811_INT_GPIO_PORT, &GPIO_InitStruct);
 8001664:	480f      	ldr	r0, [pc, #60]	; (80016a4 <IOE_ITConfig+0x4c>)
static void I2Cx_ITConfig(void)
{
  GPIO_InitTypeDef  GPIO_InitStruct;
    
  /* Enable the GPIO EXTI Clock */
  STMPE811_INT_CLK_ENABLE();
 8001666:	f042 0201 	orr.w	r2, r2, #1
 800166a:	631a      	str	r2, [r3, #48]	; 0x30
 800166c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  
  GPIO_InitStruct.Pin   = STMPE811_INT_PIN;
  GPIO_InitStruct.Pull  = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
 800166e:	9404      	str	r4, [sp, #16]
static void I2Cx_ITConfig(void)
{
  GPIO_InitTypeDef  GPIO_InitStruct;
    
  /* Enable the GPIO EXTI Clock */
  STMPE811_INT_CLK_ENABLE();
 8001670:	f003 0301 	and.w	r3, r3, #1
 8001674:	9300      	str	r3, [sp, #0]
 8001676:	9b00      	ldr	r3, [sp, #0]
  
  GPIO_InitStruct.Pin   = STMPE811_INT_PIN;
 8001678:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800167c:	9301      	str	r3, [sp, #4]
  GPIO_InitStruct.Pull  = GPIO_PULLUP;
 800167e:	2301      	movs	r3, #1
 8001680:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  GPIO_InitStruct.Mode  = GPIO_MODE_IT_FALLING;
  HAL_GPIO_Init(STMPE811_INT_GPIO_PORT, &GPIO_InitStruct);
 8001682:	a901      	add	r1, sp, #4
  STMPE811_INT_CLK_ENABLE();
  
  GPIO_InitStruct.Pin   = STMPE811_INT_PIN;
  GPIO_InitStruct.Pull  = GPIO_PULLUP;
  GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
  GPIO_InitStruct.Mode  = GPIO_MODE_IT_FALLING;
 8001684:	4b08      	ldr	r3, [pc, #32]	; (80016a8 <IOE_ITConfig+0x50>)
 8001686:	9302      	str	r3, [sp, #8]
  HAL_GPIO_Init(STMPE811_INT_GPIO_PORT, &GPIO_InitStruct);
 8001688:	f000 fb9c 	bl	8001dc4 <HAL_GPIO_Init>
    
  /* Enable and set GPIO EXTI Interrupt to the highest priority */
  HAL_NVIC_SetPriority((IRQn_Type)(STMPE811_INT_EXTI), 0x00, 0x00);
 800168c:	4622      	mov	r2, r4
 800168e:	4621      	mov	r1, r4
 8001690:	2028      	movs	r0, #40	; 0x28
 8001692:	f000 fa3f 	bl	8001b14 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ((IRQn_Type)(STMPE811_INT_EXTI));
 8001696:	2028      	movs	r0, #40	; 0x28
 8001698:	f000 fa70 	bl	8001b7c <HAL_NVIC_EnableIRQ>
  * @brief  IOE Low Level Interrupt configuration.
  */
void IOE_ITConfig(void)
{
  I2Cx_ITConfig();
}
 800169c:	b006      	add	sp, #24
 800169e:	bd10      	pop	{r4, pc}
 80016a0:	40023800 	.word	0x40023800
 80016a4:	40020000 	.word	0x40020000
 80016a8:	10210000 	.word	0x10210000

080016ac <IOE_Write>:
  * @param  Addr: I2C Address
  * @param  Reg: Reg Address 
  * @param  Value: Data to be written
  */
void IOE_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
 80016ac:	b510      	push	{r4, lr}
 80016ae:	b086      	sub	sp, #24
 80016b0:	ac06      	add	r4, sp, #24
  */
static void I2Cx_WriteData(uint8_t Addr, uint8_t Reg, uint8_t Value)
  {
  HAL_StatusTypeDef status = HAL_OK;
  
  status = HAL_I2C_Mem_Write(&I2cHandle, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, &Value, 1, I2cxTimeout); 
 80016b2:	4b09      	ldr	r3, [pc, #36]	; (80016d8 <IOE_Write+0x2c>)
 80016b4:	f804 2d01 	strb.w	r2, [r4, #-1]!
 80016b8:	681b      	ldr	r3, [r3, #0]
 80016ba:	9302      	str	r3, [sp, #8]
 80016bc:	2301      	movs	r3, #1
 80016be:	460a      	mov	r2, r1
 80016c0:	9301      	str	r3, [sp, #4]
 80016c2:	4601      	mov	r1, r0
 80016c4:	9400      	str	r4, [sp, #0]
 80016c6:	4805      	ldr	r0, [pc, #20]	; (80016dc <IOE_Write+0x30>)
 80016c8:	f000 ff68 	bl	800259c <HAL_I2C_Mem_Write>
  
  /* Check the communication status */
  if(status != HAL_OK)
 80016cc:	b108      	cbz	r0, 80016d2 <IOE_Write+0x26>
  {
    /* Re-Initialize the BUS */
    I2Cx_Error();
 80016ce:	f7ff fec5 	bl	800145c <I2Cx_Error>
  * @param  Value: Data to be written
  */
void IOE_Write(uint8_t Addr, uint8_t Reg, uint8_t Value)
{
  I2Cx_WriteData(Addr, Reg, Value);
}
 80016d2:	b006      	add	sp, #24
 80016d4:	bd10      	pop	{r4, pc}
 80016d6:	bf00      	nop
 80016d8:	20000054 	.word	0x20000054
 80016dc:	20002188 	.word	0x20002188

080016e0 <IOE_Read>:
  * @param  Addr: I2C Address
  * @param  Reg: Reg Address 
  * @retval The read data
  */
uint8_t IOE_Read(uint8_t Addr, uint8_t Reg)
{
 80016e0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  * @retval Data read at register address
  */
static uint8_t I2Cx_ReadData(uint8_t Addr, uint8_t Reg)
{
  HAL_StatusTypeDef status = HAL_OK;
  uint8_t value = 0;
 80016e2:	aa06      	add	r2, sp, #24
 80016e4:	2300      	movs	r3, #0
 80016e6:	f802 3d01 	strb.w	r3, [r2, #-1]!
  
  status = HAL_I2C_Mem_Read(&I2cHandle, Addr, Reg, I2C_MEMADD_SIZE_8BIT, &value, 1, I2cxTimeout);
 80016ea:	4b09      	ldr	r3, [pc, #36]	; (8001710 <IOE_Read+0x30>)
 80016ec:	681b      	ldr	r3, [r3, #0]
 80016ee:	9302      	str	r3, [sp, #8]
 80016f0:	2301      	movs	r3, #1
 80016f2:	e88d 000c 	stmia.w	sp, {r2, r3}
 80016f6:	460a      	mov	r2, r1
 80016f8:	4601      	mov	r1, r0
 80016fa:	4806      	ldr	r0, [pc, #24]	; (8001714 <IOE_Read+0x34>)
 80016fc:	f000 ffd2 	bl	80026a4 <HAL_I2C_Mem_Read>
 
  /* Check the communication status */
  if(status != HAL_OK)
 8001700:	b108      	cbz	r0, 8001706 <IOE_Read+0x26>
  {
    /* Re-Initialize the BUS */
    I2Cx_Error();
 8001702:	f7ff feab 	bl	800145c <I2Cx_Error>
  * @retval The read data
  */
uint8_t IOE_Read(uint8_t Addr, uint8_t Reg)
{
  return I2Cx_ReadData(Addr, Reg);
}
 8001706:	f89d 0017 	ldrb.w	r0, [sp, #23]
 800170a:	b007      	add	sp, #28
 800170c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001710:	20000054 	.word	0x20000054
 8001714:	20002188 	.word	0x20002188

08001718 <IOE_ReadMultiple>:
  * @param  pBuffer: pointer to data buffer
  * @param  Length: length of the data
  * @retval 0 if no problems to read multiple data
  */
uint16_t IOE_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t *pBuffer, uint16_t Length)
{
 8001718:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  */
static uint8_t I2Cx_ReadBuffer(uint8_t Addr, uint8_t Reg, uint8_t *pBuffer, uint16_t Length)
{
  HAL_StatusTypeDef status = HAL_OK;

  status = HAL_I2C_Mem_Read(&I2cHandle, Addr, (uint16_t)Reg, I2C_MEMADD_SIZE_8BIT, pBuffer, Length, I2cxTimeout);
 800171a:	4c08      	ldr	r4, [pc, #32]	; (800173c <IOE_ReadMultiple+0x24>)
 800171c:	6824      	ldr	r4, [r4, #0]
 800171e:	e88d 001c 	stmia.w	sp, {r2, r3, r4}
 8001722:	460a      	mov	r2, r1
 8001724:	2301      	movs	r3, #1
 8001726:	4601      	mov	r1, r0
 8001728:	4805      	ldr	r0, [pc, #20]	; (8001740 <IOE_ReadMultiple+0x28>)
 800172a:	f000 ffbb 	bl	80026a4 <HAL_I2C_Mem_Read>
  
  /* Check the communication status */
  if(status == HAL_OK)
 800172e:	b110      	cbz	r0, 8001736 <IOE_ReadMultiple+0x1e>
    return 0;
  }
  else
  {
    /* Re-Initialize the BUS */
    I2Cx_Error();
 8001730:	f7ff fe94 	bl	800145c <I2Cx_Error>

    return 1;
 8001734:	2001      	movs	r0, #1
  * @retval 0 if no problems to read multiple data
  */
uint16_t IOE_ReadMultiple(uint8_t Addr, uint8_t Reg, uint8_t *pBuffer, uint16_t Length)
{
 return I2Cx_ReadBuffer(Addr, Reg, pBuffer, Length);
}
 8001736:	b004      	add	sp, #16
 8001738:	bd10      	pop	{r4, pc}
 800173a:	bf00      	nop
 800173c:	20000054 	.word	0x20000054
 8001740:	20002188 	.word	0x20002188

08001744 <IOE_Delay>:
  * @brief  IOE Delay.
  * @param  Delay in ms
  */
void IOE_Delay(uint32_t Delay)
{
  HAL_Delay(Delay);
 8001744:	f000 b9c6 	b.w	8001ad4 <HAL_Delay>

08001748 <BSP_SDRAM_Initialization_sequence>:
/**
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
 8001748:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  __IO uint32_t tmpmrd = 0;

  /* Step 1:  Configure a clock configuration enable command */
  Command.CommandMode             = FMC_SDRAM_CMD_CLK_ENABLE;
 800174c:	4c23      	ldr	r4, [pc, #140]	; (80017dc <BSP_SDRAM_Initialization_sequence+0x94>)
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 800174e:	4d24      	ldr	r5, [pc, #144]	; (80017e0 <BSP_SDRAM_Initialization_sequence+0x98>)
{
  __IO uint32_t tmpmrd = 0;

  /* Step 1:  Configure a clock configuration enable command */
  Command.CommandMode             = FMC_SDRAM_CMD_CLK_ENABLE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 8001750:	2601      	movs	r6, #1
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
  __IO uint32_t tmpmrd = 0;
 8001752:	f04f 0800 	mov.w	r8, #0

  /* Step 1:  Configure a clock configuration enable command */
  Command.CommandMode             = FMC_SDRAM_CMD_CLK_ENABLE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 8001756:	2708      	movs	r7, #8
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8001758:	4621      	mov	r1, r4
/**
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
 800175a:	4682      	mov	sl, r0
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 800175c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001760:	4628      	mov	r0, r5
  * @brief  Programs the SDRAM device.
  * @param  RefreshCount: SDRAM refresh counter value
  */
void BSP_SDRAM_Initialization_sequence(uint32_t RefreshCount)
{
  __IO uint32_t tmpmrd = 0;
 8001762:	f8cd 8004 	str.w	r8, [sp, #4]

  /* Step 1:  Configure a clock configuration enable command */
  Command.CommandMode             = FMC_SDRAM_CMD_CLK_ENABLE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 8001766:	e884 00c0 	stmia.w	r4, {r6, r7}
  Command.AutoRefreshNumber       = 1;
 800176a:	60a6      	str	r6, [r4, #8]
  Command.ModeRegisterDefinition  = 0;
 800176c:	f8c4 800c 	str.w	r8, [r4, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8001770:	f001 ff81 	bl	8003676 <HAL_SDRAM_SendCommand>

  /* Step 2: Insert 100 us minimum delay */
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);
 8001774:	4630      	mov	r0, r6
 8001776:	f000 f9ad 	bl	8001ad4 <HAL_Delay>

  /* Step 3: Configure a PALL (precharge all) command */
  Command.CommandMode             = FMC_SDRAM_CMD_PALL;
 800177a:	2302      	movs	r3, #2
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 800177c:	4621      	mov	r1, r4
 800177e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001782:	4628      	mov	r0, r5
  /* Inserted delay is equal to 1 ms due to systick time base unit (ms) */
  HAL_Delay(1);

  /* Step 3: Configure a PALL (precharge all) command */
  Command.CommandMode             = FMC_SDRAM_CMD_PALL;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 8001784:	e884 0088 	stmia.w	r4, {r3, r7}
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);

  /* Step 4: Configure an Auto Refresh command */
  Command.CommandMode             = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 4;
 8001788:	f04f 0904 	mov.w	r9, #4
  HAL_Delay(1);

  /* Step 3: Configure a PALL (precharge all) command */
  Command.CommandMode             = FMC_SDRAM_CMD_PALL;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
 800178c:	60a6      	str	r6, [r4, #8]
  Command.ModeRegisterDefinition  = 0;
 800178e:	f8c4 800c 	str.w	r8, [r4, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8001792:	f001 ff70 	bl	8003676 <HAL_SDRAM_SendCommand>

  /* Step 4: Configure an Auto Refresh command */
  Command.CommandMode             = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
 8001796:	2303      	movs	r3, #3
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 4;
  Command.ModeRegisterDefinition  = 0;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 8001798:	4621      	mov	r1, r4
 800179a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800179e:	4628      	mov	r0, r5
  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);

  /* Step 4: Configure an Auto Refresh command */
  Command.CommandMode             = FMC_SDRAM_CMD_AUTOREFRESH_MODE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 80017a0:	e884 0088 	stmia.w	r4, {r3, r7}
  Command.AutoRefreshNumber       = 4;
 80017a4:	f8c4 9008 	str.w	r9, [r4, #8]
  Command.ModeRegisterDefinition  = 0;
 80017a8:	f8c4 800c 	str.w	r8, [r4, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 80017ac:	f001 ff63 	bl	8003676 <HAL_SDRAM_SendCommand>

  /* Step 5: Program the external memory mode register */
  tmpmrd = (uint32_t)SDRAM_MODEREG_BURST_LENGTH_1          |
 80017b0:	f44f 730c 	mov.w	r3, #560	; 0x230
 80017b4:	9301      	str	r3, [sp, #4]
           SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;

  Command.CommandMode             = FMC_SDRAM_CMD_LOAD_MODE;
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
  Command.AutoRefreshNumber       = 1;
  Command.ModeRegisterDefinition  = tmpmrd;
 80017b6:	9b01      	ldr	r3, [sp, #4]
 80017b8:	60e3      	str	r3, [r4, #12]

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 80017ba:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80017be:	4621      	mov	r1, r4
 80017c0:	4628      	mov	r0, r5
           SDRAM_MODEREG_BURST_TYPE_SEQUENTIAL   |
           SDRAM_MODEREG_CAS_LATENCY_3           |
           SDRAM_MODEREG_OPERATING_MODE_STANDARD |
           SDRAM_MODEREG_WRITEBURST_MODE_SINGLE;

  Command.CommandMode             = FMC_SDRAM_CMD_LOAD_MODE;
 80017c2:	f8c4 9000 	str.w	r9, [r4]
  Command.CommandTarget           = FMC_SDRAM_CMD_TARGET_BANK2;
 80017c6:	6067      	str	r7, [r4, #4]
  Command.AutoRefreshNumber       = 1;
 80017c8:	60a6      	str	r6, [r4, #8]
  Command.ModeRegisterDefinition  = tmpmrd;

  /* Send the command */
  HAL_SDRAM_SendCommand(&SdramHandle, &Command, SDRAM_TIMEOUT);
 80017ca:	f001 ff54 	bl	8003676 <HAL_SDRAM_SendCommand>

  /* Step 6: Set the refresh rate counter */
  /* Set the device refresh rate */
  HAL_SDRAM_ProgramRefreshRate(&SdramHandle, RefreshCount);
 80017ce:	4651      	mov	r1, sl
 80017d0:	4628      	mov	r0, r5
 80017d2:	f001 ff67 	bl	80036a4 <HAL_SDRAM_ProgramRefreshRate>
}
 80017d6:	b002      	add	sp, #8
 80017d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80017dc:	20001e40 	.word	0x20001e40
 80017e0:	20001ecc 	.word	0x20001ecc

080017e4 <BSP_SDRAM_Init>:

/**
  * @brief  Initializes the SDRAM device.
  */
void BSP_SDRAM_Init(void)
{
 80017e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  /* SDRAM device configuration */
  SdramHandle.Instance = FMC_SDRAM_DEVICE;
 80017e8:	4e6c      	ldr	r6, [pc, #432]	; (800199c <BSP_SDRAM_Init+0x1b8>)

  /* FMC Configuration -------------------------------------------------------*/
  /* FMC SDRAM Bank configuration */
  /* Timing configuration for 90 Mhz of SD clock frequency (180Mhz/2) */
  /* TMRD: 2 Clock cycles */
  Timing.LoadToActiveDelay    = 2;
 80017ea:	4f6d      	ldr	r7, [pc, #436]	; (80019a0 <BSP_SDRAM_Init+0x1bc>)
  * @brief  Initializes the SDRAM device.
  */
void BSP_SDRAM_Init(void)
{
  /* SDRAM device configuration */
  SdramHandle.Instance = FMC_SDRAM_DEVICE;
 80017ec:	4b6d      	ldr	r3, [pc, #436]	; (80019a4 <BSP_SDRAM_Init+0x1c0>)
 80017ee:	6033      	str	r3, [r6, #0]
  /* TMRD: 2 Clock cycles */
  Timing.LoadToActiveDelay    = 2;
  /* TXSR: min=70ns (7x11.11ns) */
  Timing.ExitSelfRefreshDelay = 7;
  /* TRAS: min=42ns (4x11.11ns) max=120k (ns) */
  Timing.SelfRefreshTime      = 4;
 80017f0:	2304      	movs	r3, #4
 80017f2:	60bb      	str	r3, [r7, #8]
  /* FMC SDRAM control configuration */
  SdramHandle.Init.SDBank             = FMC_SDRAM_BANK2;
  /* Row addressing: [7:0] */
  SdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
  /* Column addressing: [11:0] */
  SdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
 80017f4:	60f3      	str	r3, [r6, #12]
  SdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
 80017f6:	2310      	movs	r3, #16
 80017f8:	6133      	str	r3, [r6, #16]
  SdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
 80017fa:	2340      	movs	r3, #64	; 0x40
 80017fc:	6173      	str	r3, [r6, #20]
  SdramHandle.Init.CASLatency         = SDRAM_CAS_LATENCY;
 80017fe:	f44f 73c0 	mov.w	r3, #384	; 0x180
 8001802:	61b3      	str	r3, [r6, #24]
  SdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  SdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 8001804:	f44f 6300 	mov.w	r3, #2048	; 0x800

/**
  * @brief  Initializes the SDRAM device.
  */
void BSP_SDRAM_Init(void)
{
 8001808:	b08e      	sub	sp, #56	; 0x38
  SdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
  SdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
  SdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
  SdramHandle.Init.CASLatency         = SDRAM_CAS_LATENCY;
  SdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  SdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
 800180a:	6233      	str	r3, [r6, #32]
  SdramHandle.Init.ReadBurst          = SDRAM_READBURST;
  SdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_1;
 800180c:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  Timing.RCDDelay             = 2;

  /* FMC SDRAM control configuration */
  SdramHandle.Init.SDBank             = FMC_SDRAM_BANK2;
  /* Row addressing: [7:0] */
  SdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 8001810:	2400      	movs	r4, #0

  /* FMC Configuration -------------------------------------------------------*/
  /* FMC SDRAM Bank configuration */
  /* Timing configuration for 90 Mhz of SD clock frequency (180Mhz/2) */
  /* TMRD: 2 Clock cycles */
  Timing.LoadToActiveDelay    = 2;
 8001812:	2202      	movs	r2, #2
  SdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
  SdramHandle.Init.CASLatency         = SDRAM_CAS_LATENCY;
  SdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
  SdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
  SdramHandle.Init.ReadBurst          = SDRAM_READBURST;
  SdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_1;
 8001814:	62b3      	str	r3, [r6, #40]	; 0x28
  Timing.RPDelay              = 2;
  /* TRCD: 20ns => 2x11.11ns */
  Timing.RCDDelay             = 2;

  /* FMC SDRAM control configuration */
  SdramHandle.Init.SDBank             = FMC_SDRAM_BANK2;
 8001816:	f04f 0801 	mov.w	r8, #1
  static DMA_HandleTypeDef dmaHandle;
  GPIO_InitTypeDef GPIO_InitStructure;
  SDRAM_HandleTypeDef  *hsdram = &SdramHandle;

  /* Enable FMC clock */
  __FMC_CLK_ENABLE();
 800181a:	4b63      	ldr	r3, [pc, #396]	; (80019a8 <BSP_SDRAM_Init+0x1c4>)

  /* FMC Configuration -------------------------------------------------------*/
  /* FMC SDRAM Bank configuration */
  /* Timing configuration for 90 Mhz of SD clock frequency (180Mhz/2) */
  /* TMRD: 2 Clock cycles */
  Timing.LoadToActiveDelay    = 2;
 800181c:	603a      	str	r2, [r7, #0]
  /* TXSR: min=70ns (7x11.11ns) */
  Timing.ExitSelfRefreshDelay = 7;
 800181e:	2107      	movs	r1, #7
  /* TRAS: min=42ns (4x11.11ns) max=120k (ns) */
  Timing.SelfRefreshTime      = 4;
  /* TRC:  min=70 (7x11.11ns) */
  Timing.RowCycleDelay        = 7;
  /* TWR:  min=1+ 7ns (1+1x11.11ns) */
  Timing.WriteRecoveryTime    = 2;
 8001820:	613a      	str	r2, [r7, #16]
  /* TRP:  20ns => 2x11.11ns*/
  Timing.RPDelay              = 2;
 8001822:	617a      	str	r2, [r7, #20]
  /* TRCD: 20ns => 2x11.11ns */
  Timing.RCDDelay             = 2;
 8001824:	61ba      	str	r2, [r7, #24]
  static DMA_HandleTypeDef dmaHandle;
  GPIO_InitTypeDef GPIO_InitStructure;
  SDRAM_HandleTypeDef  *hsdram = &SdramHandle;

  /* Enable FMC clock */
  __FMC_CLK_ENABLE();
 8001826:	9401      	str	r4, [sp, #4]
  /* FMC SDRAM Bank configuration */
  /* Timing configuration for 90 Mhz of SD clock frequency (180Mhz/2) */
  /* TMRD: 2 Clock cycles */
  Timing.LoadToActiveDelay    = 2;
  /* TXSR: min=70ns (7x11.11ns) */
  Timing.ExitSelfRefreshDelay = 7;
 8001828:	6079      	str	r1, [r7, #4]
  /* TRAS: min=42ns (4x11.11ns) max=120k (ns) */
  Timing.SelfRefreshTime      = 4;
  /* TRC:  min=70 (7x11.11ns) */
  Timing.RowCycleDelay        = 7;
 800182a:	60f9      	str	r1, [r7, #12]
  Timing.RPDelay              = 2;
  /* TRCD: 20ns => 2x11.11ns */
  Timing.RCDDelay             = 2;

  /* FMC SDRAM control configuration */
  SdramHandle.Init.SDBank             = FMC_SDRAM_BANK2;
 800182c:	f8c6 8004 	str.w	r8, [r6, #4]
  /* Row addressing: [7:0] */
  SdramHandle.Init.ColumnBitsNumber   = FMC_SDRAM_COLUMN_BITS_NUM_8;
 8001830:	60b4      	str	r4, [r6, #8]
  /* Column addressing: [11:0] */
  SdramHandle.Init.RowBitsNumber      = FMC_SDRAM_ROW_BITS_NUM_12;
  SdramHandle.Init.MemoryDataWidth    = SDRAM_MEMORY_WIDTH;
  SdramHandle.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
  SdramHandle.Init.CASLatency         = SDRAM_CAS_LATENCY;
  SdramHandle.Init.WriteProtection    = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
 8001832:	61f4      	str	r4, [r6, #28]
  SdramHandle.Init.SDClockPeriod      = SDCLOCK_PERIOD;
  SdramHandle.Init.ReadBurst          = SDRAM_READBURST;
 8001834:	6274      	str	r4, [r6, #36]	; 0x24
  static DMA_HandleTypeDef dmaHandle;
  GPIO_InitTypeDef GPIO_InitStructure;
  SDRAM_HandleTypeDef  *hsdram = &SdramHandle;

  /* Enable FMC clock */
  __FMC_CLK_ENABLE();
 8001836:	6b99      	ldr	r1, [r3, #56]	; 0x38
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
  GPIO_InitStructure.Alternate = GPIO_AF12_FMC;

  /* GPIOB configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8001838:	485c      	ldr	r0, [pc, #368]	; (80019ac <BSP_SDRAM_Init+0x1c8>)
  static DMA_HandleTypeDef dmaHandle;
  GPIO_InitTypeDef GPIO_InitStructure;
  SDRAM_HandleTypeDef  *hsdram = &SdramHandle;

  /* Enable FMC clock */
  __FMC_CLK_ENABLE();
 800183a:	ea41 0108 	orr.w	r1, r1, r8
 800183e:	6399      	str	r1, [r3, #56]	; 0x38
 8001840:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8001842:	ea01 0108 	and.w	r1, r1, r8
 8001846:	9101      	str	r1, [sp, #4]
 8001848:	9901      	ldr	r1, [sp, #4]

  /* Enable chosen DMAx clock */
  __DMAx_CLK_ENABLE();
 800184a:	9402      	str	r4, [sp, #8]
 800184c:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800184e:	f441 0180 	orr.w	r1, r1, #4194304	; 0x400000
 8001852:	6319      	str	r1, [r3, #48]	; 0x30
 8001854:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001856:	f401 0180 	and.w	r1, r1, #4194304	; 0x400000
 800185a:	9102      	str	r1, [sp, #8]
 800185c:	9902      	ldr	r1, [sp, #8]

  /* Enable GPIOs clock */
  __GPIOB_CLK_ENABLE();
 800185e:	9403      	str	r4, [sp, #12]
 8001860:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001862:	4311      	orrs	r1, r2
 8001864:	6319      	str	r1, [r3, #48]	; 0x30
 8001866:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001868:	4011      	ands	r1, r2
 800186a:	9103      	str	r1, [sp, #12]
 800186c:	9903      	ldr	r1, [sp, #12]
  __GPIOC_CLK_ENABLE();
 800186e:	9404      	str	r4, [sp, #16]
 8001870:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001872:	f041 0104 	orr.w	r1, r1, #4
 8001876:	6319      	str	r1, [r3, #48]	; 0x30
 8001878:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800187a:	f001 0104 	and.w	r1, r1, #4
 800187e:	9104      	str	r1, [sp, #16]
 8001880:	9904      	ldr	r1, [sp, #16]
  __GPIOD_CLK_ENABLE();
 8001882:	9405      	str	r4, [sp, #20]
 8001884:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001886:	f041 0108 	orr.w	r1, r1, #8
 800188a:	6319      	str	r1, [r3, #48]	; 0x30
 800188c:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800188e:	f001 0108 	and.w	r1, r1, #8
 8001892:	9105      	str	r1, [sp, #20]
 8001894:	9905      	ldr	r1, [sp, #20]
  __GPIOE_CLK_ENABLE();
 8001896:	9406      	str	r4, [sp, #24]
 8001898:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800189a:	f041 0110 	orr.w	r1, r1, #16
 800189e:	6319      	str	r1, [r3, #48]	; 0x30
 80018a0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80018a2:	f001 0110 	and.w	r1, r1, #16
 80018a6:	9106      	str	r1, [sp, #24]
 80018a8:	9906      	ldr	r1, [sp, #24]
  __GPIOF_CLK_ENABLE();
 80018aa:	9407      	str	r4, [sp, #28]
 80018ac:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80018ae:	f041 0120 	orr.w	r1, r1, #32
 80018b2:	6319      	str	r1, [r3, #48]	; 0x30
 80018b4:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80018b6:	f001 0120 	and.w	r1, r1, #32
 80018ba:	9107      	str	r1, [sp, #28]
 80018bc:	9907      	ldr	r1, [sp, #28]
  __GPIOG_CLK_ENABLE();
 80018be:	9408      	str	r4, [sp, #32]
 80018c0:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80018c2:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 80018c6:	6319      	str	r1, [r3, #48]	; 0x30
 80018c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   +-------------------+

  */

  /* Common GPIO configuration */
  GPIO_InitStructure.Mode  = GPIO_MODE_AF_PP;
 80018ca:	920a      	str	r2, [sp, #40]	; 0x28
  __GPIOB_CLK_ENABLE();
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOF_CLK_ENABLE();
  __GPIOG_CLK_ENABLE();
 80018cc:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80018d0:	9308      	str	r3, [sp, #32]
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
  GPIO_InitStructure.Alternate = GPIO_AF12_FMC;

  /* GPIOB configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
 80018d2:	ad0e      	add	r5, sp, #56	; 0x38
  __GPIOB_CLK_ENABLE();
  __GPIOC_CLK_ENABLE();
  __GPIOD_CLK_ENABLE();
  __GPIOE_CLK_ENABLE();
  __GPIOF_CLK_ENABLE();
  __GPIOG_CLK_ENABLE();
 80018d4:	9b08      	ldr	r3, [sp, #32]

  */

  /* Common GPIO configuration */
  GPIO_InitStructure.Mode  = GPIO_MODE_AF_PP;
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
 80018d6:	920c      	str	r2, [sp, #48]	; 0x30
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
  GPIO_InitStructure.Alternate = GPIO_AF12_FMC;
 80018d8:	230c      	movs	r3, #12
 80018da:	930d      	str	r3, [sp, #52]	; 0x34

  /* GPIOB configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
 80018dc:	2360      	movs	r3, #96	; 0x60
 80018de:	f845 3d14 	str.w	r3, [r5, #-20]!
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 80018e2:	4629      	mov	r1, r5
  */

  /* Common GPIO configuration */
  GPIO_InitStructure.Mode  = GPIO_MODE_AF_PP;
  GPIO_InitStructure.Speed = GPIO_SPEED_FAST;
  GPIO_InitStructure.Pull  = GPIO_NOPULL;
 80018e4:	940b      	str	r4, [sp, #44]	; 0x2c
  GPIO_InitStructure.Alternate = GPIO_AF12_FMC;

  /* GPIOB configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 80018e6:	f000 fa6d 	bl	8001dc4 <HAL_GPIO_Init>

  /* GPIOC configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 80018ea:	4629      	mov	r1, r5
 80018ec:	4830      	ldr	r0, [pc, #192]	; (80019b0 <BSP_SDRAM_Init+0x1cc>)
  /* GPIOB configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_5 | GPIO_PIN_6;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);

  /* GPIOC configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0;
 80018ee:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 80018f2:	f000 fa67 	bl	8001dc4 <HAL_GPIO_Init>

  /* GPIOD configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1  | GPIO_PIN_8 |
 80018f6:	f24c 7303 	movw	r3, #50947	; 0xc703
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_14 |
                           GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 80018fa:	4629      	mov	r1, r5
 80018fc:	482d      	ldr	r0, [pc, #180]	; (80019b4 <BSP_SDRAM_Init+0x1d0>)
  /* GPIOC configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);

  /* GPIOD configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1  | GPIO_PIN_8 |
 80018fe:	9309      	str	r3, [sp, #36]	; 0x24
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_14 |
                           GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8001900:	f000 fa60 	bl	8001dc4 <HAL_GPIO_Init>

  /* GPIOE configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_7 |
 8001904:	f64f 7383 	movw	r3, #65411	; 0xff83
                           GPIO_PIN_8  | GPIO_PIN_9  | GPIO_PIN_10 |
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 8001908:	4629      	mov	r1, r5
 800190a:	482b      	ldr	r0, [pc, #172]	; (80019b8 <BSP_SDRAM_Init+0x1d4>)
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_14 |
                           GPIO_PIN_15;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);

  /* GPIOE configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1  | GPIO_PIN_7 |
 800190c:	9309      	str	r3, [sp, #36]	; 0x24
                           GPIO_PIN_8  | GPIO_PIN_9  | GPIO_PIN_10 |
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 800190e:	f000 fa59 	bl	8001dc4 <HAL_GPIO_Init>

  /* GPIOF configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1 | GPIO_PIN_2 |
 8001912:	f64f 033f 	movw	r3, #63551	; 0xf83f
                           GPIO_PIN_3  | GPIO_PIN_4 | GPIO_PIN_5 |
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);
 8001916:	4629      	mov	r1, r5
 8001918:	4828      	ldr	r0, [pc, #160]	; (80019bc <BSP_SDRAM_Init+0x1d8>)
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);

  /* GPIOF configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0  | GPIO_PIN_1 | GPIO_PIN_2 |
 800191a:	9309      	str	r3, [sp, #36]	; 0x24
                           GPIO_PIN_3  | GPIO_PIN_4 | GPIO_PIN_5 |
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);
 800191c:	f000 fa52 	bl	8001dc4 <HAL_GPIO_Init>

  /* GPIOG configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
                           GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8001920:	4629      	mov	r1, r5
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);

  /* GPIOG configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
 8001922:	f248 1333 	movw	r3, #33075	; 0x8133
                           GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);

  /* Configure common DMA parameters */
  dmaHandle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 8001926:	4d26      	ldr	r5, [pc, #152]	; (80019c0 <BSP_SDRAM_Init+0x1dc>)
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);

  /* GPIOG configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
                           GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 8001928:	4826      	ldr	r0, [pc, #152]	; (80019c4 <BSP_SDRAM_Init+0x1e0>)
                           GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13 |
                           GPIO_PIN_14 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOF, &GPIO_InitStructure);

  /* GPIOG configuration */
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
 800192a:	9309      	str	r3, [sp, #36]	; 0x24
                           GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);
 800192c:	f000 fa4a 	bl	8001dc4 <HAL_GPIO_Init>

  /* Configure common DMA parameters */
  dmaHandle.Init.Channel             = SDRAM_DMAx_CHANNEL;
  dmaHandle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
 8001930:	2380      	movs	r3, #128	; 0x80
 8001932:	60ab      	str	r3, [r5, #8]
  dmaHandle.Init.PeriphInc           = DMA_PINC_ENABLE;
 8001934:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001938:	60eb      	str	r3, [r5, #12]
  dmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
 800193a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800193e:	612b      	str	r3, [r5, #16]
  dmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
 8001940:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001944:	616b      	str	r3, [r5, #20]
  dmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
 8001946:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 800194a:	61ab      	str	r3, [r5, #24]
  dmaHandle.Init.Mode                = DMA_NORMAL;
  dmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
 800194c:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001950:	622b      	str	r3, [r5, #32]
  dmaHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
  dmaHandle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
 8001952:	2303      	movs	r3, #3
 8001954:	62ab      	str	r3, [r5, #40]	; 0x28

  /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dmaHandle);

  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dmaHandle);
 8001956:	4628      	mov	r0, r5
  dmaHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
  dmaHandle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dmaHandle.Init.MemBurst            = DMA_MBURST_SINGLE;
  dmaHandle.Init.PeriphBurst         = DMA_PBURST_SINGLE;

  dmaHandle.Instance = SDRAM_DMAx_STREAM;
 8001958:	4b1b      	ldr	r3, [pc, #108]	; (80019c8 <BSP_SDRAM_Init+0x1e4>)
 800195a:	602b      	str	r3, [r5, #0]
  GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_4 |
                           GPIO_PIN_5 | GPIO_PIN_8 | GPIO_PIN_15;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);

  /* Configure common DMA parameters */
  dmaHandle.Init.Channel             = SDRAM_DMAx_CHANNEL;
 800195c:	606c      	str	r4, [r5, #4]
  dmaHandle.Init.Direction           = DMA_MEMORY_TO_MEMORY;
  dmaHandle.Init.PeriphInc           = DMA_PINC_ENABLE;
  dmaHandle.Init.MemInc              = DMA_MINC_ENABLE;
  dmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
  dmaHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_WORD;
  dmaHandle.Init.Mode                = DMA_NORMAL;
 800195e:	61ec      	str	r4, [r5, #28]
  dmaHandle.Init.Priority            = DMA_PRIORITY_HIGH;
  dmaHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
 8001960:	626c      	str	r4, [r5, #36]	; 0x24
  dmaHandle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
  dmaHandle.Init.MemBurst            = DMA_MBURST_SINGLE;
 8001962:	62ec      	str	r4, [r5, #44]	; 0x2c
  dmaHandle.Init.PeriphBurst         = DMA_PBURST_SINGLE;
 8001964:	632c      	str	r4, [r5, #48]	; 0x30

  dmaHandle.Instance = SDRAM_DMAx_STREAM;

  /* Associate the DMA handle */
  __HAL_LINKDMA(hsdram, hdma, dmaHandle);
 8001966:	6335      	str	r5, [r6, #48]	; 0x30
 8001968:	63ae      	str	r6, [r5, #56]	; 0x38

  /* Deinitialize the stream for new transfer */
  HAL_DMA_DeInit(&dmaHandle);
 800196a:	f000 f9c7 	bl	8001cfc <HAL_DMA_DeInit>

  /* Configure the DMA stream */
  HAL_DMA_Init(&dmaHandle);
 800196e:	4628      	mov	r0, r5
 8001970:	f000 f94e 	bl	8001c10 <HAL_DMA_Init>

  /* NVIC configuration for DMA transfer complete interrupt */
  HAL_NVIC_SetPriority(SDRAM_DMAx_IRQn, 0, 0);
 8001974:	4622      	mov	r2, r4
 8001976:	4621      	mov	r1, r4
 8001978:	2038      	movs	r0, #56	; 0x38
 800197a:	f000 f8cb 	bl	8001b14 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(SDRAM_DMAx_IRQn);
 800197e:	2038      	movs	r0, #56	; 0x38
 8001980:	f000 f8fc 	bl	8001b7c <HAL_NVIC_EnableIRQ>
  SdramHandle.Init.ReadBurst          = SDRAM_READBURST;
  SdramHandle.Init.ReadPipeDelay      = FMC_SDRAM_RPIPE_DELAY_1;

  /* SDRAM controller initialization */
  MspInit();
  HAL_SDRAM_Init(&SdramHandle, &Timing);
 8001984:	4639      	mov	r1, r7
 8001986:	4630      	mov	r0, r6
 8001988:	f001 fe55 	bl	8003636 <HAL_SDRAM_Init>

  /* SDRAM initialization sequence */
  BSP_SDRAM_Initialization_sequence(REFRESH_COUNT);
 800198c:	f240 506a 	movw	r0, #1386	; 0x56a
 8001990:	f7ff feda 	bl	8001748 <BSP_SDRAM_Initialization_sequence>
}
 8001994:	b00e      	add	sp, #56	; 0x38
 8001996:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800199a:	bf00      	nop
 800199c:	20001ecc 	.word	0x20001ecc
 80019a0:	20001e50 	.word	0x20001e50
 80019a4:	a0000140 	.word	0xa0000140
 80019a8:	40023800 	.word	0x40023800
 80019ac:	40020400 	.word	0x40020400
 80019b0:	40020800 	.word	0x40020800
 80019b4:	40020c00 	.word	0x40020c00
 80019b8:	40021000 	.word	0x40021000
 80019bc:	40021400 	.word	0x40021400
 80019c0:	20001e6c 	.word	0x20001e6c
 80019c4:	40021800 	.word	0x40021800
 80019c8:	40026410 	.word	0x40026410

080019cc <BSP_TS_Init>:
  * @param  XSize: The maximum X size of the TS area on LCD
  * @param  YSize: The maximum Y size of the TS area on LCD  
  * @retval TS_OK: if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_Init(uint16_t XSize, uint16_t YSize)
{
 80019cc:	b538      	push	{r3, r4, r5, lr}
  uint8_t ret = TS_ERROR;

  /* Initialize x and y positions boundaries */
  TsXBoundary = XSize;
 80019ce:	4b0c      	ldr	r3, [pc, #48]	; (8001a00 <BSP_TS_Init+0x34>)
  TsYBoundary = YSize;

  /* Read ID and verify if the IO expander is ready */
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
 80019d0:	4c0c      	ldr	r4, [pc, #48]	; (8001a04 <BSP_TS_Init+0x38>)
uint8_t BSP_TS_Init(uint16_t XSize, uint16_t YSize)
{
  uint8_t ret = TS_ERROR;

  /* Initialize x and y positions boundaries */
  TsXBoundary = XSize;
 80019d2:	8018      	strh	r0, [r3, #0]
  TsYBoundary = YSize;
 80019d4:	4b0c      	ldr	r3, [pc, #48]	; (8001a08 <BSP_TS_Init+0x3c>)

  /* Read ID and verify if the IO expander is ready */
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
 80019d6:	2082      	movs	r0, #130	; 0x82
{
  uint8_t ret = TS_ERROR;

  /* Initialize x and y positions boundaries */
  TsXBoundary = XSize;
  TsYBoundary = YSize;
 80019d8:	8019      	strh	r1, [r3, #0]

  /* Read ID and verify if the IO expander is ready */
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
 80019da:	6863      	ldr	r3, [r4, #4]
 80019dc:	4798      	blx	r3
 80019de:	f640 0311 	movw	r3, #2065	; 0x811
 80019e2:	4298      	cmp	r0, r3
 80019e4:	d10a      	bne.n	80019fc <BSP_TS_Init+0x30>
  {
    /* Initialize the TS driver structure */
    TsDrv = &stmpe811_ts_drv;
 80019e6:	4d09      	ldr	r5, [pc, #36]	; (8001a0c <BSP_TS_Init+0x40>)
  }

  if(ret == TS_OK)
  {
    /* Initialize the LL TS Driver */
    TsDrv->Init(TS_I2C_ADDRESS);
 80019e8:	6823      	ldr	r3, [r4, #0]

  /* Read ID and verify if the IO expander is ready */
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
  {
    /* Initialize the TS driver structure */
    TsDrv = &stmpe811_ts_drv;
 80019ea:	602c      	str	r4, [r5, #0]
  }

  if(ret == TS_OK)
  {
    /* Initialize the LL TS Driver */
    TsDrv->Init(TS_I2C_ADDRESS);
 80019ec:	2082      	movs	r0, #130	; 0x82
 80019ee:	4798      	blx	r3
    TsDrv->Start(TS_I2C_ADDRESS);
 80019f0:	682b      	ldr	r3, [r5, #0]
 80019f2:	2082      	movs	r0, #130	; 0x82
 80019f4:	68db      	ldr	r3, [r3, #12]
 80019f6:	4798      	blx	r3
  if(stmpe811_ts_drv.ReadID(TS_I2C_ADDRESS) == STMPE811_ID)
  {
    /* Initialize the TS driver structure */
    TsDrv = &stmpe811_ts_drv;

    ret = TS_OK;
 80019f8:	2000      	movs	r0, #0
 80019fa:	bd38      	pop	{r3, r4, r5, pc}
  * @param  YSize: The maximum Y size of the TS area on LCD  
  * @retval TS_OK: if all initializations are OK. Other value if error.
  */
uint8_t BSP_TS_Init(uint16_t XSize, uint16_t YSize)
{
  uint8_t ret = TS_ERROR;
 80019fc:	2001      	movs	r0, #1
    TsDrv->Init(TS_I2C_ADDRESS);
    TsDrv->Start(TS_I2C_ADDRESS);
  }

  return ret;
}
 80019fe:	bd38      	pop	{r3, r4, r5, pc}
 8001a00:	20001f04 	.word	0x20001f04
 8001a04:	20000024 	.word	0x20000024
 8001a08:	20001f06 	.word	0x20001f06
 8001a0c:	20001f00 	.word	0x20001f00

08001a10 <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 8001a10:	490f      	ldr	r1, [pc, #60]	; (8001a50 <SystemInit+0x40>)
 8001a12:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001a16:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001a1a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001a1e:	4b0d      	ldr	r3, [pc, #52]	; (8001a54 <SystemInit+0x44>)
 8001a20:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001a22:	2000      	movs	r0, #0
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
  #endif
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 8001a24:	f042 0201 	orr.w	r2, r2, #1
 8001a28:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 8001a2a:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8001a2c:	681a      	ldr	r2, [r3, #0]
 8001a2e:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 8001a32:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8001a36:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x24003010;
 8001a38:	4a07      	ldr	r2, [pc, #28]	; (8001a58 <SystemInit+0x48>)
 8001a3a:	605a      	str	r2, [r3, #4]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8001a3c:	681a      	ldr	r2, [r3, #0]
 8001a3e:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001a42:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIR = 0x00000000;
 8001a44:	60d8      	str	r0, [r3, #12]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8001a46:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8001a4a:	608b      	str	r3, [r1, #8]
 8001a4c:	4770      	bx	lr
 8001a4e:	bf00      	nop
 8001a50:	e000ed00 	.word	0xe000ed00
 8001a54:	40023800 	.word	0x40023800
 8001a58:	24003010 	.word	0x24003010

08001a5c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001a5c:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8001a5e:	4b08      	ldr	r3, [pc, #32]	; (8001a80 <HAL_InitTick+0x24>)
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001a60:	4604      	mov	r4, r0
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000U);
 8001a62:	6818      	ldr	r0, [r3, #0]
 8001a64:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001a68:	fbb0 f0f3 	udiv	r0, r0, r3
 8001a6c:	f000 f892 	bl	8001b94 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);
 8001a70:	2200      	movs	r2, #0
 8001a72:	4621      	mov	r1, r4
 8001a74:	f04f 30ff 	mov.w	r0, #4294967295
 8001a78:	f000 f84c 	bl	8001b14 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8001a7c:	2000      	movs	r0, #0
 8001a7e:	bd10      	pop	{r4, pc}
 8001a80:	20000058 	.word	0x20000058

08001a84 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8001a84:	b508      	push	{r3, lr}
  /* Configure Flash prefetch, Instruction cache, Data cache */ 
#if (INSTRUCTION_CACHE_ENABLE != 0U)
   __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 8001a86:	4b0b      	ldr	r3, [pc, #44]	; (8001ab4 <HAL_Init+0x30>)
 8001a88:	681a      	ldr	r2, [r3, #0]
 8001a8a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8001a8e:	601a      	str	r2, [r3, #0]
#endif /* INSTRUCTION_CACHE_ENABLE */

#if (DATA_CACHE_ENABLE != 0U)
   __HAL_FLASH_DATA_CACHE_ENABLE();
 8001a90:	681a      	ldr	r2, [r3, #0]
 8001a92:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8001a96:	601a      	str	r2, [r3, #0]
#endif /* DATA_CACHE_ENABLE */

#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8001a98:	681a      	ldr	r2, [r3, #0]
 8001a9a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001a9e:	601a      	str	r2, [r3, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8001aa0:	2003      	movs	r0, #3
 8001aa2:	f000 f825 	bl	8001af0 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8001aa6:	2000      	movs	r0, #0
 8001aa8:	f7ff ffd8 	bl	8001a5c <HAL_InitTick>
  
  /* Init the low level hardware */
  HAL_MspInit();
 8001aac:	f7fe ffce 	bl	8000a4c <HAL_MspInit>
  
  /* Return function status */
  return HAL_OK;
}
 8001ab0:	2000      	movs	r0, #0
 8001ab2:	bd08      	pop	{r3, pc}
 8001ab4:	40023c00 	.word	0x40023c00

08001ab8 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8001ab8:	4a02      	ldr	r2, [pc, #8]	; (8001ac4 <HAL_IncTick+0xc>)
 8001aba:	6813      	ldr	r3, [r2, #0]
 8001abc:	3301      	adds	r3, #1
 8001abe:	6013      	str	r3, [r2, #0]
 8001ac0:	4770      	bx	lr
 8001ac2:	bf00      	nop
 8001ac4:	200021dc 	.word	0x200021dc

08001ac8 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001ac8:	4b01      	ldr	r3, [pc, #4]	; (8001ad0 <HAL_GetTick+0x8>)
 8001aca:	6818      	ldr	r0, [r3, #0]
}
 8001acc:	4770      	bx	lr
 8001ace:	bf00      	nop
 8001ad0:	200021dc 	.word	0x200021dc

08001ad4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay: specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(__IO uint32_t Delay)
{
 8001ad4:	b513      	push	{r0, r1, r4, lr}
 8001ad6:	9001      	str	r0, [sp, #4]
  uint32_t tickstart = 0U;
  tickstart = HAL_GetTick();
 8001ad8:	f7ff fff6 	bl	8001ac8 <HAL_GetTick>
 8001adc:	4604      	mov	r4, r0
  while((HAL_GetTick() - tickstart) < Delay)
 8001ade:	f7ff fff3 	bl	8001ac8 <HAL_GetTick>
 8001ae2:	9b01      	ldr	r3, [sp, #4]
 8001ae4:	1b00      	subs	r0, r0, r4
 8001ae6:	4298      	cmp	r0, r3
 8001ae8:	d3f9      	bcc.n	8001ade <HAL_Delay+0xa>
  {
  }
}
 8001aea:	b002      	add	sp, #8
 8001aec:	bd10      	pop	{r4, pc}
	...

08001af0 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001af0:	4a07      	ldr	r2, [pc, #28]	; (8001b10 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001af2:	68d3      	ldr	r3, [r2, #12]
 8001af4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001af8:	041b      	lsls	r3, r3, #16
 8001afa:	0c1b      	lsrs	r3, r3, #16
 8001afc:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8001b00:	0200      	lsls	r0, r0, #8
 8001b02:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001b06:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8001b0a:	4303      	orrs	r3, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8001b0c:	60d3      	str	r3, [r2, #12]
 8001b0e:	4770      	bx	lr
 8001b10:	e000ed00 	.word	0xe000ed00

08001b14 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001b14:	4b17      	ldr	r3, [pc, #92]	; (8001b74 <HAL_NVIC_SetPriority+0x60>)
 8001b16:	68db      	ldr	r3, [r3, #12]
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8001b18:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8001b1c:	b530      	push	{r4, r5, lr}
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001b1e:	f1c3 0407 	rsb	r4, r3, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001b22:	1d1d      	adds	r5, r3, #4
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001b24:	2c04      	cmp	r4, #4
 8001b26:	bf28      	it	cs
 8001b28:	2404      	movcs	r4, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001b2a:	2d06      	cmp	r5, #6

  return (
 8001b2c:	f04f 0501 	mov.w	r5, #1
 8001b30:	fa05 f404 	lsl.w	r4, r5, r4
 8001b34:	f104 34ff 	add.w	r4, r4, #4294967295
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001b38:	bf8c      	ite	hi
 8001b3a:	3b03      	subhi	r3, #3
 8001b3c:	2300      	movls	r3, #0

  return (
 8001b3e:	400c      	ands	r4, r1
 8001b40:	409c      	lsls	r4, r3
 8001b42:	fa05 f303 	lsl.w	r3, r5, r3
 8001b46:	3b01      	subs	r3, #1
 8001b48:	401a      	ands	r2, r3
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
 8001b4a:	2800      	cmp	r0, #0
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));

  return (
 8001b4c:	ea42 0204 	orr.w	r2, r2, r4
 8001b50:	ea4f 1202 	mov.w	r2, r2, lsl #4
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b54:	bfaf      	iteee	ge
 8001b56:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b5a:	f000 000f 	andlt.w	r0, r0, #15
 8001b5e:	4b06      	ldrlt	r3, [pc, #24]	; (8001b78 <HAL_NVIC_SetPriority+0x64>)
 8001b60:	b2d2      	uxtblt	r2, r2
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b62:	bfa5      	ittet	ge
 8001b64:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 8001b68:	b2d2      	uxtbge	r2, r2
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b6a:	541a      	strblt	r2, [r3, r0]
  }
  else
  {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b6c:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 8001b70:	bd30      	pop	{r4, r5, pc}
 8001b72:	bf00      	nop
 8001b74:	e000ed00 	.word	0xe000ed00
 8001b78:	e000ed14 	.word	0xe000ed14

08001b7c <HAL_NVIC_EnableIRQ>:
  \details Enables a device-specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 8001b7c:	0942      	lsrs	r2, r0, #5
 8001b7e:	2301      	movs	r3, #1
 8001b80:	f000 001f 	and.w	r0, r0, #31
 8001b84:	fa03 f000 	lsl.w	r0, r3, r0
 8001b88:	4b01      	ldr	r3, [pc, #4]	; (8001b90 <HAL_NVIC_EnableIRQ+0x14>)
 8001b8a:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 8001b8e:	4770      	bx	lr
 8001b90:	e000e100 	.word	0xe000e100

08001b94 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001b94:	3801      	subs	r0, #1
 8001b96:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8001b9a:	d20a      	bcs.n	8001bb2 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001b9c:	4b06      	ldr	r3, [pc, #24]	; (8001bb8 <HAL_SYSTICK_Config+0x24>)
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001b9e:	4a07      	ldr	r2, [pc, #28]	; (8001bbc <HAL_SYSTICK_Config+0x28>)
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8001ba0:	6058      	str	r0, [r3, #4]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001ba2:	21f0      	movs	r1, #240	; 0xf0
 8001ba4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001ba8:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001baa:	2207      	movs	r2, #7
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001bac:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001bae:	601a      	str	r2, [r3, #0]
 8001bb0:	4770      	bx	lr
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
  {
    return (1UL);                                                   /* Reload value impossible */
 8001bb2:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8001bb4:	4770      	bx	lr
 8001bb6:	bf00      	nop
 8001bb8:	e000e010 	.word	0xe000e010
 8001bbc:	e000ed00 	.word	0xe000ed00

08001bc0 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8001bc0:	4b04      	ldr	r3, [pc, #16]	; (8001bd4 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001bc2:	681a      	ldr	r2, [r3, #0]
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8001bc4:	2804      	cmp	r0, #4
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001bc6:	bf0c      	ite	eq
 8001bc8:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8001bcc:	f022 0204 	bicne.w	r2, r2, #4
 8001bd0:	601a      	str	r2, [r3, #0]
 8001bd2:	4770      	bx	lr
 8001bd4:	e000e010 	.word	0xe000e010

08001bd8 <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8001bd8:	4770      	bx	lr

08001bda <HAL_SYSTICK_IRQHandler>:
/**
  * @brief  This function handles SYSTICK interrupt request.
  * @retval None
  */
void HAL_SYSTICK_IRQHandler(void)
{
 8001bda:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8001bdc:	f7ff fffc 	bl	8001bd8 <HAL_SYSTICK_Callback>
 8001be0:	bd08      	pop	{r3, pc}
	...

08001be4 <DMA_CalcBaseAndBitshift>:
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001be4:	6803      	ldr	r3, [r0, #0]
 8001be6:	b2da      	uxtb	r2, r3
 8001be8:	f423 737f 	bic.w	r3, r3, #1020	; 0x3fc
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
  
  if (stream_number > 3U)
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001bec:	f023 0303 	bic.w	r3, r3, #3
  *                     the configuration information for the specified DMA Stream. 
  * @retval Stream base address
  */
static uint32_t DMA_CalcBaseAndBitshift(DMA_HandleTypeDef *hdma)
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
 8001bf0:	2118      	movs	r1, #24
 8001bf2:	3a10      	subs	r2, #16
 8001bf4:	fbb2 f2f1 	udiv	r2, r2, r1
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001bf8:	4904      	ldr	r1, [pc, #16]	; (8001c0c <DMA_CalcBaseAndBitshift+0x28>)
  
  if (stream_number > 3U)
 8001bfa:	2a03      	cmp	r2, #3
  {
    /* return pointer to HISR and HIFCR */
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
 8001bfc:	bf88      	it	hi
 8001bfe:	3304      	addhi	r3, #4
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001c00:	5c89      	ldrb	r1, [r1, r2]
    hdma->StreamBaseAddress = (((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU)) + 4U);
  }
  else
  {
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
 8001c02:	6583      	str	r3, [r0, #88]	; 0x58
{
  uint32_t stream_number = (((uint32_t)hdma->Instance & 0xFFU) - 16U) / 24U;
  
  /* lookup table for necessary bitshift of flags within status registers */
  static const uint8_t flagBitshiftOffset[8U] = {0U, 6U, 16U, 22U, 0U, 6U, 16U, 22U};
  hdma->StreamIndex = flagBitshiftOffset[stream_number];
 8001c04:	65c1      	str	r1, [r0, #92]	; 0x5c
    /* return pointer to LISR and LIFCR */
    hdma->StreamBaseAddress = ((uint32_t)hdma->Instance & (uint32_t)(~0x3FFU));
  }
  
  return hdma->StreamBaseAddress;
}
 8001c06:	6d80      	ldr	r0, [r0, #88]	; 0x58
 8001c08:	4770      	bx	lr
 8001c0a:	bf00      	nop
 8001c0c:	08009bc3 	.word	0x08009bc3

08001c10 <HAL_DMA_Init>:
  * @param  hdma: Pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Init(DMA_HandleTypeDef *hdma)
{
 8001c10:	b570      	push	{r4, r5, r6, lr}
 8001c12:	4604      	mov	r4, r0
  uint32_t tmp = 0U;
  uint32_t tickstart = HAL_GetTick();
 8001c14:	f7ff ff58 	bl	8001ac8 <HAL_GetTick>
 8001c18:	4605      	mov	r5, r0
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8001c1a:	2c00      	cmp	r4, #0
 8001c1c:	d064      	beq.n	8001ce8 <HAL_DMA_Init+0xd8>
    assert_param(IS_DMA_MEMORY_BURST(hdma->Init.MemBurst));
    assert_param(IS_DMA_PERIPHERAL_BURST(hdma->Init.PeriphBurst));
  }
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);
 8001c1e:	2300      	movs	r3, #0
 8001c20:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8001c24:	6822      	ldr	r2, [r4, #0]
  
  /* Allocate lock resource */
  __HAL_UNLOCK(hdma);

  /* Change DMA peripheral state */
  hdma->State = HAL_DMA_STATE_BUSY;
 8001c26:	2302      	movs	r3, #2
 8001c28:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35
  
  /* Disable the peripheral */
  __HAL_DMA_DISABLE(hdma);
 8001c2c:	6813      	ldr	r3, [r2, #0]
 8001c2e:	f023 0301 	bic.w	r3, r3, #1
 8001c32:	6013      	str	r3, [r2, #0]
  
  /* Check if the DMA Stream is effectively disabled */
  while((hdma->Instance->CR & DMA_SxCR_EN) != RESET)
 8001c34:	6821      	ldr	r1, [r4, #0]
 8001c36:	680b      	ldr	r3, [r1, #0]
 8001c38:	07d8      	lsls	r0, r3, #31
 8001c3a:	d508      	bpl.n	8001c4e <HAL_DMA_Init+0x3e>
  {
    /* Check for the Timeout */
    if((HAL_GetTick() - tickstart ) > HAL_TIMEOUT_DMA_ABORT)
 8001c3c:	f7ff ff44 	bl	8001ac8 <HAL_GetTick>
 8001c40:	1b40      	subs	r0, r0, r5
 8001c42:	2805      	cmp	r0, #5
 8001c44:	d9f6      	bls.n	8001c34 <HAL_DMA_Init+0x24>
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_TIMEOUT;
 8001c46:	2320      	movs	r3, #32
 8001c48:	6563      	str	r3, [r4, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_TIMEOUT;
 8001c4a:	2003      	movs	r0, #3
 8001c4c:	e051      	b.n	8001cf2 <HAL_DMA_Init+0xe2>
      return HAL_TIMEOUT;
    }
  }
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;
 8001c4e:	680b      	ldr	r3, [r1, #0]

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001c50:	4a29      	ldr	r2, [pc, #164]	; (8001cf8 <HAL_DMA_Init+0xe8>)
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001c52:	6865      	ldr	r5, [r4, #4]
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
 8001c54:	69a0      	ldr	r0, [r4, #24]
  
  /* Get the CR register value */
  tmp = hdma->Instance->CR;

  /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC, DIR, CT and DBM bits */
  tmp &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
 8001c56:	401a      	ands	r2, r3
                      DMA_SxCR_PL    | DMA_SxCR_MSIZE  | DMA_SxCR_PSIZE  | \
                      DMA_SxCR_MINC  | DMA_SxCR_PINC   | DMA_SxCR_CIRC   | \
                      DMA_SxCR_DIR   | DMA_SxCR_CT     | DMA_SxCR_DBM));

  /* Prepare the DMA Stream configuration */
  tmp |=  hdma->Init.Channel             | hdma->Init.Direction        |
 8001c58:	68a3      	ldr	r3, [r4, #8]
 8001c5a:	431d      	orrs	r5, r3
 8001c5c:	68e3      	ldr	r3, [r4, #12]
 8001c5e:	431d      	orrs	r5, r3
 8001c60:	6923      	ldr	r3, [r4, #16]
 8001c62:	431d      	orrs	r5, r3
 8001c64:	6963      	ldr	r3, [r4, #20]
 8001c66:	432b      	orrs	r3, r5
 8001c68:	69e5      	ldr	r5, [r4, #28]
 8001c6a:	4303      	orrs	r3, r0
 8001c6c:	432b      	orrs	r3, r5
 8001c6e:	6a25      	ldr	r5, [r4, #32]
 8001c70:	432b      	orrs	r3, r5
 8001c72:	4313      	orrs	r3, r2
          hdma->Init.PeriphInc           | hdma->Init.MemInc           |
          hdma->Init.PeriphDataAlignment | hdma->Init.MemDataAlignment |
          hdma->Init.Mode                | hdma->Init.Priority;

  /* the Memory burst and peripheral burst are not used when the FIFO is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001c74:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001c76:	2a04      	cmp	r2, #4
  {
    /* Get memory burst and peripheral burst */
    tmp |=  hdma->Init.MemBurst | hdma->Init.PeriphBurst;
 8001c78:	bf01      	itttt	eq
 8001c7a:	6b25      	ldreq	r5, [r4, #48]	; 0x30
 8001c7c:	6ae6      	ldreq	r6, [r4, #44]	; 0x2c
 8001c7e:	4335      	orreq	r5, r6
 8001c80:	432b      	orreq	r3, r5
  }
  
  /* Write to DMA Stream CR register */
  hdma->Instance->CR = tmp;  
 8001c82:	600b      	str	r3, [r1, #0]

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;
 8001c84:	694b      	ldr	r3, [r1, #20]

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001c86:	2a04      	cmp	r2, #4

  /* Get the FCR register value */
  tmp = hdma->Instance->FCR;

  /* Clear Direct mode and FIFO threshold bits */
  tmp &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
 8001c88:	f023 0307 	bic.w	r3, r3, #7

  /* Prepare the DMA Stream FIFO configuration */
  tmp |= hdma->Init.FIFOMode;
 8001c8c:	ea43 0302 	orr.w	r3, r3, r2

  /* the FIFO threshold is not used when the FIFO mode is disabled */
  if(hdma->Init.FIFOMode == DMA_FIFOMODE_ENABLE)
 8001c90:	d11c      	bne.n	8001ccc <HAL_DMA_Init+0xbc>
  {
    /* Get the FIFO threshold */
    tmp |= hdma->Init.FIFOThreshold;
 8001c92:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001c94:	4313      	orrs	r3, r2
{
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t tmp = hdma->Init.FIFOThreshold;
  
  /* Memory Data size equal to Byte */
  if(hdma->Init.MemDataAlignment == DMA_MDATAALIGN_BYTE)
 8001c96:	b920      	cbnz	r0, 8001ca2 <HAL_DMA_Init+0x92>
  {
    switch (tmp)
 8001c98:	2a01      	cmp	r2, #1
 8001c9a:	d00b      	beq.n	8001cb4 <HAL_DMA_Init+0xa4>
 8001c9c:	d313      	bcc.n	8001cc6 <HAL_DMA_Init+0xb6>
 8001c9e:	2a02      	cmp	r2, #2
 8001ca0:	e010      	b.n	8001cc4 <HAL_DMA_Init+0xb4>
        break;
    }
  }
  
  /* Memory Data size equal to Half-Word */
  else if (hdma->Init.MemDataAlignment == DMA_MDATAALIGN_HALFWORD)
 8001ca2:	f5b0 5f00 	cmp.w	r0, #8192	; 0x2000
 8001ca6:	d10a      	bne.n	8001cbe <HAL_DMA_Init+0xae>
  {
    switch (tmp)
 8001ca8:	2a03      	cmp	r2, #3
 8001caa:	d80f      	bhi.n	8001ccc <HAL_DMA_Init+0xbc>
 8001cac:	e8df f002 	tbb	[pc, r2]
 8001cb0:	021e0b1e 	.word	0x021e0b1e
        break;
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;
      case DMA_FIFO_THRESHOLD_FULL:
        if (hdma->Init.MemBurst == DMA_MBURST_INC16)
 8001cb4:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001cb6:	f1b2 7fc0 	cmp.w	r2, #25165824	; 0x1800000
 8001cba:	d107      	bne.n	8001ccc <HAL_DMA_Init+0xbc>
 8001cbc:	e016      	b.n	8001cec <HAL_DMA_Init+0xdc>
  }
  
  /* Memory Data size equal to Word */
  else
  {
    switch (tmp)
 8001cbe:	2a02      	cmp	r2, #2
 8001cc0:	d914      	bls.n	8001cec <HAL_DMA_Init+0xdc>
 8001cc2:	2a03      	cmp	r2, #3
 8001cc4:	d102      	bne.n	8001ccc <HAL_DMA_Init+0xbc>
      case DMA_FIFO_THRESHOLD_HALFFULL:
      case DMA_FIFO_THRESHOLD_3QUARTERSFULL:
        status = HAL_ERROR;
        break;
      case DMA_FIFO_THRESHOLD_FULL:
        if ((hdma->Init.MemBurst & DMA_SxCR_MBURST_1) == DMA_SxCR_MBURST_1)
 8001cc6:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001cc8:	01d2      	lsls	r2, r2, #7
 8001cca:	d40f      	bmi.n	8001cec <HAL_DMA_Init+0xdc>
      return HAL_ERROR; 
    }
  }
  
  /* Write to DMA Stream FCR */
  hdma->Instance->FCR = tmp;
 8001ccc:	614b      	str	r3, [r1, #20]

  /* Initialize StreamBaseAddress and StreamIndex parameters to be used to calculate
     DMA steam Base Address needed by HAL_DMA_IRQHandler() and HAL_DMA_PollForTransfer() */
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8001cce:	4620      	mov	r0, r4
 8001cd0:	f7ff ff88 	bl	8001be4 <DMA_CalcBaseAndBitshift>
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001cd4:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8001cd6:	233f      	movs	r3, #63	; 0x3f
 8001cd8:	4093      	lsls	r3, r2
 8001cda:	6083      	str	r3, [r0, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001cdc:	2000      	movs	r0, #0
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8001cde:	2301      	movs	r3, #1
  
  /* Clear all interrupt flags */
  regs->IFCR = 0x3FU << hdma->StreamIndex;

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001ce0:	6560      	str	r0, [r4, #84]	; 0x54
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;
 8001ce2:	f884 3035 	strb.w	r3, [r4, #53]	; 0x35

  return HAL_OK;
 8001ce6:	bd70      	pop	{r4, r5, r6, pc}
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 8001ce8:	2001      	movs	r0, #1
 8001cea:	bd70      	pop	{r4, r5, r6, pc}
    tmp |= hdma->Init.FIFOThreshold;
    
    if(DMA_CheckFifoParam(hdma) != HAL_OK)
    {
      /* Update error code */
      hdma->ErrorCode = HAL_DMA_ERROR_PARAM;
 8001cec:	2340      	movs	r3, #64	; 0x40
 8001cee:	6563      	str	r3, [r4, #84]	; 0x54
      
      /* Change the DMA state */
      hdma->State = HAL_DMA_STATE_READY;
 8001cf0:	2001      	movs	r0, #1
 8001cf2:	f884 0035 	strb.w	r0, [r4, #53]	; 0x35
                                                                                     
  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_READY;

  return HAL_OK;
}
 8001cf6:	bd70      	pop	{r4, r5, r6, pc}
 8001cf8:	f010803f 	.word	0xf010803f

08001cfc <HAL_DMA_DeInit>:
  * @param  hdma: pointer to a DMA_HandleTypeDef structure that contains
  *               the configuration information for the specified DMA Stream.  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_DeInit(DMA_HandleTypeDef *hdma)
{
 8001cfc:	b538      	push	{r3, r4, r5, lr}
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
 8001cfe:	4605      	mov	r5, r0
 8001d00:	b1e8      	cbz	r0, 8001d3e <HAL_DMA_DeInit+0x42>
  {
    return HAL_ERROR;
  }
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
 8001d02:	f890 4035 	ldrb.w	r4, [r0, #53]	; 0x35
 8001d06:	b2e4      	uxtb	r4, r4
 8001d08:	2c02      	cmp	r4, #2
 8001d0a:	d01a      	beq.n	8001d42 <HAL_DMA_DeInit+0x46>
    /* Return error status */
    return HAL_BUSY;
  }

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);
 8001d0c:	6803      	ldr	r3, [r0, #0]
 8001d0e:	681a      	ldr	r2, [r3, #0]
 8001d10:	f022 0201 	bic.w	r2, r2, #1
 8001d14:	601a      	str	r2, [r3, #0]

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0U;
 8001d16:	2400      	movs	r4, #0
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0U;
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 8001d18:	2221      	movs	r2, #33	; 0x21

  /* Disable the selected DMA Streamx */
  __HAL_DMA_DISABLE(hdma);

  /* Reset DMA Streamx control register */
  hdma->Instance->CR   = 0U;
 8001d1a:	601c      	str	r4, [r3, #0]

  /* Reset DMA Streamx number of data to transfer register */
  hdma->Instance->NDTR = 0U;
 8001d1c:	605c      	str	r4, [r3, #4]

  /* Reset DMA Streamx peripheral address register */
  hdma->Instance->PAR  = 0U;
 8001d1e:	609c      	str	r4, [r3, #8]

  /* Reset DMA Streamx memory 0 address register */
  hdma->Instance->M0AR = 0U;
 8001d20:	60dc      	str	r4, [r3, #12]
  
  /* Reset DMA Streamx memory 1 address register */
  hdma->Instance->M1AR = 0U;
 8001d22:	611c      	str	r4, [r3, #16]
  
  /* Reset DMA Streamx FIFO control register */
  hdma->Instance->FCR  = (uint32_t)0x00000021U;
 8001d24:	615a      	str	r2, [r3, #20]
  
  /* Get DMA steam Base Address */  
  regs = (DMA_Base_Registers *)DMA_CalcBaseAndBitshift(hdma);
 8001d26:	f7ff ff5d 	bl	8001be4 <DMA_CalcBaseAndBitshift>
  
  /* Clear all interrupt flags at correct offset within the register */
  regs->IFCR = 0x3FU << hdma->StreamIndex;
 8001d2a:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8001d2c:	233f      	movs	r3, #63	; 0x3f
 8001d2e:	4093      	lsls	r3, r2
 8001d30:	6083      	str	r3, [r0, #8]

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;
 8001d32:	656c      	str	r4, [r5, #84]	; 0x54

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hdma);
 8001d34:	f885 4034 	strb.w	r4, [r5, #52]	; 0x34

  /* Initialize the error code */
  hdma->ErrorCode = HAL_DMA_ERROR_NONE;

  /* Initialize the DMA state */
  hdma->State = HAL_DMA_STATE_RESET;
 8001d38:	f885 4035 	strb.w	r4, [r5, #53]	; 0x35
 8001d3c:	e001      	b.n	8001d42 <HAL_DMA_DeInit+0x46>
  DMA_Base_Registers *regs;

  /* Check the DMA peripheral state */
  if(hdma == NULL)
  {
    return HAL_ERROR;
 8001d3e:	2001      	movs	r0, #1
 8001d40:	bd38      	pop	{r3, r4, r5, pc}
  
  /* Check the DMA peripheral state */
  if(hdma->State == HAL_DMA_STATE_BUSY)
  {
    /* Return error status */
    return HAL_BUSY;
 8001d42:	4620      	mov	r0, r4

  /* Release Lock */
  __HAL_UNLOCK(hdma);

  return HAL_OK;
}
 8001d44:	bd38      	pop	{r3, r4, r5, pc}

08001d46 <HAL_DMA_Abort_IT>:
  *                 the configuration information for the specified DMA Stream.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA_Abort_IT(DMA_HandleTypeDef *hdma)
{
  if(hdma->State != HAL_DMA_STATE_BUSY)
 8001d46:	f890 3035 	ldrb.w	r3, [r0, #53]	; 0x35
 8001d4a:	2b02      	cmp	r3, #2
 8001d4c:	d003      	beq.n	8001d56 <HAL_DMA_Abort_IT+0x10>
  {
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
 8001d4e:	2380      	movs	r3, #128	; 0x80
 8001d50:	6543      	str	r3, [r0, #84]	; 0x54
    return HAL_ERROR;
 8001d52:	2001      	movs	r0, #1
 8001d54:	4770      	bx	lr
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8001d56:	6802      	ldr	r2, [r0, #0]
    return HAL_ERROR;
  }
  else
  {
    /* Set Abort State  */
    hdma->State = HAL_DMA_STATE_ABORT;
 8001d58:	2305      	movs	r3, #5
 8001d5a:	f880 3035 	strb.w	r3, [r0, #53]	; 0x35
    
    /* Disable the stream */
    __HAL_DMA_DISABLE(hdma);
 8001d5e:	6813      	ldr	r3, [r2, #0]
 8001d60:	f023 0301 	bic.w	r3, r3, #1
 8001d64:	6013      	str	r3, [r2, #0]
  }

  return HAL_OK;
 8001d66:	2000      	movs	r0, #0
}
 8001d68:	4770      	bx	lr

08001d6a <HAL_DMA2D_Init>:
  * @param  hdma2d: pointer to a DMA2D_HandleTypeDef structure that contains
  *                 the configuration information for the DMA2D.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
 8001d6a:	b510      	push	{r4, lr}
  /* Check the DMA2D peripheral state */
  if(hdma2d == NULL)
 8001d6c:	4604      	mov	r4, r0
 8001d6e:	b330      	cbz	r0, 8001dbe <HAL_DMA2D_Init+0x54>
  assert_param(IS_DMA2D_ALL_INSTANCE(hdma2d->Instance));
  assert_param(IS_DMA2D_MODE(hdma2d->Init.Mode));
  assert_param(IS_DMA2D_CMODE(hdma2d->Init.ColorMode));
  assert_param(IS_DMA2D_OFFSET(hdma2d->Init.OutputOffset));

  if(hdma2d->State == HAL_DMA2D_STATE_RESET)
 8001d70:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8001d74:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001d78:	b91b      	cbnz	r3, 8001d82 <HAL_DMA2D_Init+0x18>
  {
    /* Allocate lock resource and initialize it */
    hdma2d->Lock = HAL_UNLOCKED;
 8001d7a:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    /* Init the low level hardware */
    HAL_DMA2D_MspInit(hdma2d);
 8001d7e:	f002 fa31 	bl	80041e4 <HAL_DMA2D_MspInit>
  }

  /* Change DMA2D peripheral state */
  hdma2d->State = HAL_DMA2D_STATE_BUSY;
 8001d82:	2302      	movs	r3, #2
 8001d84:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* DMA2D CR register configuration -------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->CR, DMA2D_CR_MODE, hdma2d->Init.Mode);
 8001d88:	6823      	ldr	r3, [r4, #0]
 8001d8a:	681a      	ldr	r2, [r3, #0]
 8001d8c:	f422 3140 	bic.w	r1, r2, #196608	; 0x30000
 8001d90:	6862      	ldr	r2, [r4, #4]
 8001d92:	430a      	orrs	r2, r1
 8001d94:	601a      	str	r2, [r3, #0]

  /* DMA2D OPFCCR register configuration ---------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OPFCCR, DMA2D_OPFCCR_CM, hdma2d->Init.ColorMode);
 8001d96:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001d98:	f022 0107 	bic.w	r1, r2, #7
 8001d9c:	68a2      	ldr	r2, [r4, #8]
 8001d9e:	430a      	orrs	r2, r1
 8001da0:	635a      	str	r2, [r3, #52]	; 0x34

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);  
 8001da2:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8001da4:	68e1      	ldr	r1, [r4, #12]
 8001da6:	f422 527f 	bic.w	r2, r2, #16320	; 0x3fc0
 8001daa:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8001dae:	430a      	orrs	r2, r1
 8001db0:	641a      	str	r2, [r3, #64]	; 0x40

  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8001db2:	2000      	movs	r0, #0

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8001db4:	2301      	movs	r3, #1

  /* DMA2D OOR register configuration ------------------------------------------*/
  MODIFY_REG(hdma2d->Instance->OOR, DMA2D_OOR_LO, hdma2d->Init.OutputOffset);  

  /* Update error code */
  hdma2d->ErrorCode = HAL_DMA2D_ERROR_NONE;
 8001db6:	63e0      	str	r0, [r4, #60]	; 0x3c

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;
 8001db8:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  return HAL_OK;
 8001dbc:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_DMA2D_Init(DMA2D_HandleTypeDef *hdma2d)
{
  /* Check the DMA2D peripheral state */
  if(hdma2d == NULL)
  {
     return HAL_ERROR;
 8001dbe:	2001      	movs	r0, #1

  /* Initialize the DMA2D state*/
  hdma2d->State  = HAL_DMA2D_STATE_READY;

  return HAL_OK;
}
 8001dc0:	bd10      	pop	{r4, pc}
	...

08001dc4 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001dc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001dc8:	4f70      	ldr	r7, [pc, #448]	; (8001f8c <HAL_GPIO_Init+0x1c8>)
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001dca:	680b      	ldr	r3, [r1, #0]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001dcc:	f8df c1c4 	ldr.w	ip, [pc, #452]	; 8001f94 <HAL_GPIO_Init+0x1d0>

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001dd0:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 8001f98 <HAL_GPIO_Init+0x1d4>
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001dd4:	b085      	sub	sp, #20
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001dd6:	2200      	movs	r2, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8001dd8:	9301      	str	r3, [sp, #4]
 8001dda:	46be      	mov	lr, r7

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8001ddc:	2401      	movs	r4, #1
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8001dde:	9b01      	ldr	r3, [sp, #4]

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8001de0:	4094      	lsls	r4, r2
    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;

    if(iocurrent == ioposition)
 8001de2:	ea34 0303 	bics.w	r3, r4, r3
 8001de6:	f040 80c9 	bne.w	8001f7c <HAL_GPIO_Init+0x1b8>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001dea:	684d      	ldr	r5, [r1, #4]
 8001dec:	f025 0a10 	bic.w	sl, r5, #16
 8001df0:	f1ba 0f02 	cmp.w	sl, #2
 8001df4:	d114      	bne.n	8001e20 <HAL_GPIO_Init+0x5c>
 8001df6:	ea4f 09d2 	mov.w	r9, r2, lsr #3
 8001dfa:	eb00 0989 	add.w	r9, r0, r9, lsl #2
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8001dfe:	f002 0b07 	and.w	fp, r2, #7
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Alternate function parameter */
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));
        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8001e02:	f8d9 6020 	ldr.w	r6, [r9, #32]
        temp &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8001e06:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 8001e0a:	230f      	movs	r3, #15
 8001e0c:	fa03 f30b 	lsl.w	r3, r3, fp
 8001e10:	ea26 0603 	bic.w	r6, r6, r3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
 8001e14:	690b      	ldr	r3, [r1, #16]
 8001e16:	fa03 f30b 	lsl.w	r3, r3, fp
 8001e1a:	4333      	orrs	r3, r6
        GPIOx->AFR[position >> 3U] = temp;
 8001e1c:	f8c9 3020 	str.w	r3, [r9, #32]
 8001e20:	ea4f 0b42 	mov.w	fp, r2, lsl #1
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001e24:	f04f 0903 	mov.w	r9, #3
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8001e28:	6803      	ldr	r3, [r0, #0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001e2a:	fa09 f90b 	lsl.w	r9, r9, fp
 8001e2e:	ea6f 0909 	mvn.w	r9, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001e32:	f005 0603 	and.w	r6, r5, #3
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001e36:	ea03 0309 	and.w	r3, r3, r9
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001e3a:	fa06 f60b 	lsl.w	r6, r6, fp
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001e3e:	f10a 3aff 	add.w	sl, sl, #4294967295
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001e42:	4333      	orrs	r3, r6
      GPIOx->MODER = temp;

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001e44:	f1ba 0f01 	cmp.w	sl, #1

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
      GPIOx->MODER = temp;
 8001e48:	6003      	str	r3, [r0, #0]

      /* In case of Output or Alternate function mode selection */
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001e4a:	d80f      	bhi.n	8001e6c <HAL_GPIO_Init+0xa8>
         (GPIO_Init->Mode == GPIO_MODE_OUTPUT_OD) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
 8001e4c:	6883      	ldr	r3, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001e4e:	68ce      	ldr	r6, [r1, #12]
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));
        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR; 
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001e50:	ea09 0303 	and.w	r3, r9, r3
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001e54:	fa06 f60b 	lsl.w	r6, r6, fp
 8001e58:	431e      	orrs	r6, r3
        GPIOx->OSPEEDR = temp;
 8001e5a:	6086      	str	r6, [r0, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8001e5c:	6843      	ldr	r3, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8001e5e:	f3c5 1600 	ubfx	r6, r5, #4, #1
        temp |= (GPIO_Init->Speed << (position * 2U));
        GPIOx->OSPEEDR = temp;

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001e62:	ea23 0304 	bic.w	r3, r3, r4
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8001e66:	4096      	lsls	r6, r2
 8001e68:	4333      	orrs	r3, r6
        GPIOx->OTYPER = temp;
 8001e6a:	6043      	str	r3, [r0, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8001e6c:	68c3      	ldr	r3, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 8001e6e:	ea09 0903 	and.w	r9, r9, r3
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001e72:	688b      	ldr	r3, [r1, #8]
 8001e74:	fa03 f30b 	lsl.w	r3, r3, fp
 8001e78:	ea43 0309 	orr.w	r3, r3, r9
      GPIOx->PUPDR = temp;
 8001e7c:	60c3      	str	r3, [r0, #12]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001e7e:	00eb      	lsls	r3, r5, #3
 8001e80:	d57c      	bpl.n	8001f7c <HAL_GPIO_Init+0x1b8>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001e82:	2300      	movs	r3, #0
 8001e84:	9303      	str	r3, [sp, #12]
 8001e86:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001e8a:	4b41      	ldr	r3, [pc, #260]	; (8001f90 <HAL_GPIO_Init+0x1cc>)
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001e8c:	f446 4680 	orr.w	r6, r6, #16384	; 0x4000
 8001e90:	f8cc 6044 	str.w	r6, [ip, #68]	; 0x44
 8001e94:	f8dc 6044 	ldr.w	r6, [ip, #68]	; 0x44
 8001e98:	f022 0903 	bic.w	r9, r2, #3
 8001e9c:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
 8001ea0:	f406 4680 	and.w	r6, r6, #16384	; 0x4000
 8001ea4:	f509 399c 	add.w	r9, r9, #79872	; 0x13800
 8001ea8:	9603      	str	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8001eaa:	f002 0a03 	and.w	sl, r2, #3
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001eae:	9e03      	ldr	r6, [sp, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8001eb0:	f8d9 b008 	ldr.w	fp, [r9, #8]
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8001eb4:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8001eb8:	260f      	movs	r6, #15
 8001eba:	fa06 f60a 	lsl.w	r6, r6, sl
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001ebe:	4298      	cmp	r0, r3
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();

        temp = SYSCFG->EXTICR[position >> 2U];
        temp &= ~(((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8001ec0:	ea2b 0606 	bic.w	r6, fp, r6
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
 8001ec4:	d024      	beq.n	8001f10 <HAL_GPIO_Init+0x14c>
 8001ec6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001eca:	4298      	cmp	r0, r3
 8001ecc:	d022      	beq.n	8001f14 <HAL_GPIO_Init+0x150>
 8001ece:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001ed2:	4298      	cmp	r0, r3
 8001ed4:	d020      	beq.n	8001f18 <HAL_GPIO_Init+0x154>
 8001ed6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001eda:	4298      	cmp	r0, r3
 8001edc:	d01e      	beq.n	8001f1c <HAL_GPIO_Init+0x158>
 8001ede:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001ee2:	4298      	cmp	r0, r3
 8001ee4:	d01c      	beq.n	8001f20 <HAL_GPIO_Init+0x15c>
 8001ee6:	4540      	cmp	r0, r8
 8001ee8:	d01c      	beq.n	8001f24 <HAL_GPIO_Init+0x160>
 8001eea:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8001eee:	4298      	cmp	r0, r3
 8001ef0:	d01a      	beq.n	8001f28 <HAL_GPIO_Init+0x164>
 8001ef2:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001ef6:	4298      	cmp	r0, r3
 8001ef8:	d018      	beq.n	8001f2c <HAL_GPIO_Init+0x168>
 8001efa:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001efe:	4298      	cmp	r0, r3
 8001f00:	d016      	beq.n	8001f30 <HAL_GPIO_Init+0x16c>
 8001f02:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001f06:	4298      	cmp	r0, r3
 8001f08:	bf14      	ite	ne
 8001f0a:	230a      	movne	r3, #10
 8001f0c:	2309      	moveq	r3, #9
 8001f0e:	e010      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f10:	2300      	movs	r3, #0
 8001f12:	e00e      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f14:	2301      	movs	r3, #1
 8001f16:	e00c      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f18:	2302      	movs	r3, #2
 8001f1a:	e00a      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f1c:	2303      	movs	r3, #3
 8001f1e:	e008      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f20:	2304      	movs	r3, #4
 8001f22:	e006      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f24:	2305      	movs	r3, #5
 8001f26:	e004      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f28:	2306      	movs	r3, #6
 8001f2a:	e002      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f2c:	2307      	movs	r3, #7
 8001f2e:	e000      	b.n	8001f32 <HAL_GPIO_Init+0x16e>
 8001f30:	2308      	movs	r3, #8
 8001f32:	fa03 f30a 	lsl.w	r3, r3, sl
 8001f36:	4333      	orrs	r3, r6
        SYSCFG->EXTICR[position >> 2U] = temp;
 8001f38:	f8c9 3008 	str.w	r3, [r9, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 8001f3c:	683b      	ldr	r3, [r7, #0]
        temp &= ~((uint32_t)iocurrent);
 8001f3e:	43e6      	mvns	r6, r4
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001f40:	f415 3f80 	tst.w	r5, #65536	; 0x10000
        temp |= ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
        temp &= ~((uint32_t)iocurrent);
 8001f44:	bf0c      	ite	eq
 8001f46:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
        {
          temp |= iocurrent;
 8001f48:	4323      	orrne	r3, r4
        }
        EXTI->IMR = temp;
 8001f4a:	f8ce 3000 	str.w	r3, [lr]

        temp = EXTI->EMR;
 8001f4e:	f8de 3004 	ldr.w	r3, [lr, #4]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001f52:	f415 3f00 	tst.w	r5, #131072	; 0x20000
          temp |= iocurrent;
        }
        EXTI->IMR = temp;

        temp = EXTI->EMR;
        temp &= ~((uint32_t)iocurrent);
 8001f56:	bf0c      	ite	eq
 8001f58:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
        {
          temp |= iocurrent;
 8001f5a:	4323      	orrne	r3, r4
        }
        EXTI->EMR = temp;
 8001f5c:	607b      	str	r3, [r7, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
 8001f5e:	68bb      	ldr	r3, [r7, #8]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001f60:	f415 1f80 	tst.w	r5, #1048576	; 0x100000
        }
        EXTI->EMR = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR;
        temp &= ~((uint32_t)iocurrent);
 8001f64:	bf0c      	ite	eq
 8001f66:	4033      	andeq	r3, r6
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
        {
          temp |= iocurrent;
 8001f68:	4323      	orrne	r3, r4
        }
        EXTI->RTSR = temp;
 8001f6a:	f8ce 3008 	str.w	r3, [lr, #8]

        temp = EXTI->FTSR;
 8001f6e:	f8de 300c 	ldr.w	r3, [lr, #12]
        temp &= ~((uint32_t)iocurrent);
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001f72:	02ad      	lsls	r5, r5, #10
          temp |= iocurrent;
        }
        EXTI->RTSR = temp;

        temp = EXTI->FTSR;
        temp &= ~((uint32_t)iocurrent);
 8001f74:	bf54      	ite	pl
 8001f76:	4033      	andpl	r3, r6
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
        {
          temp |= iocurrent;
 8001f78:	4323      	orrmi	r3, r4
        }
        EXTI->FTSR = temp;
 8001f7a:	60fb      	str	r3, [r7, #12]
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001f7c:	3201      	adds	r2, #1
 8001f7e:	2a10      	cmp	r2, #16
 8001f80:	f47f af2c 	bne.w	8001ddc <HAL_GPIO_Init+0x18>
        }
        EXTI->FTSR = temp;
      }
    }
  }
}
 8001f84:	b005      	add	sp, #20
 8001f86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001f8a:	bf00      	nop
 8001f8c:	40013c00 	.word	0x40013c00
 8001f90:	40020000 	.word	0x40020000
 8001f94:	40023800 	.word	0x40023800
 8001f98:	40021400 	.word	0x40021400

08001f9c <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *          This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8001f9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0FU) << (4U * (position & 0x03U));
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 8001fa0:	4c4d      	ldr	r4, [pc, #308]	; (80020d8 <HAL_GPIO_DeInit+0x13c>)
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 8001fa2:	f8df a13c 	ldr.w	sl, [pc, #316]	; 80020e0 <HAL_GPIO_DeInit+0x144>
 8001fa6:	f8df b13c 	ldr.w	fp, [pc, #316]	; 80020e4 <HAL_GPIO_DeInit+0x148>

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 8001faa:	2200      	movs	r2, #0
  {
    /* Get the IO position */
    ioposition = ((uint32_t)0x01U) << position;
 8001fac:	f04f 0901 	mov.w	r9, #1
 8001fb0:	fa09 f502 	lsl.w	r5, r9, r2
    /* Get the current IO position */
    iocurrent = (GPIO_Pin) & ioposition;

    if(iocurrent == ioposition)
 8001fb4:	ea35 0301 	bics.w	r3, r5, r1
 8001fb8:	f040 8087 	bne.w	80020ca <HAL_GPIO_DeInit+0x12e>
    {
      /*------------------------- GPIO Mode Configuration --------------------*/
      /* Configure IO Direction in Input Floating Mode */
      GPIOx->MODER &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8001fbc:	2303      	movs	r3, #3
 8001fbe:	fa02 f609 	lsl.w	r6, r2, r9
 8001fc2:	6807      	ldr	r7, [r0, #0]
 8001fc4:	fa03 f606 	lsl.w	r6, r3, r6
 8001fc8:	43f6      	mvns	r6, r6
 8001fca:	fa22 fc03 	lsr.w	ip, r2, r3
 8001fce:	4037      	ands	r7, r6
 8001fd0:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
 8001fd4:	6007      	str	r7, [r0, #0]

      /* Configure the default Alternate Function in current IO */
      GPIOx->AFR[position >> 3U] &= ~((uint32_t)0xFU << ((uint32_t)(position & (uint32_t)0x07U) * 4U)) ;
 8001fd6:	f002 0e07 	and.w	lr, r2, #7
 8001fda:	f8dc 8020 	ldr.w	r8, [ip, #32]
 8001fde:	270f      	movs	r7, #15
 8001fe0:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 8001fe4:	fa07 fe0e 	lsl.w	lr, r7, lr
 8001fe8:	ea28 0e0e 	bic.w	lr, r8, lr
 8001fec:	f8cc e020 	str.w	lr, [ip, #32]

      /* Configure the default value for IO Speed */
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 8001ff0:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8001ff4:	ea06 0e0e 	and.w	lr, r6, lr
 8001ff8:	f8c0 e008 	str.w	lr, [r0, #8]

      /* Configure the default value IO Output Type */
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT_0 << position) ;
 8001ffc:	f8d0 e004 	ldr.w	lr, [r0, #4]
 8002000:	43ed      	mvns	r5, r5
 8002002:	ea0e 0e05 	and.w	lr, lr, r5
 8002006:	f8c0 e004 	str.w	lr, [r0, #4]

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 800200a:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 800200e:	ea06 060e 	and.w	r6, r6, lr
 8002012:	60c6      	str	r6, [r0, #12]
 8002014:	f022 0603 	bic.w	r6, r2, #3
 8002018:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 800201c:	f506 369c 	add.w	r6, r6, #79872	; 0x13800

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8002020:	ea02 0e03 	and.w	lr, r2, r3
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 8002024:	4b2d      	ldr	r3, [pc, #180]	; (80020dc <HAL_GPIO_DeInit+0x140>)

      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2U];
 8002026:	f8d6 c008 	ldr.w	ip, [r6, #8]
      tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 800202a:	ea4f 0e8e 	mov.w	lr, lr, lsl #2
 800202e:	fa07 f70e 	lsl.w	r7, r7, lr
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 8002032:	4298      	cmp	r0, r3
      /* Deactivate the Pull-up and Pull-down resistor for the current IO */
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));

      /*------------------------- EXTI Mode Configuration --------------------*/
      tmp = SYSCFG->EXTICR[position >> 2U];
      tmp &= (((uint32_t)0x0FU) << (4U * (position & 0x03U)));
 8002034:	ea0c 0c07 	and.w	ip, ip, r7
      if(tmp == ((uint32_t)(GPIO_GET_INDEX(GPIOx)) << (4U * (position & 0x03U))))
 8002038:	d022      	beq.n	8002080 <HAL_GPIO_DeInit+0xe4>
 800203a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800203e:	4298      	cmp	r0, r3
 8002040:	d020      	beq.n	8002084 <HAL_GPIO_DeInit+0xe8>
 8002042:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002046:	4298      	cmp	r0, r3
 8002048:	d01e      	beq.n	8002088 <HAL_GPIO_DeInit+0xec>
 800204a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800204e:	4298      	cmp	r0, r3
 8002050:	d01c      	beq.n	800208c <HAL_GPIO_DeInit+0xf0>
 8002052:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002056:	4298      	cmp	r0, r3
 8002058:	d01a      	beq.n	8002090 <HAL_GPIO_DeInit+0xf4>
 800205a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 800205e:	4298      	cmp	r0, r3
 8002060:	d018      	beq.n	8002094 <HAL_GPIO_DeInit+0xf8>
 8002062:	4550      	cmp	r0, sl
 8002064:	d018      	beq.n	8002098 <HAL_GPIO_DeInit+0xfc>
 8002066:	4558      	cmp	r0, fp
 8002068:	d018      	beq.n	800209c <HAL_GPIO_DeInit+0x100>
 800206a:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 800206e:	4298      	cmp	r0, r3
 8002070:	d016      	beq.n	80020a0 <HAL_GPIO_DeInit+0x104>
 8002072:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002076:	4298      	cmp	r0, r3
 8002078:	bf0c      	ite	eq
 800207a:	2309      	moveq	r3, #9
 800207c:	230a      	movne	r3, #10
 800207e:	e010      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 8002080:	2300      	movs	r3, #0
 8002082:	e00e      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 8002084:	464b      	mov	r3, r9
 8002086:	e00c      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 8002088:	2302      	movs	r3, #2
 800208a:	e00a      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 800208c:	2303      	movs	r3, #3
 800208e:	e008      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 8002090:	2304      	movs	r3, #4
 8002092:	e006      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 8002094:	2305      	movs	r3, #5
 8002096:	e004      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 8002098:	2306      	movs	r3, #6
 800209a:	e002      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 800209c:	2307      	movs	r3, #7
 800209e:	e000      	b.n	80020a2 <HAL_GPIO_DeInit+0x106>
 80020a0:	2308      	movs	r3, #8
 80020a2:	fa03 f30e 	lsl.w	r3, r3, lr
 80020a6:	459c      	cmp	ip, r3
 80020a8:	d10f      	bne.n	80020ca <HAL_GPIO_DeInit+0x12e>
      {
        /* Configure the External Interrupt or event for the current IO */
        tmp = ((uint32_t)0x0FU) << (4U * (position & 0x03U));
        SYSCFG->EXTICR[position >> 2U] &= ~tmp;
 80020aa:	68b3      	ldr	r3, [r6, #8]
 80020ac:	ea23 0707 	bic.w	r7, r3, r7
 80020b0:	60b7      	str	r7, [r6, #8]

        /* Clear EXTI line configuration */
        EXTI->IMR &= ~((uint32_t)iocurrent);
 80020b2:	6823      	ldr	r3, [r4, #0]
 80020b4:	402b      	ands	r3, r5
 80020b6:	6023      	str	r3, [r4, #0]
        EXTI->EMR &= ~((uint32_t)iocurrent);
 80020b8:	6863      	ldr	r3, [r4, #4]
 80020ba:	402b      	ands	r3, r5
 80020bc:	6063      	str	r3, [r4, #4]
        
        /* Clear Rising Falling edge configuration */
        EXTI->RTSR &= ~((uint32_t)iocurrent);
 80020be:	68a3      	ldr	r3, [r4, #8]
 80020c0:	402b      	ands	r3, r5
 80020c2:	60a3      	str	r3, [r4, #8]
        EXTI->FTSR &= ~((uint32_t)iocurrent);
 80020c4:	68e3      	ldr	r3, [r4, #12]
 80020c6:	401d      	ands	r5, r3
 80020c8:	60e5      	str	r5, [r4, #12]

  /* Check the parameters */
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  
  /* Configure the port pins */
  for(position = 0U; position < GPIO_NUMBER; position++)
 80020ca:	3201      	adds	r2, #1
 80020cc:	2a10      	cmp	r2, #16
 80020ce:	f47f af6d 	bne.w	8001fac <HAL_GPIO_DeInit+0x10>
        EXTI->RTSR &= ~((uint32_t)iocurrent);
        EXTI->FTSR &= ~((uint32_t)iocurrent);
      }
    }
  }
}
 80020d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80020d6:	bf00      	nop
 80020d8:	40013c00 	.word	0x40013c00
 80020dc:	40020000 	.word	0x40020000
 80020e0:	40021800 	.word	0x40021800
 80020e4:	40021c00 	.word	0x40021c00

080020e8 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 80020e8:	6903      	ldr	r3, [r0, #16]
  }
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
 80020ea:	4219      	tst	r1, r3
}
 80020ec:	bf14      	ite	ne
 80020ee:	2001      	movne	r0, #1
 80020f0:	2000      	moveq	r0, #0
 80020f2:	4770      	bx	lr

080020f4 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80020f4:	b902      	cbnz	r2, 80020f8 <HAL_GPIO_WritePin+0x4>
  {
    GPIOx->BSRR = GPIO_Pin;
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16U;
 80020f6:	0409      	lsls	r1, r1, #16
 80020f8:	6181      	str	r1, [r0, #24]
 80020fa:	4770      	bx	lr

080020fc <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 80020fc:	6943      	ldr	r3, [r0, #20]
 80020fe:	4059      	eors	r1, r3
 8002100:	6141      	str	r1, [r0, #20]
 8002102:	4770      	bx	lr

08002104 <I2C_IsAcknowledgeFailed>:
  *                the configuration information for the specified I2C.
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_IsAcknowledgeFailed(I2C_HandleTypeDef *hi2c)
{
  if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002104:	6802      	ldr	r2, [r0, #0]
 8002106:	6953      	ldr	r3, [r2, #20]
 8002108:	f413 6380 	ands.w	r3, r3, #1024	; 0x400
 800210c:	d00d      	beq.n	800212a <I2C_IsAcknowledgeFailed+0x26>
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 800210e:	f46f 6380 	mvn.w	r3, #1024	; 0x400
 8002112:	6153      	str	r3, [r2, #20]

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 8002114:	2304      	movs	r3, #4
 8002116:	6403      	str	r3, [r0, #64]	; 0x40
    hi2c->PreviousState = I2C_STATE_NONE;
    hi2c->State= HAL_I2C_STATE_READY;
 8002118:	2220      	movs	r2, #32
  {
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->PreviousState = I2C_STATE_NONE;
 800211a:	2300      	movs	r3, #0
 800211c:	6303      	str	r3, [r0, #48]	; 0x30
    hi2c->State= HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800211e:	f880 303c 	strb.w	r3, [r0, #60]	; 0x3c
    /* Clear NACKF Flag */
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

    hi2c->ErrorCode = HAL_I2C_ERROR_AF;
    hi2c->PreviousState = I2C_STATE_NONE;
    hi2c->State= HAL_I2C_STATE_READY;
 8002122:	f880 203d 	strb.w	r2, [r0, #61]	; 0x3d

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);

    return HAL_ERROR;
 8002126:	2001      	movs	r0, #1
 8002128:	4770      	bx	lr
  }
  return HAL_OK;
 800212a:	4618      	mov	r0, r3
}
 800212c:	4770      	bx	lr

0800212e <I2C_WaitOnFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, FlagStatus Status, uint32_t Timeout, uint32_t Tickstart)
{
 800212e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8002132:	9c08      	ldr	r4, [sp, #32]
 8002134:	4605      	mov	r5, r0
 8002136:	460e      	mov	r6, r1
 8002138:	4690      	mov	r8, r2
 800213a:	461f      	mov	r7, r3
  /* Wait until flag is set */
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
 800213c:	f3c1 4907 	ubfx	r9, r1, #16, #8
 8002140:	682b      	ldr	r3, [r5, #0]
 8002142:	f1b9 0f01 	cmp.w	r9, #1
 8002146:	bf0c      	ite	eq
 8002148:	6958      	ldreq	r0, [r3, #20]
 800214a:	6998      	ldrne	r0, [r3, #24]
 800214c:	43c0      	mvns	r0, r0
 800214e:	b280      	uxth	r0, r0
 8002150:	4230      	tst	r0, r6
 8002152:	bf0c      	ite	eq
 8002154:	2301      	moveq	r3, #1
 8002156:	2300      	movne	r3, #0
 8002158:	4543      	cmp	r3, r8
 800215a:	d112      	bne.n	8002182 <I2C_WaitOnFlagUntilTimeout+0x54>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 800215c:	1c7b      	adds	r3, r7, #1
 800215e:	d0ef      	beq.n	8002140 <I2C_WaitOnFlagUntilTimeout+0x12>
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8002160:	b94f      	cbnz	r7, 8002176 <I2C_WaitOnFlagUntilTimeout+0x48>
      {
        hi2c->PreviousState = I2C_STATE_NONE;
 8002162:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 8002164:	2220      	movs	r2, #32
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
      {
        hi2c->PreviousState = I2C_STATE_NONE;
 8002166:	632b      	str	r3, [r5, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;
        
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002168:	f885 303c 	strb.w	r3, [r5, #60]	; 0x3c
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
      {
        hi2c->PreviousState = I2C_STATE_NONE;
        hi2c->State= HAL_I2C_STATE_READY;
 800216c:	f885 203d 	strb.w	r2, [r5, #61]	; 0x3d
        
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        
        return HAL_TIMEOUT;
 8002170:	2003      	movs	r0, #3
 8002172:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  while((__HAL_I2C_GET_FLAG(hi2c, Flag) ? SET : RESET) == Status) 
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 8002176:	f7ff fca7 	bl	8001ac8 <HAL_GetTick>
 800217a:	1b00      	subs	r0, r0, r4
 800217c:	4287      	cmp	r7, r0
 800217e:	d2df      	bcs.n	8002140 <I2C_WaitOnFlagUntilTimeout+0x12>
 8002180:	e7ef      	b.n	8002162 <I2C_WaitOnFlagUntilTimeout+0x34>
        return HAL_TIMEOUT;
      }
    }
  }
  
  return HAL_OK;
 8002182:	2000      	movs	r0, #0
}
 8002184:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

08002188 <I2C_WaitOnMasterAddressFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnMasterAddressFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Flag, uint32_t Timeout, uint32_t Tickstart)
{
 8002188:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800218c:	4604      	mov	r4, r0
 800218e:	460e      	mov	r6, r1
 8002190:	4617      	mov	r7, r2
 8002192:	4699      	mov	r9, r3
  while(__HAL_I2C_GET_FLAG(hi2c, Flag) == RESET)
 8002194:	f3c1 4807 	ubfx	r8, r1, #16, #8
 8002198:	6825      	ldr	r5, [r4, #0]
 800219a:	f1b8 0f01 	cmp.w	r8, #1
 800219e:	bf0c      	ite	eq
 80021a0:	6968      	ldreq	r0, [r5, #20]
 80021a2:	69a8      	ldrne	r0, [r5, #24]
 80021a4:	43c0      	mvns	r0, r0
 80021a6:	b280      	uxth	r0, r0
 80021a8:	4230      	tst	r0, r6
 80021aa:	bf14      	ite	ne
 80021ac:	2001      	movne	r0, #1
 80021ae:	2000      	moveq	r0, #0
 80021b0:	b348      	cbz	r0, 8002206 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x7e>
  {
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 80021b2:	696b      	ldr	r3, [r5, #20]
 80021b4:	055a      	lsls	r2, r3, #21
 80021b6:	d512      	bpl.n	80021de <I2C_WaitOnMasterAddressFlagUntilTimeout+0x56>
    {
      /* Generate Stop */
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80021b8:	682b      	ldr	r3, [r5, #0]
 80021ba:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80021be:	602b      	str	r3, [r5, #0]

      /* Clear AF Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 80021c0:	f46f 6380 	mvn.w	r3, #1024	; 0x400
 80021c4:	616b      	str	r3, [r5, #20]

      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
 80021c6:	2304      	movs	r3, #4
 80021c8:	6423      	str	r3, [r4, #64]	; 0x40
      hi2c->PreviousState = I2C_STATE_NONE;
      hi2c->State= HAL_I2C_STATE_READY;
 80021ca:	2220      	movs	r2, #32

      /* Clear AF Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
      hi2c->PreviousState = I2C_STATE_NONE;
 80021cc:	2300      	movs	r3, #0
 80021ce:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 80021d0:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
      /* Clear AF Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);

      hi2c->ErrorCode = HAL_I2C_ERROR_AF;
      hi2c->PreviousState = I2C_STATE_NONE;
      hi2c->State= HAL_I2C_STATE_READY;
 80021d4:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
 80021d8:	2001      	movs	r0, #1
 80021da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80021de:	1c7b      	adds	r3, r7, #1
 80021e0:	d0da      	beq.n	8002198 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x10>
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 80021e2:	b94f      	cbnz	r7, 80021f8 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x70>
      {
        hi2c->PreviousState = I2C_STATE_NONE;
 80021e4:	2300      	movs	r3, #0
        hi2c->State= HAL_I2C_STATE_READY;
 80021e6:	2220      	movs	r2, #32
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
      {
        hi2c->PreviousState = I2C_STATE_NONE;
 80021e8:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80021ea:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
      {
        hi2c->PreviousState = I2C_STATE_NONE;
        hi2c->State= HAL_I2C_STATE_READY;
 80021ee:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);

        return HAL_TIMEOUT;
 80021f2:	2003      	movs	r0, #3
 80021f4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - Tickstart ) > Timeout))
 80021f8:	f7ff fc66 	bl	8001ac8 <HAL_GetTick>
 80021fc:	ebc9 0000 	rsb	r0, r9, r0
 8002200:	4287      	cmp	r7, r0
 8002202:	d2c9      	bcs.n	8002198 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x10>
 8002204:	e7ee      	b.n	80021e4 <I2C_WaitOnMasterAddressFlagUntilTimeout+0x5c>
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
}
 8002206:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0800220a <I2C_WaitOnBTFFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnBTFFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{  
 800220a:	b570      	push	{r4, r5, r6, lr}
 800220c:	4604      	mov	r4, r0
 800220e:	460d      	mov	r5, r1
 8002210:	4616      	mov	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
 8002212:	6823      	ldr	r3, [r4, #0]
 8002214:	695b      	ldr	r3, [r3, #20]
 8002216:	075b      	lsls	r3, r3, #29
 8002218:	d419      	bmi.n	800224e <I2C_WaitOnBTFFlagUntilTimeout+0x44>
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 800221a:	4620      	mov	r0, r4
 800221c:	f7ff ff72 	bl	8002104 <I2C_IsAcknowledgeFailed>
 8002220:	b9b8      	cbnz	r0, 8002252 <I2C_WaitOnBTFFlagUntilTimeout+0x48>
    {
      return HAL_ERROR;
    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8002222:	1c6a      	adds	r2, r5, #1
 8002224:	d0f5      	beq.n	8002212 <I2C_WaitOnBTFFlagUntilTimeout+0x8>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8002226:	b965      	cbnz	r5, 8002242 <I2C_WaitOnBTFFlagUntilTimeout+0x38>
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002228:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800222a:	f043 0320 	orr.w	r3, r3, #32
 800222e:	6423      	str	r3, [r4, #64]	; 0x40
        hi2c->PreviousState = I2C_STATE_NONE;
        hi2c->State= HAL_I2C_STATE_READY;
 8002230:	2220      	movs	r2, #32
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
        hi2c->PreviousState = I2C_STATE_NONE;
 8002232:	2300      	movs	r3, #0
 8002234:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002236:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
        hi2c->PreviousState = I2C_STATE_NONE;
        hi2c->State= HAL_I2C_STATE_READY;
 800223a:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 800223e:	2003      	movs	r0, #3
 8002240:	bd70      	pop	{r4, r5, r6, pc}
    }

    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8002242:	f7ff fc41 	bl	8001ac8 <HAL_GetTick>
 8002246:	1b80      	subs	r0, r0, r6
 8002248:	4285      	cmp	r5, r0
 800224a:	d2e2      	bcs.n	8002212 <I2C_WaitOnBTFFlagUntilTimeout+0x8>
 800224c:	e7ec      	b.n	8002228 <I2C_WaitOnBTFFlagUntilTimeout+0x1e>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 800224e:	2000      	movs	r0, #0
 8002250:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == RESET)
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
    {
      return HAL_ERROR;
 8002252:	2001      	movs	r0, #1
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
}
 8002254:	bd70      	pop	{r4, r5, r6, pc}

08002256 <I2C_WaitOnRXNEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnRXNEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{  
 8002256:	b570      	push	{r4, r5, r6, lr}
 8002258:	4604      	mov	r4, r0
 800225a:	460d      	mov	r5, r1
 800225c:	4616      	mov	r6, r2

  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 800225e:	6820      	ldr	r0, [r4, #0]
 8002260:	6943      	ldr	r3, [r0, #20]
 8002262:	f013 0340 	ands.w	r3, r3, #64	; 0x40
 8002266:	d121      	bne.n	80022ac <I2C_WaitOnRXNEFlagUntilTimeout+0x56>
  {
    /* Check if a STOPF is detected */
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8002268:	6942      	ldr	r2, [r0, #20]
 800226a:	06d2      	lsls	r2, r2, #27
 800226c:	d50b      	bpl.n	8002286 <I2C_WaitOnRXNEFlagUntilTimeout+0x30>
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800226e:	f06f 0210 	mvn.w	r2, #16
 8002272:	6142      	str	r2, [r0, #20]

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      hi2c->PreviousState = I2C_STATE_NONE;
      hi2c->State= HAL_I2C_STATE_READY;
 8002274:	2220      	movs	r2, #32
    if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002276:	6423      	str	r3, [r4, #64]	; 0x40
      hi2c->PreviousState = I2C_STATE_NONE;
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8002278:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    {
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      hi2c->PreviousState = I2C_STATE_NONE;
 800227c:	6323      	str	r3, [r4, #48]	; 0x30
      hi2c->State= HAL_I2C_STATE_READY;

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
 800227e:	2001      	movs	r0, #1
      /* Clear STOP Flag */
      __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);

      hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
      hi2c->PreviousState = I2C_STATE_NONE;
      hi2c->State= HAL_I2C_STATE_READY;
 8002280:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);

      return HAL_ERROR;
 8002284:	bd70      	pop	{r4, r5, r6, pc}
    }

    /* Check for the Timeout */
    if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 8002286:	b95d      	cbnz	r5, 80022a0 <I2C_WaitOnRXNEFlagUntilTimeout+0x4a>
    {
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002288:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800228a:	f043 0320 	orr.w	r3, r3, #32
 800228e:	6423      	str	r3, [r4, #64]	; 0x40
      hi2c->State= HAL_I2C_STATE_READY;
 8002290:	2320      	movs	r3, #32
 8002292:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

      /* Process Unlocked */
      __HAL_UNLOCK(hi2c);
 8002296:	2300      	movs	r3, #0
 8002298:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
 800229c:	2003      	movs	r0, #3
 800229e:	bd70      	pop	{r4, r5, r6, pc}

      return HAL_ERROR;
    }

    /* Check for the Timeout */
    if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80022a0:	f7ff fc12 	bl	8001ac8 <HAL_GetTick>
 80022a4:	1b80      	subs	r0, r0, r6
 80022a6:	4285      	cmp	r5, r0
 80022a8:	d2d9      	bcs.n	800225e <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
 80022aa:	e7ed      	b.n	8002288 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
      __HAL_UNLOCK(hi2c);

      return HAL_TIMEOUT;
    }
  }
  return HAL_OK;
 80022ac:	2000      	movs	r0, #0
}
 80022ae:	bd70      	pop	{r4, r5, r6, pc}

080022b0 <I2C_WaitOnTXEFlagUntilTimeout>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_WaitOnTXEFlagUntilTimeout(I2C_HandleTypeDef *hi2c, uint32_t Timeout, uint32_t Tickstart)
{    
 80022b0:	b570      	push	{r4, r5, r6, lr}
 80022b2:	4604      	mov	r4, r0
 80022b4:	460d      	mov	r5, r1
 80022b6:	4616      	mov	r6, r2
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80022b8:	6823      	ldr	r3, [r4, #0]
 80022ba:	695b      	ldr	r3, [r3, #20]
 80022bc:	061b      	lsls	r3, r3, #24
 80022be:	d419      	bmi.n	80022f4 <I2C_WaitOnTXEFlagUntilTimeout+0x44>
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
 80022c0:	4620      	mov	r0, r4
 80022c2:	f7ff ff1f 	bl	8002104 <I2C_IsAcknowledgeFailed>
 80022c6:	b9b8      	cbnz	r0, 80022f8 <I2C_WaitOnTXEFlagUntilTimeout+0x48>
    {
      return HAL_ERROR;
    }
		
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 80022c8:	1c6a      	adds	r2, r5, #1
 80022ca:	d0f5      	beq.n	80022b8 <I2C_WaitOnTXEFlagUntilTimeout+0x8>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80022cc:	b965      	cbnz	r5, 80022e8 <I2C_WaitOnTXEFlagUntilTimeout+0x38>
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80022ce:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80022d0:	f043 0320 	orr.w	r3, r3, #32
 80022d4:	6423      	str	r3, [r4, #64]	; 0x40
        hi2c->PreviousState = I2C_STATE_NONE;
        hi2c->State= HAL_I2C_STATE_READY;
 80022d6:	2220      	movs	r2, #32
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
        hi2c->PreviousState = I2C_STATE_NONE;
 80022d8:	2300      	movs	r3, #0
 80022da:	6323      	str	r3, [r4, #48]	; 0x30
        hi2c->State= HAL_I2C_STATE_READY;

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80022dc:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
      {
        hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
        hi2c->PreviousState = I2C_STATE_NONE;
        hi2c->State= HAL_I2C_STATE_READY;
 80022e0:	f884 203d 	strb.w	r2, [r4, #61]	; 0x3d

        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 80022e4:	2003      	movs	r0, #3
 80022e6:	bd70      	pop	{r4, r5, r6, pc}
    }
		
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) > Timeout))
 80022e8:	f7ff fbee 	bl	8001ac8 <HAL_GetTick>
 80022ec:	1b80      	subs	r0, r0, r6
 80022ee:	4285      	cmp	r5, r0
 80022f0:	d2e2      	bcs.n	80022b8 <I2C_WaitOnTXEFlagUntilTimeout+0x8>
 80022f2:	e7ec      	b.n	80022ce <I2C_WaitOnTXEFlagUntilTimeout+0x1e>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;      
 80022f4:	2000      	movs	r0, #0
 80022f6:	bd70      	pop	{r4, r5, r6, pc}
  while(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
  {
    /* Check if a NACK is detected */
    if(I2C_IsAcknowledgeFailed(hi2c) != HAL_OK)
    {
      return HAL_ERROR;
 80022f8:	2001      	movs	r0, #1
        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;      
}
 80022fa:	bd70      	pop	{r4, r5, r6, pc}

080022fc <I2C_RequestMemoryWrite>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80022fc:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8002300:	4615      	mov	r5, r2
  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8002302:	6802      	ldr	r2, [r0, #0]
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 8002304:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
 8002306:	4698      	mov	r8, r3
  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8002308:	6813      	ldr	r3, [r2, #0]
 800230a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800230e:	6013      	str	r3, [r2, #0]
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 8002310:	460f      	mov	r7, r1
  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;

  /* Wait until SB flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 8002312:	9600      	str	r6, [sp, #0]
 8002314:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002316:	2200      	movs	r2, #0
 8002318:	f04f 1101 	mov.w	r1, #65537	; 0x10001
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryWrite(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800231c:	4604      	mov	r4, r0
  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;

  /* Wait until SB flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 800231e:	f7ff ff06 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 8002322:	b968      	cbnz	r0, 8002340 <I2C_RequestMemoryWrite+0x44>
  {
    return HAL_TIMEOUT;
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 8002324:	6823      	ldr	r3, [r4, #0]

  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 8002326:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8002328:	491b      	ldr	r1, [pc, #108]	; (8002398 <I2C_RequestMemoryWrite+0x9c>)
  {
    return HAL_TIMEOUT;
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 800232a:	f007 07fe 	and.w	r7, r7, #254	; 0xfe
 800232e:	611f      	str	r7, [r3, #16]

  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 8002330:	4620      	mov	r0, r4
 8002332:	4633      	mov	r3, r6
 8002334:	f7ff ff28 	bl	8002188 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 8002338:	b120      	cbz	r0, 8002344 <I2C_RequestMemoryWrite+0x48>
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800233a:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800233c:	2b04      	cmp	r3, #4
 800233e:	d027      	beq.n	8002390 <I2C_RequestMemoryWrite+0x94>
    {
      return HAL_ERROR;
    }
    else
    {
      return HAL_TIMEOUT;
 8002340:	2003      	movs	r0, #3
 8002342:	e026      	b.n	8002392 <I2C_RequestMemoryWrite+0x96>
    }
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002344:	6823      	ldr	r3, [r4, #0]
 8002346:	9003      	str	r0, [sp, #12]
 8002348:	695a      	ldr	r2, [r3, #20]
 800234a:	9203      	str	r2, [sp, #12]
 800234c:	699b      	ldr	r3, [r3, #24]
 800234e:	9303      	str	r3, [sp, #12]

  /* Wait until TXE flag is set */
  if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002350:	4632      	mov	r2, r6
 8002352:	990a      	ldr	r1, [sp, #40]	; 0x28
      return HAL_TIMEOUT;
    }
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002354:	9b03      	ldr	r3, [sp, #12]

  /* Wait until TXE flag is set */
  if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002356:	4620      	mov	r0, r4
 8002358:	f7ff ffaa 	bl	80022b0 <I2C_WaitOnTXEFlagUntilTimeout>
 800235c:	b958      	cbnz	r0, 8002376 <I2C_RequestMemoryWrite+0x7a>
      return HAL_TIMEOUT;
    }
  }

  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 800235e:	f1b8 0f01 	cmp.w	r8, #1
 8002362:	6823      	ldr	r3, [r4, #0]
 8002364:	d011      	beq.n	800238a <I2C_RequestMemoryWrite+0x8e>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 8002366:	0a2a      	lsrs	r2, r5, #8
 8002368:	611a      	str	r2, [r3, #16]

    /* Wait until TXE flag is set */
    if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800236a:	990a      	ldr	r1, [sp, #40]	; 0x28
 800236c:	4632      	mov	r2, r6
 800236e:	4620      	mov	r0, r4
 8002370:	f7ff ff9e 	bl	80022b0 <I2C_WaitOnTXEFlagUntilTimeout>
 8002374:	b140      	cbz	r0, 8002388 <I2C_RequestMemoryWrite+0x8c>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002376:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002378:	2b04      	cmp	r3, #4
 800237a:	d1e1      	bne.n	8002340 <I2C_RequestMemoryWrite+0x44>
      {
        /* Generate Stop */
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800237c:	6822      	ldr	r2, [r4, #0]
 800237e:	6813      	ldr	r3, [r2, #0]
 8002380:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002384:	6013      	str	r3, [r2, #0]
 8002386:	e003      	b.n	8002390 <I2C_RequestMemoryWrite+0x94>
        return HAL_TIMEOUT;
      }
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 8002388:	6823      	ldr	r3, [r4, #0]
 800238a:	b2ed      	uxtb	r5, r5
 800238c:	611d      	str	r5, [r3, #16]
 800238e:	e000      	b.n	8002392 <I2C_RequestMemoryWrite+0x96>
  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
    {
      return HAL_ERROR;
 8002390:	2001      	movs	r0, #1
    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
  }

  return HAL_OK;
}
 8002392:	b004      	add	sp, #16
 8002394:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002398:	00010002 	.word	0x00010002

0800239c <I2C_RequestMemoryRead>:
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 800239c:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80023a0:	4698      	mov	r8, r3
  /* Enable Acknowledge */
  hi2c->Instance->CR1 |= I2C_CR1_ACK;
 80023a2:	6803      	ldr	r3, [r0, #0]
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80023a4:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
 80023a6:	4616      	mov	r6, r2
  /* Enable Acknowledge */
  hi2c->Instance->CR1 |= I2C_CR1_ACK;
 80023a8:	681a      	ldr	r2, [r3, #0]
 80023aa:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80023ae:	601a      	str	r2, [r3, #0]

  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;
 80023b0:	681a      	ldr	r2, [r3, #0]
 80023b2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80023b6:	601a      	str	r2, [r3, #0]
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80023b8:	460f      	mov	r7, r1

  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;

  /* Wait until SB flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 80023ba:	9500      	str	r5, [sp, #0]
 80023bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80023be:	2200      	movs	r2, #0
 80023c0:	f04f 1101 	mov.w	r1, #65537	; 0x10001
  * @param  Timeout Timeout duration
  * @param  Tickstart Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef I2C_RequestMemoryRead(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint32_t Timeout, uint32_t Tickstart)
{
 80023c4:	4604      	mov	r4, r0

  /* Generate Start */
  hi2c->Instance->CR1 |= I2C_CR1_START;

  /* Wait until SB flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 80023c6:	f7ff feb2 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 80023ca:	2800      	cmp	r0, #0
 80023cc:	d136      	bne.n	800243c <I2C_RequestMemoryRead+0xa0>
  {
    return HAL_TIMEOUT;
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 80023ce:	6823      	ldr	r3, [r4, #0]

  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 80023d0:	492d      	ldr	r1, [pc, #180]	; (8002488 <I2C_RequestMemoryRead+0xec>)
  {
    return HAL_TIMEOUT;
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_WRITE(DevAddress);
 80023d2:	b2ff      	uxtb	r7, r7
 80023d4:	f007 02fe 	and.w	r2, r7, #254	; 0xfe
 80023d8:	611a      	str	r2, [r3, #16]

  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 80023da:	4620      	mov	r0, r4
 80023dc:	462b      	mov	r3, r5
 80023de:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 80023e0:	f7ff fed2 	bl	8002188 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 80023e4:	b118      	cbz	r0, 80023ee <I2C_RequestMemoryRead+0x52>
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 80023e6:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80023e8:	2b04      	cmp	r3, #4
 80023ea:	d127      	bne.n	800243c <I2C_RequestMemoryRead+0xa0>
 80023ec:	e030      	b.n	8002450 <I2C_RequestMemoryRead+0xb4>
      return HAL_TIMEOUT;
    }
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80023ee:	6823      	ldr	r3, [r4, #0]
 80023f0:	9003      	str	r0, [sp, #12]
 80023f2:	695a      	ldr	r2, [r3, #20]
 80023f4:	9203      	str	r2, [sp, #12]
 80023f6:	699b      	ldr	r3, [r3, #24]
 80023f8:	9303      	str	r3, [sp, #12]

  /* Wait until TXE flag is set */
  if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 80023fa:	462a      	mov	r2, r5
 80023fc:	990a      	ldr	r1, [sp, #40]	; 0x28
      return HAL_TIMEOUT;
    }
  }

  /* Clear ADDR flag */
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 80023fe:	9b03      	ldr	r3, [sp, #12]

  /* Wait until TXE flag is set */
  if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002400:	4620      	mov	r0, r4
 8002402:	f7ff ff55 	bl	80022b0 <I2C_WaitOnTXEFlagUntilTimeout>
 8002406:	b9d8      	cbnz	r0, 8002440 <I2C_RequestMemoryRead+0xa4>
      return HAL_TIMEOUT;
    }
  }

  /* If Memory address size is 8Bit */
  if(MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8002408:	f1b8 0f01 	cmp.w	r8, #1
 800240c:	6823      	ldr	r3, [r4, #0]
 800240e:	d121      	bne.n	8002454 <I2C_RequestMemoryRead+0xb8>
        return HAL_TIMEOUT;
      }
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 8002410:	b2f6      	uxtb	r6, r6
 8002412:	611e      	str	r6, [r3, #16]
  }

  /* Wait until TXE flag is set */
  if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002414:	462a      	mov	r2, r5
 8002416:	990a      	ldr	r1, [sp, #40]	; 0x28
 8002418:	4620      	mov	r0, r4
 800241a:	f7ff ff49 	bl	80022b0 <I2C_WaitOnTXEFlagUntilTimeout>
 800241e:	4602      	mov	r2, r0
 8002420:	b970      	cbnz	r0, 8002440 <I2C_RequestMemoryRead+0xa4>
      return HAL_TIMEOUT;
    }
  }

  /* Generate Restart */
  hi2c->Instance->CR1 |= I2C_CR1_START;
 8002422:	6821      	ldr	r1, [r4, #0]
 8002424:	680b      	ldr	r3, [r1, #0]
 8002426:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800242a:	600b      	str	r3, [r1, #0]

  /* Wait until SB flag is set */
  if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_SB, RESET, Timeout, Tickstart) != HAL_OK)
 800242c:	4620      	mov	r0, r4
 800242e:	9500      	str	r5, [sp, #0]
 8002430:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002432:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 8002436:	f7ff fe7a 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 800243a:	b1b0      	cbz	r0, 800246a <I2C_RequestMemoryRead+0xce>
    {
      return HAL_ERROR;
    }
    else
    {
      return HAL_TIMEOUT;
 800243c:	2003      	movs	r0, #3
 800243e:	e020      	b.n	8002482 <I2C_RequestMemoryRead+0xe6>
  __HAL_I2C_CLEAR_ADDRFLAG(hi2c);

  /* Wait until TXE flag is set */
  if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
  {
    if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002440:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002442:	2b04      	cmp	r3, #4
 8002444:	d1fa      	bne.n	800243c <I2C_RequestMemoryRead+0xa0>
    {
      /* Generate Stop */
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8002446:	6822      	ldr	r2, [r4, #0]
 8002448:	6813      	ldr	r3, [r2, #0]
 800244a:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 800244e:	6013      	str	r3, [r2, #0]
      return HAL_ERROR;
 8002450:	2001      	movs	r0, #1
 8002452:	e016      	b.n	8002482 <I2C_RequestMemoryRead+0xe6>
  }
  /* If Memory address size is 16Bit */
  else
  {
    /* Send MSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_MSB(MemAddress);
 8002454:	0a32      	lsrs	r2, r6, #8
 8002456:	611a      	str	r2, [r3, #16]

    /* Wait until TXE flag is set */
    if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002458:	990a      	ldr	r1, [sp, #40]	; 0x28
 800245a:	462a      	mov	r2, r5
 800245c:	4620      	mov	r0, r4
 800245e:	f7ff ff27 	bl	80022b0 <I2C_WaitOnTXEFlagUntilTimeout>
 8002462:	2800      	cmp	r0, #0
 8002464:	d1ec      	bne.n	8002440 <I2C_RequestMemoryRead+0xa4>
        return HAL_TIMEOUT;
      }
    }

    /* Send LSB of Memory Address */
    hi2c->Instance->DR = I2C_MEM_ADD_LSB(MemAddress);
 8002466:	6823      	ldr	r3, [r4, #0]
 8002468:	e7d2      	b.n	8002410 <I2C_RequestMemoryRead+0x74>
  {
    return HAL_TIMEOUT;
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
 800246a:	6823      	ldr	r3, [r4, #0]

  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 800246c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800246e:	4906      	ldr	r1, [pc, #24]	; (8002488 <I2C_RequestMemoryRead+0xec>)
  {
    return HAL_TIMEOUT;
  }

  /* Send slave address */
  hi2c->Instance->DR = I2C_7BIT_ADD_READ(DevAddress);
 8002470:	f047 0701 	orr.w	r7, r7, #1
 8002474:	611f      	str	r7, [r3, #16]

  /* Wait until ADDR flag is set */
  if(I2C_WaitOnMasterAddressFlagUntilTimeout(hi2c, I2C_FLAG_ADDR, Timeout, Tickstart) != HAL_OK)
 8002476:	4620      	mov	r0, r4
 8002478:	462b      	mov	r3, r5
 800247a:	f7ff fe85 	bl	8002188 <I2C_WaitOnMasterAddressFlagUntilTimeout>
 800247e:	2800      	cmp	r0, #0
 8002480:	d1b1      	bne.n	80023e6 <I2C_RequestMemoryRead+0x4a>
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
}
 8002482:	b004      	add	sp, #16
 8002484:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002488:	00010002 	.word	0x00010002

0800248c <HAL_I2C_Init>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Init(I2C_HandleTypeDef *hi2c)
{
 800248c:	b570      	push	{r4, r5, r6, lr}
  uint32_t freqrange = 0U;
  uint32_t pclk1 = 0U;

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 800248e:	4604      	mov	r4, r0
 8002490:	2800      	cmp	r0, #0
 8002492:	d063      	beq.n	800255c <HAL_I2C_Init+0xd0>
  assert_param(IS_I2C_DUAL_ADDRESS(hi2c->Init.DualAddressMode));
  assert_param(IS_I2C_OWN_ADDRESS2(hi2c->Init.OwnAddress2));
  assert_param(IS_I2C_GENERAL_CALL(hi2c->Init.GeneralCallMode));
  assert_param(IS_I2C_NO_STRETCH(hi2c->Init.NoStretchMode));

  if(hi2c->State == HAL_I2C_STATE_RESET)
 8002494:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8002498:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800249c:	b91b      	cbnz	r3, 80024a6 <HAL_I2C_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hi2c->Lock = HAL_UNLOCKED;
 800249e:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
 80024a2:	f7fe fb09 	bl	8000ab8 <HAL_I2C_MspInit>
  }

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80024a6:	6822      	ldr	r2, [r4, #0]
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80024a8:	4d2d      	ldr	r5, [pc, #180]	; (8002560 <HAL_I2C_Init+0xd4>)
    hi2c->Lock = HAL_UNLOCKED;
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_I2C_MspInit(hi2c);
  }

  hi2c->State = HAL_I2C_STATE_BUSY;
 80024aa:	2324      	movs	r3, #36	; 0x24
 80024ac:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d

  /* Disable the selected I2C peripheral */
  __HAL_I2C_DISABLE(hi2c);
 80024b0:	6813      	ldr	r3, [r2, #0]
 80024b2:	f023 0301 	bic.w	r3, r3, #1
 80024b6:	6013      	str	r3, [r2, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();
 80024b8:	f000 ff08 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80024bc:	6863      	ldr	r3, [r4, #4]
  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;
 80024be:	6822      	ldr	r2, [r4, #0]

  /* Get PCLK1 frequency */
  pclk1 = HAL_RCC_GetPCLK1Freq();

  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);
 80024c0:	4928      	ldr	r1, [pc, #160]	; (8002564 <HAL_I2C_Init+0xd8>)
 80024c2:	fbb0 f1f1 	udiv	r1, r0, r1
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80024c6:	42ab      	cmp	r3, r5
 80024c8:	462e      	mov	r6, r5
 80024ca:	bf88      	it	hi
 80024cc:	f44f 7596 	movhi.w	r5, #300	; 0x12c
  /* Calculate frequency range */
  freqrange = I2C_FREQRANGE(pclk1);

  /*---------------------------- I2Cx CR2 Configuration ----------------------*/
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;
 80024d0:	6051      	str	r1, [r2, #4]

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80024d2:	bf82      	ittt	hi
 80024d4:	4369      	mulhi	r1, r5
 80024d6:	f44f 757a 	movhi.w	r5, #1000	; 0x3e8
 80024da:	fbb1 f1f5 	udivhi	r1, r1, r5

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 80024de:	42b3      	cmp	r3, r6
  /* Configure I2Cx: Frequency range */
  hi2c->Instance->CR2 = freqrange;

  /*---------------------------- I2Cx TRISE Configuration --------------------*/
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);
 80024e0:	f101 0101 	add.w	r1, r1, #1
 80024e4:	6211      	str	r1, [r2, #32]

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 80024e6:	d808      	bhi.n	80024fa <HAL_I2C_Init+0x6e>
 80024e8:	005b      	lsls	r3, r3, #1
 80024ea:	fbb0 f0f3 	udiv	r0, r0, r3
 80024ee:	f3c0 030b 	ubfx	r3, r0, #0, #12
 80024f2:	2b03      	cmp	r3, #3
 80024f4:	bf98      	it	ls
 80024f6:	2004      	movls	r0, #4
 80024f8:	e016      	b.n	8002528 <HAL_I2C_Init+0x9c>
 80024fa:	68a1      	ldr	r1, [r4, #8]
 80024fc:	b949      	cbnz	r1, 8002512 <HAL_I2C_Init+0x86>
 80024fe:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 8002502:	fbb0 f0f3 	udiv	r0, r0, r3
 8002506:	f3c0 030b 	ubfx	r3, r0, #0, #12
 800250a:	b163      	cbz	r3, 8002526 <HAL_I2C_Init+0x9a>
 800250c:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
 8002510:	e00a      	b.n	8002528 <HAL_I2C_Init+0x9c>
 8002512:	2119      	movs	r1, #25
 8002514:	434b      	muls	r3, r1
 8002516:	fbb0 f0f3 	udiv	r0, r0, r3
 800251a:	f3c0 030b 	ubfx	r3, r0, #0, #12
 800251e:	b113      	cbz	r3, 8002526 <HAL_I2C_Init+0x9a>
 8002520:	f440 4040 	orr.w	r0, r0, #49152	; 0xc000
 8002524:	e000      	b.n	8002528 <HAL_I2C_Init+0x9c>
 8002526:	2001      	movs	r0, #1

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8002528:	69e1      	ldr	r1, [r4, #28]
 800252a:	6a23      	ldr	r3, [r4, #32]
  /* Configure I2Cx: Rise Time */
  hi2c->Instance->TRISE = I2C_RISE_TIME(freqrange, hi2c->Init.ClockSpeed);

  /*---------------------------- I2Cx CCR Configuration ----------------------*/
  /* Configure I2Cx: Speed */
  hi2c->Instance->CCR = I2C_SPEED(pclk1, hi2c->Init.ClockSpeed, hi2c->Init.DutyCycle);
 800252c:	61d0      	str	r0, [r2, #28]

  /*---------------------------- I2Cx CR1 Configuration ----------------------*/
  /* Configure I2Cx: Generalcall and NoStretch mode */
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 800252e:	430b      	orrs	r3, r1
 8002530:	6013      	str	r3, [r2, #0]

  /*---------------------------- I2Cx OAR1 Configuration ---------------------*/
  /* Configure I2Cx: Own Address1 and addressing mode */
  hi2c->Instance->OAR1 = (hi2c->Init.AddressingMode | hi2c->Init.OwnAddress1);
 8002532:	6921      	ldr	r1, [r4, #16]
 8002534:	68e3      	ldr	r3, [r4, #12]
 8002536:	430b      	orrs	r3, r1
 8002538:	6093      	str	r3, [r2, #8]

  /*---------------------------- I2Cx OAR2 Configuration ---------------------*/
  /* Configure I2Cx: Dual mode and Own Address2 */
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);
 800253a:	6961      	ldr	r1, [r4, #20]
 800253c:	69a3      	ldr	r3, [r4, #24]
 800253e:	430b      	orrs	r3, r1
 8002540:	60d3      	str	r3, [r2, #12]

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);
 8002542:	6813      	ldr	r3, [r2, #0]
 8002544:	f043 0301 	orr.w	r3, r3, #1
 8002548:	6013      	str	r3, [r2, #0]

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800254a:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 800254c:	2320      	movs	r3, #32
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2);

  /* Enable the selected I2C peripheral */
  __HAL_I2C_ENABLE(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800254e:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_READY;
 8002550:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 8002554:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8002556:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e

  return HAL_OK;
 800255a:	bd70      	pop	{r4, r5, r6, pc}
  uint32_t pclk1 = 0U;

  /* Check the I2C handle allocation */
  if(hi2c == NULL)
  {
    return HAL_ERROR;
 800255c:	2001      	movs	r0, #1
  hi2c->State = HAL_I2C_STATE_READY;
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->Mode = HAL_I2C_MODE_NONE;

  return HAL_OK;
}
 800255e:	bd70      	pop	{r4, r5, r6, pc}
 8002560:	000186a0 	.word	0x000186a0
 8002564:	000f4240 	.word	0x000f4240

08002568 <HAL_I2C_DeInit>:
  * @param  hi2c Pointer to a I2C_HandleTypeDef structure that contains
  *         the configuration information for I2C module
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
 8002568:	b510      	push	{r4, lr}
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
 800256a:	4604      	mov	r4, r0
 800256c:	b198      	cbz	r0, 8002596 <HAL_I2C_DeInit+0x2e>
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 800256e:	6802      	ldr	r2, [r0, #0]
  }

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));

  hi2c->State = HAL_I2C_STATE_BUSY;
 8002570:	2324      	movs	r3, #36	; 0x24
 8002572:	f880 303d 	strb.w	r3, [r0, #61]	; 0x3d

  /* Disable the I2C Peripheral Clock */
  __HAL_I2C_DISABLE(hi2c);
 8002576:	6813      	ldr	r3, [r2, #0]
 8002578:	f023 0301 	bic.w	r3, r3, #1
 800257c:	6013      	str	r3, [r2, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);
 800257e:	f7fe fad3 	bl	8000b28 <HAL_I2C_MspDeInit>

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002582:	2000      	movs	r0, #0
 8002584:	6420      	str	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
  hi2c->PreviousState = I2C_STATE_NONE;
  hi2c->Mode = HAL_I2C_MODE_NONE;
    
  /* Release Lock */
  __HAL_UNLOCK(hi2c);
 8002586:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
  HAL_I2C_MspDeInit(hi2c);

  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
  hi2c->State = HAL_I2C_STATE_RESET;
 800258a:	f884 003d 	strb.w	r0, [r4, #61]	; 0x3d
  hi2c->PreviousState = I2C_STATE_NONE;
 800258e:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8002590:	f884 003e 	strb.w	r0, [r4, #62]	; 0x3e
    
  /* Release Lock */
  __HAL_UNLOCK(hi2c);

  return HAL_OK;
 8002594:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_I2C_DeInit(I2C_HandleTypeDef *hi2c)
{
  /* Check the I2C handle allocation */
  if(hi2c == NULL)
  {
    return HAL_ERROR;
 8002596:	2001      	movs	r0, #1
    
  /* Release Lock */
  __HAL_UNLOCK(hi2c);

  return HAL_OK;
}
 8002598:	bd10      	pop	{r4, pc}
	...

0800259c <HAL_I2C_Mem_Write>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800259c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80025a0:	4604      	mov	r4, r0
 80025a2:	b085      	sub	sp, #20
 80025a4:	469b      	mov	fp, r3
 80025a6:	9103      	str	r1, [sp, #12]
 80025a8:	4692      	mov	sl, r2
 80025aa:	9f0e      	ldr	r7, [sp, #56]	; 0x38
 80025ac:	f8bd 603c 	ldrh.w	r6, [sp, #60]	; 0x3c
  uint32_t tickstart = 0x00U;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80025b0:	f7ff fa8a 	bl	8001ac8 <HAL_GetTick>
  
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
 80025b4:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80025b8:	2b20      	cmp	r3, #32
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  uint32_t tickstart = 0x00U;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80025ba:	4680      	mov	r8, r0
  
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
 80025bc:	d001      	beq.n	80025c2 <HAL_I2C_Mem_Write+0x26>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 80025be:	2002      	movs	r0, #2
 80025c0:	e069      	b.n	8002696 <HAL_I2C_Mem_Write+0xfa>
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    /* Wait until BUSY flag is reset */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 80025c2:	9000      	str	r0, [sp, #0]
 80025c4:	2319      	movs	r3, #25
 80025c6:	2201      	movs	r2, #1
 80025c8:	4934      	ldr	r1, [pc, #208]	; (800269c <HAL_I2C_Mem_Write+0x100>)
 80025ca:	4620      	mov	r0, r4
 80025cc:	f7ff fdaf 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 80025d0:	4681      	mov	r9, r0
 80025d2:	2800      	cmp	r0, #0
 80025d4:	d1f3      	bne.n	80025be <HAL_I2C_Mem_Write+0x22>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80025d6:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80025da:	2b01      	cmp	r3, #1
 80025dc:	d0ef      	beq.n	80025be <HAL_I2C_Mem_Write+0x22>
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80025de:	6822      	ldr	r2, [r4, #0]
    hi2c->Mode = HAL_I2C_MODE_MEM;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80025e0:	9903      	ldr	r1, [sp, #12]

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80025e2:	6813      	ldr	r3, [r2, #0]
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80025e4:	2501      	movs	r5, #1
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80025e6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80025ea:	f884 503c 	strb.w	r5, [r4, #60]	; 0x3c
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80025ee:	6013      	str	r3, [r2, #0]

    hi2c->State = HAL_I2C_STATE_BUSY_TX;
 80025f0:	2321      	movs	r3, #33	; 0x21
 80025f2:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_MEM;
 80025f6:	2340      	movs	r3, #64	; 0x40
 80025f8:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 80025fc:	4b28      	ldr	r3, [pc, #160]	; (80026a0 <HAL_I2C_Mem_Write+0x104>)
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;

    hi2c->State = HAL_I2C_STATE_BUSY_TX;
    hi2c->Mode = HAL_I2C_MODE_MEM;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80025fe:	6420      	str	r0, [r4, #64]	; 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8002600:	62e3      	str	r3, [r4, #44]	; 0x2c
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8002602:	9b10      	ldr	r3, [sp, #64]	; 0x40
 8002604:	9300      	str	r3, [sp, #0]
 8002606:	f8cd 8004 	str.w	r8, [sp, #4]
 800260a:	465b      	mov	r3, fp
 800260c:	4652      	mov	r2, sl
 800260e:	4620      	mov	r0, r4
 8002610:	f7ff fe74 	bl	80022fc <I2C_RequestMemoryWrite>
 8002614:	b1b8      	cbz	r0, 8002646 <HAL_I2C_Mem_Write+0xaa>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002616:	6c23      	ldr	r3, [r4, #64]	; 0x40
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002618:	f884 903c 	strb.w	r9, [r4, #60]	; 0x3c
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryWrite(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800261c:	2b04      	cmp	r3, #4
 800261e:	d101      	bne.n	8002624 <HAL_I2C_Mem_Write+0x88>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        return HAL_ERROR;
 8002620:	4628      	mov	r0, r5
 8002622:	e038      	b.n	8002696 <HAL_I2C_Mem_Write+0xfa>
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
          return HAL_ERROR;
        }
        else
        {
          return HAL_TIMEOUT;
 8002624:	2003      	movs	r0, #3
 8002626:	e036      	b.n	8002696 <HAL_I2C_Mem_Write+0xfa>
    }

    while(Size > 0U)
    {
      /* Wait until TXE flag is set */
      if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002628:	f7ff fe42 	bl	80022b0 <I2C_WaitOnTXEFlagUntilTimeout>
 800262c:	b988      	cbnz	r0, 8002652 <HAL_I2C_Mem_Write+0xb6>
          return HAL_TIMEOUT;
        }
      }

      /* Write data to DR */
      hi2c->Instance->DR = (*pData++);
 800262e:	6822      	ldr	r2, [r4, #0]
 8002630:	783b      	ldrb	r3, [r7, #0]
 8002632:	6113      	str	r3, [r2, #16]
      Size--;

      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 8002634:	6950      	ldr	r0, [r2, #20]
        }
      }

      /* Write data to DR */
      hi2c->Instance->DR = (*pData++);
      Size--;
 8002636:	1e73      	subs	r3, r6, #1

      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 8002638:	0740      	lsls	r0, r0, #29
          return HAL_TIMEOUT;
        }
      }

      /* Write data to DR */
      hi2c->Instance->DR = (*pData++);
 800263a:	f107 0101 	add.w	r1, r7, #1
      Size--;
 800263e:	b29b      	uxth	r3, r3

      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 8002640:	d411      	bmi.n	8002666 <HAL_I2C_Mem_Write+0xca>
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Write(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8002642:	461e      	mov	r6, r3
 8002644:	460f      	mov	r7, r1
    }

    while(Size > 0U)
    {
      /* Wait until TXE flag is set */
      if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002646:	4642      	mov	r2, r8
 8002648:	9910      	ldr	r1, [sp, #64]	; 0x40
 800264a:	4620      	mov	r0, r4
        __HAL_UNLOCK(hi2c);
        return HAL_TIMEOUT;
      }
    }

    while(Size > 0U)
 800264c:	2e00      	cmp	r6, #0
 800264e:	d1eb      	bne.n	8002628 <HAL_I2C_Mem_Write+0x8c>
 8002650:	e011      	b.n	8002676 <HAL_I2C_Mem_Write+0xda>
    {
      /* Wait until TXE flag is set */
      if(I2C_WaitOnTXEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
      {
        if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002652:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8002654:	2b04      	cmp	r3, #4
 8002656:	d1e5      	bne.n	8002624 <HAL_I2C_Mem_Write+0x88>
    if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
      {
        /* Generate Stop */
        hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8002658:	6822      	ldr	r2, [r4, #0]
 800265a:	6813      	ldr	r3, [r2, #0]
 800265c:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002660:	6013      	str	r3, [r2, #0]
        return HAL_ERROR;
 8002662:	2001      	movs	r0, #1
 8002664:	e017      	b.n	8002696 <HAL_I2C_Mem_Write+0xfa>

      /* Write data to DR */
      hi2c->Instance->DR = (*pData++);
      Size--;

      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
 8002666:	2b00      	cmp	r3, #0
 8002668:	d0eb      	beq.n	8002642 <HAL_I2C_Mem_Write+0xa6>
      {
        /* Write data to DR */
        hi2c->Instance->DR = (*pData++);
 800266a:	787b      	ldrb	r3, [r7, #1]
 800266c:	6113      	str	r3, [r2, #16]
        Size--;
 800266e:	3e02      	subs	r6, #2
      Size--;

      if((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET) && (Size != 0))
      {
        /* Write data to DR */
        hi2c->Instance->DR = (*pData++);
 8002670:	1cb9      	adds	r1, r7, #2
        Size--;
 8002672:	b2b3      	uxth	r3, r6
 8002674:	e7e5      	b.n	8002642 <HAL_I2C_Mem_Write+0xa6>
      }
    }
    
    /* Wait until BTF flag is set */
    if(I2C_WaitOnBTFFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002676:	f7ff fdc8 	bl	800220a <I2C_WaitOnBTFFlagUntilTimeout>
 800267a:	2800      	cmp	r0, #0
 800267c:	d1e9      	bne.n	8002652 <HAL_I2C_Mem_Write+0xb6>
        return HAL_TIMEOUT;
      }
    }

    /* Generate Stop */
    hi2c->Instance->CR1 |= I2C_CR1_STOP;
 800267e:	6822      	ldr	r2, [r4, #0]
 8002680:	6813      	ldr	r3, [r2, #0]
 8002682:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8002686:	6013      	str	r3, [r2, #0]

    hi2c->State = HAL_I2C_STATE_READY;
 8002688:	2320      	movs	r3, #32
 800268a:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800268e:	f884 603c 	strb.w	r6, [r4, #60]	; 0x3c

    /* Generate Stop */
    hi2c->Instance->CR1 |= I2C_CR1_STOP;

    hi2c->State = HAL_I2C_STATE_READY;
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002692:	f884 603e 	strb.w	r6, [r4, #62]	; 0x3e
  }
  else
  {
    return HAL_BUSY;
  }
}
 8002696:	b005      	add	sp, #20
 8002698:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800269c:	00100002 	.word	0x00100002
 80026a0:	ffff0000 	.word	0xffff0000

080026a4 <HAL_I2C_Mem_Read>:
  * @param  Size Amount of data to be sent
  * @param  Timeout Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 80026a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80026a8:	4604      	mov	r4, r0
 80026aa:	b089      	sub	sp, #36	; 0x24
 80026ac:	469b      	mov	fp, r3
 80026ae:	9102      	str	r1, [sp, #8]
 80026b0:	9203      	str	r2, [sp, #12]
 80026b2:	9e12      	ldr	r6, [sp, #72]	; 0x48
 80026b4:	f8bd 504c 	ldrh.w	r5, [sp, #76]	; 0x4c
 80026b8:	f8dd 8050 	ldr.w	r8, [sp, #80]	; 0x50
  uint32_t tickstart = 0x00U;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80026bc:	f7ff fa04 	bl	8001ac8 <HAL_GetTick>
  
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
 80026c0:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
 80026c4:	2b20      	cmp	r3, #32
HAL_StatusTypeDef HAL_I2C_Mem_Read(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint16_t MemAddress, uint16_t MemAddSize, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
  uint32_t tickstart = 0x00U;

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 80026c6:	4607      	mov	r7, r0
  
  /* Check the parameters */
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
 80026c8:	d002      	beq.n	80026d0 <HAL_I2C_Mem_Read+0x2c>

    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 80026ca:	f04f 0b02 	mov.w	fp, #2
 80026ce:	e0d5      	b.n	800287c <HAL_I2C_Mem_Read+0x1d8>
  assert_param(IS_I2C_MEMADD_SIZE(MemAddSize));

  if(hi2c->State == HAL_I2C_STATE_READY)
  {
    /* Wait until BUSY flag is reset */
    if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY_FLAG, tickstart) != HAL_OK)
 80026d0:	9000      	str	r0, [sp, #0]
 80026d2:	2319      	movs	r3, #25
 80026d4:	2201      	movs	r2, #1
 80026d6:	496b      	ldr	r1, [pc, #428]	; (8002884 <HAL_I2C_Mem_Read+0x1e0>)
 80026d8:	4620      	mov	r0, r4
 80026da:	f7ff fd28 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 80026de:	4681      	mov	r9, r0
 80026e0:	2800      	cmp	r0, #0
 80026e2:	d1f2      	bne.n	80026ca <HAL_I2C_Mem_Read+0x26>
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80026e4:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 80026e8:	2b01      	cmp	r3, #1
 80026ea:	d0ee      	beq.n	80026ca <HAL_I2C_Mem_Read+0x26>
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80026ec:	6822      	ldr	r2, [r4, #0]
    hi2c->Mode = HAL_I2C_MODE_MEM;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80026ee:	9902      	ldr	r1, [sp, #8]

    /* Process Locked */
    __HAL_LOCK(hi2c);
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80026f0:	6813      	ldr	r3, [r2, #0]
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80026f2:	f04f 0a01 	mov.w	sl, #1
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80026f6:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    {
      return HAL_BUSY;
    }

    /* Process Locked */
    __HAL_LOCK(hi2c);
 80026fa:	f884 a03c 	strb.w	sl, [r4, #60]	; 0x3c
    
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;
 80026fe:	6013      	str	r3, [r2, #0]

    hi2c->State = HAL_I2C_STATE_BUSY_RX;
 8002700:	2322      	movs	r3, #34	; 0x22
 8002702:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_MEM;
 8002706:	2340      	movs	r3, #64	; 0x40
 8002708:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 800270c:	4b5e      	ldr	r3, [pc, #376]	; (8002888 <HAL_I2C_Mem_Read+0x1e4>)
    /* Disable Pos */
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;

    hi2c->State = HAL_I2C_STATE_BUSY_RX;
    hi2c->Mode = HAL_I2C_MODE_MEM;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800270e:	6420      	str	r0, [r4, #64]	; 0x40
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8002710:	9701      	str	r7, [sp, #4]
    hi2c->Instance->CR1 &= ~I2C_CR1_POS;

    hi2c->State = HAL_I2C_STATE_BUSY_RX;
    hi2c->Mode = HAL_I2C_MODE_MEM;
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
 8002712:	62e3      	str	r3, [r4, #44]	; 0x2c
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 8002714:	f8cd 8000 	str.w	r8, [sp]
 8002718:	465b      	mov	r3, fp
 800271a:	9a03      	ldr	r2, [sp, #12]
 800271c:	4620      	mov	r0, r4
 800271e:	f7ff fe3d 	bl	800239c <I2C_RequestMemoryRead>
 8002722:	4683      	mov	fp, r0
 8002724:	b130      	cbz	r0, 8002734 <HAL_I2C_Mem_Read+0x90>
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 8002726:	6c23      	ldr	r3, [r4, #64]	; 0x40
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
 8002728:	f884 903c 	strb.w	r9, [r4, #60]	; 0x3c
    hi2c->XferOptions = I2C_NO_OPTION_FRAME;
    
    /* Send Slave Address and Memory Address */
    if(I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
    {
      if(hi2c->ErrorCode == HAL_I2C_ERROR_AF)
 800272c:	2b04      	cmp	r3, #4
 800272e:	d143      	bne.n	80027b8 <HAL_I2C_Mem_Read+0x114>
      {
        /* Process Unlocked */
        __HAL_UNLOCK(hi2c);
        return HAL_ERROR;
 8002730:	46d3      	mov	fp, sl
 8002732:	e0a3      	b.n	800287c <HAL_I2C_Mem_Read+0x1d8>
 8002734:	6823      	ldr	r3, [r4, #0]
        __HAL_UNLOCK(hi2c);
        return HAL_TIMEOUT;
      }
    }

    if(Size == 0U)
 8002736:	b955      	cbnz	r5, 800274e <HAL_I2C_Mem_Read+0xaa>
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002738:	9004      	str	r0, [sp, #16]
 800273a:	695a      	ldr	r2, [r3, #20]
 800273c:	9204      	str	r2, [sp, #16]
 800273e:	699a      	ldr	r2, [r3, #24]
 8002740:	9204      	str	r2, [sp, #16]
 8002742:	9a04      	ldr	r2, [sp, #16]
      
      /* Generate Stop */
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8002744:	681a      	ldr	r2, [r3, #0]
 8002746:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800274a:	601a      	str	r2, [r3, #0]
 800274c:	e08e      	b.n	800286c <HAL_I2C_Mem_Read+0x1c8>
    }
    else if(Size == 1U)
 800274e:	2d01      	cmp	r5, #1
 8002750:	d10e      	bne.n	8002770 <HAL_I2C_Mem_Read+0xcc>
    {
      /* Disable Acknowledge */
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002752:	681a      	ldr	r2, [r3, #0]
 8002754:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8002758:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 800275a:	9005      	str	r0, [sp, #20]
 800275c:	695a      	ldr	r2, [r3, #20]
 800275e:	9205      	str	r2, [sp, #20]
 8002760:	699a      	ldr	r2, [r3, #24]
 8002762:	9205      	str	r2, [sp, #20]
 8002764:	9a05      	ldr	r2, [sp, #20]

      /* Generate Stop */
      hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8002766:	681a      	ldr	r2, [r3, #0]
 8002768:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800276c:	601a      	str	r2, [r3, #0]
 800276e:	e016      	b.n	800279e <HAL_I2C_Mem_Read+0xfa>
    }
    else if(Size == 2U)
 8002770:	2d02      	cmp	r5, #2
 8002772:	d10e      	bne.n	8002792 <HAL_I2C_Mem_Read+0xee>
    {
      /* Disable Acknowledge */
      hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002774:	681a      	ldr	r2, [r3, #0]
 8002776:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800277a:	601a      	str	r2, [r3, #0]

      /* Enable Pos */
      hi2c->Instance->CR1 |= I2C_CR1_POS;
 800277c:	681a      	ldr	r2, [r3, #0]
 800277e:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 8002782:	601a      	str	r2, [r3, #0]

      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002784:	9006      	str	r0, [sp, #24]
 8002786:	695a      	ldr	r2, [r3, #20]
 8002788:	9206      	str	r2, [sp, #24]
 800278a:	699b      	ldr	r3, [r3, #24]
 800278c:	9306      	str	r3, [sp, #24]
 800278e:	9b06      	ldr	r3, [sp, #24]
 8002790:	e005      	b.n	800279e <HAL_I2C_Mem_Read+0xfa>
    }
    else
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
 8002792:	9007      	str	r0, [sp, #28]
 8002794:	695a      	ldr	r2, [r3, #20]
 8002796:	9207      	str	r2, [sp, #28]
 8002798:	699b      	ldr	r3, [r3, #24]
 800279a:	9307      	str	r3, [sp, #28]
 800279c:	9b07      	ldr	r3, [sp, #28]
    }

    while(Size > 0U)
    {
      if(Size <= 3U)
 800279e:	2d03      	cmp	r5, #3
 80027a0:	d84a      	bhi.n	8002838 <HAL_I2C_Mem_Read+0x194>
      {
        /* One byte */
        if(Size== 1U)
 80027a2:	2d01      	cmp	r5, #1
 80027a4:	d112      	bne.n	80027cc <HAL_I2C_Mem_Read+0x128>
        {
          /* Wait until RXNE flag is set */
          if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
 80027a6:	463a      	mov	r2, r7
 80027a8:	4641      	mov	r1, r8
 80027aa:	4620      	mov	r0, r4
 80027ac:	f7ff fd53 	bl	8002256 <I2C_WaitOnRXNEFlagUntilTimeout>
 80027b0:	b140      	cbz	r0, 80027c4 <HAL_I2C_Mem_Read+0x120>
          {
            if(hi2c->ErrorCode == HAL_I2C_ERROR_TIMEOUT)
 80027b2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 80027b4:	2b20      	cmp	r3, #32
 80027b6:	d102      	bne.n	80027be <HAL_I2C_Mem_Read+0x11a>
            {
              return HAL_TIMEOUT;
 80027b8:	f04f 0b03 	mov.w	fp, #3
 80027bc:	e05e      	b.n	800287c <HAL_I2C_Mem_Read+0x1d8>
            }
            else
            {
              return HAL_ERROR;
 80027be:	f04f 0b01 	mov.w	fp, #1
 80027c2:	e05b      	b.n	800287c <HAL_I2C_Mem_Read+0x1d8>
            }
          }

          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 80027c4:	6823      	ldr	r3, [r4, #0]
 80027c6:	691b      	ldr	r3, [r3, #16]
 80027c8:	7033      	strb	r3, [r6, #0]
 80027ca:	e04f      	b.n	800286c <HAL_I2C_Mem_Read+0x1c8>
          Size--;
        }
        /* Two bytes */
        else if(Size == 2U)
 80027cc:	2d02      	cmp	r5, #2
        {
          /* Wait until BTF flag is set */
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 80027ce:	9700      	str	r7, [sp, #0]
 80027d0:	4643      	mov	r3, r8
 80027d2:	f04f 0200 	mov.w	r2, #0
 80027d6:	492d      	ldr	r1, [pc, #180]	; (800288c <HAL_I2C_Mem_Read+0x1e8>)
 80027d8:	4620      	mov	r0, r4
          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
          Size--;
        }
        /* Two bytes */
        else if(Size == 2U)
 80027da:	d10e      	bne.n	80027fa <HAL_I2C_Mem_Read+0x156>
        {
          /* Wait until BTF flag is set */
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 80027dc:	f7ff fca7 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 80027e0:	2800      	cmp	r0, #0
 80027e2:	d1e9      	bne.n	80027b8 <HAL_I2C_Mem_Read+0x114>
          {
            return HAL_TIMEOUT;
          }

          /* Generate Stop */
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 80027e4:	6823      	ldr	r3, [r4, #0]
 80027e6:	681a      	ldr	r2, [r3, #0]
 80027e8:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80027ec:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 80027ee:	691b      	ldr	r3, [r3, #16]
 80027f0:	7033      	strb	r3, [r6, #0]
          Size--;

          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 80027f2:	6823      	ldr	r3, [r4, #0]
 80027f4:	691b      	ldr	r3, [r3, #16]
 80027f6:	7073      	strb	r3, [r6, #1]
 80027f8:	e038      	b.n	800286c <HAL_I2C_Mem_Read+0x1c8>
        }
        /* 3 Last bytes */
        else
        {
          /* Wait until BTF flag is set */
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 80027fa:	f7ff fc98 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 80027fe:	4602      	mov	r2, r0
 8002800:	2800      	cmp	r0, #0
 8002802:	d1d9      	bne.n	80027b8 <HAL_I2C_Mem_Read+0x114>
          {
            return HAL_TIMEOUT;
          }

          /* Disable Acknowledge */
          hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
 8002804:	6823      	ldr	r3, [r4, #0]
 8002806:	6819      	ldr	r1, [r3, #0]
 8002808:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
 800280c:	6019      	str	r1, [r3, #0]

          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 800280e:	691b      	ldr	r3, [r3, #16]
 8002810:	7033      	strb	r3, [r6, #0]
          Size--;

          /* Wait until BTF flag is set */
          if(I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BTF, RESET, Timeout, tickstart) != HAL_OK)
 8002812:	491e      	ldr	r1, [pc, #120]	; (800288c <HAL_I2C_Mem_Read+0x1e8>)
 8002814:	9700      	str	r7, [sp, #0]
 8002816:	4643      	mov	r3, r8
 8002818:	4620      	mov	r0, r4
 800281a:	f7ff fc88 	bl	800212e <I2C_WaitOnFlagUntilTimeout>
 800281e:	2800      	cmp	r0, #0
 8002820:	d1ca      	bne.n	80027b8 <HAL_I2C_Mem_Read+0x114>
          {
            return HAL_TIMEOUT;
          }

          /* Generate Stop */
          hi2c->Instance->CR1 |= I2C_CR1_STOP;
 8002822:	6823      	ldr	r3, [r4, #0]
 8002824:	681a      	ldr	r2, [r3, #0]
 8002826:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800282a:	601a      	str	r2, [r3, #0]

          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 800282c:	691b      	ldr	r3, [r3, #16]
 800282e:	7073      	strb	r3, [r6, #1]
          Size--;

          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 8002830:	6823      	ldr	r3, [r4, #0]
 8002832:	691b      	ldr	r3, [r3, #16]
 8002834:	70b3      	strb	r3, [r6, #2]
 8002836:	e019      	b.n	800286c <HAL_I2C_Mem_Read+0x1c8>
        }
      }
      else
      {
        /* Wait until RXNE flag is set */
        if(I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)      
 8002838:	463a      	mov	r2, r7
 800283a:	4641      	mov	r1, r8
 800283c:	4620      	mov	r0, r4
 800283e:	f7ff fd0a 	bl	8002256 <I2C_WaitOnRXNEFlagUntilTimeout>
 8002842:	2800      	cmp	r0, #0
 8002844:	d1b5      	bne.n	80027b2 <HAL_I2C_Mem_Read+0x10e>
            return HAL_ERROR;
          }
        }

        /* Read data from DR */
        (*pData++) = hi2c->Instance->DR;
 8002846:	6823      	ldr	r3, [r4, #0]
 8002848:	691b      	ldr	r3, [r3, #16]
 800284a:	7033      	strb	r3, [r6, #0]
        Size--;

        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
 800284c:	6823      	ldr	r3, [r4, #0]
 800284e:	695a      	ldr	r2, [r3, #20]
 8002850:	0752      	lsls	r2, r2, #29
          }
        }

        /* Read data from DR */
        (*pData++) = hi2c->Instance->DR;
        Size--;
 8002852:	bf51      	iteee	pl
 8002854:	f105 35ff 	addpl.w	r5, r5, #4294967295

        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
        {
          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
          Size--;
 8002858:	3d02      	submi	r5, #2
        Size--;

        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
        {
          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 800285a:	691b      	ldrmi	r3, [r3, #16]
 800285c:	7073      	strbmi	r3, [r6, #1]
          }
        }

        /* Read data from DR */
        (*pData++) = hi2c->Instance->DR;
        Size--;
 800285e:	bf55      	itete	pl
 8002860:	b2ad      	uxthpl	r5, r5

        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
        {
          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
          Size--;
 8002862:	b2ad      	uxthmi	r5, r5
            return HAL_ERROR;
          }
        }

        /* Read data from DR */
        (*pData++) = hi2c->Instance->DR;
 8002864:	3601      	addpl	r6, #1
        Size--;

        if(__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_BTF) == SET)
        {
          /* Read data from DR */
          (*pData++) = hi2c->Instance->DR;
 8002866:	3602      	addmi	r6, #2
    {
      /* Clear ADDR flag */
      __HAL_I2C_CLEAR_ADDRFLAG(hi2c);
    }

    while(Size > 0U)
 8002868:	2d00      	cmp	r5, #0
 800286a:	d198      	bne.n	800279e <HAL_I2C_Mem_Read+0xfa>
          Size--;
        }
      }
    }

    hi2c->State = HAL_I2C_STATE_READY;
 800286c:	2320      	movs	r3, #32
 800286e:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8002872:	2300      	movs	r3, #0
 8002874:	f884 303e 	strb.w	r3, [r4, #62]	; 0x3e
    
    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8002878:	f884 303c 	strb.w	r3, [r4, #60]	; 0x3c
  }
  else
  {
    return HAL_BUSY;
  }
}
 800287c:	4658      	mov	r0, fp
 800287e:	b009      	add	sp, #36	; 0x24
 8002880:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002884:	00100002 	.word	0x00100002
 8002888:	ffff0000 	.word	0xffff0000
 800288c:	00010004 	.word	0x00010004

08002890 <HAL_I2C_GetState>:
  *         the configuration information for I2C module
  * @retval HAL state
  */
HAL_I2C_StateTypeDef HAL_I2C_GetState(I2C_HandleTypeDef *hi2c)
{
  return hi2c->State;
 8002890:	f890 003d 	ldrb.w	r0, [r0, #61]	; 0x3d
}
 8002894:	4770      	bx	lr

08002896 <LTDC_SetConfig>:
  * @param  LayerIdx:  LTDC Layer index.
  *                    This parameter can be one of the following values: 0 or 1
  * @retval None
  */
static void LTDC_SetConfig(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{
 8002896:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t tmp = 0U;
  uint32_t tmp1 = 0U;
  uint32_t tmp2 = 0U;

  /* Configures the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
 800289a:	6804      	ldr	r4, [r0, #0]
 800289c:	684f      	ldr	r7, [r1, #4]
 800289e:	68e5      	ldr	r5, [r4, #12]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 80028a0:	f8d1 c000 	ldr.w	ip, [r1]
  uint32_t tmp1 = 0U;
  uint32_t tmp2 = 0U;

  /* Configures the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 80028a4:	f104 0e84 	add.w	lr, r4, #132	; 0x84
 80028a8:	01d2      	lsls	r2, r2, #7
 80028aa:	eb02 030e 	add.w	r3, r2, lr
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 80028ae:	f3c5 450b 	ubfx	r5, r5, #16, #12
  uint32_t tmp1 = 0U;
  uint32_t tmp2 = 0U;

  /* Configures the horizontal start and stop position */
  tmp = ((pLayerCfg->WindowX1 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
 80028b2:	6858      	ldr	r0, [r3, #4]
 80028b4:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 80028b8:	6058      	str	r0, [r3, #4]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);
 80028ba:	68e0      	ldr	r0, [r4, #12]
 80028bc:	19ee      	adds	r6, r5, r7
 80028be:	f3c0 400b 	ubfx	r0, r0, #16, #12
 80028c2:	f10c 0501 	add.w	r5, ip, #1
 80028c6:	4428      	add	r0, r5
 80028c8:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80028cc:	6058      	str	r0, [r3, #4]

  /* Configures the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
 80028ce:	68e0      	ldr	r0, [r4, #12]
 80028d0:	68cd      	ldr	r5, [r1, #12]
 80028d2:	f3c0 000a 	ubfx	r0, r0, #0, #11
 80028d6:	1946      	adds	r6, r0, r5
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 80028d8:	6898      	ldr	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);  
 80028da:	688d      	ldr	r5, [r1, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR &= ~(LTDC_LxWHPCR_WHSTPOS | LTDC_LxWHPCR_WHSPPOS);
  LTDC_LAYER(hltdc, LayerIdx)->WHPCR = ((pLayerCfg->WindowX0 + ((hltdc->Instance->BPCR & LTDC_BPCR_AHBP) >> 16U) + 1U) | tmp);

  /* Configures the vertical start and stop position */
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
 80028dc:	f400 4070 	and.w	r0, r0, #61440	; 0xf000
 80028e0:	6098      	str	r0, [r3, #8]
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);  
 80028e2:	68e4      	ldr	r4, [r4, #12]
 80028e4:	1c68      	adds	r0, r5, #1
 80028e6:	f3c4 040a 	ubfx	r4, r4, #0, #11
 80028ea:	4420      	add	r0, r4
 80028ec:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
 80028f0:	6098      	str	r0, [r3, #8]

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80028f2:	6918      	ldr	r0, [r3, #16]
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 80028f4:	690e      	ldr	r6, [r1, #16]

  /* Configures the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  tmp2 = (pLayerCfg->Alpha0 << 24U);  
 80028f6:	698d      	ldr	r5, [r1, #24]
  tmp = ((pLayerCfg->WindowY1 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP)) << 16U);
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);  

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
 80028f8:	f020 0007 	bic.w	r0, r0, #7
 80028fc:	6118      	str	r0, [r3, #16]

  /* Configures the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  tmp2 = (pLayerCfg->Alpha0 << 24U);  
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 80028fe:	f04f 0800 	mov.w	r8, #0
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR &= ~(LTDC_LxWVPCR_WVSTPOS | LTDC_LxWVPCR_WVSPPOS);
  LTDC_LAYER(hltdc, LayerIdx)->WVPCR  = ((pLayerCfg->WindowY0 + (hltdc->Instance->BPCR & LTDC_BPCR_AVBP) + 1U) | tmp);  

  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);
 8002902:	611e      	str	r6, [r3, #16]

  /* Configures the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
  tmp2 = (pLayerCfg->Alpha0 << 24U);  
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 8002904:	6998      	ldr	r0, [r3, #24]
  /* Specifies the pixel format */
  LTDC_LAYER(hltdc, LayerIdx)->PFCR &= ~(LTDC_LxPFCR_PF);
  LTDC_LAYER(hltdc, LayerIdx)->PFCR = (pLayerCfg->PixelFormat);

  /* Configures the default color values */
  tmp = ((uint32_t)(pLayerCfg->Backcolor.Green) << 8U);
 8002906:	f891 4031 	ldrb.w	r4, [r1, #49]	; 0x31
  tmp1 = ((uint32_t)(pLayerCfg->Backcolor.Red) << 16U);
 800290a:	f891 9032 	ldrb.w	r9, [r1, #50]	; 0x32
  tmp2 = (pLayerCfg->Alpha0 << 24U);  
  LTDC_LAYER(hltdc, LayerIdx)->DCCR &= ~(LTDC_LxDCCR_DCBLUE | LTDC_LxDCCR_DCGREEN | LTDC_LxDCCR_DCRED | LTDC_LxDCCR_DCALPHA);
 800290e:	f8c3 8018 	str.w	r8, [r3, #24]
  LTDC_LAYER(hltdc, LayerIdx)->DCCR = (pLayerCfg->Backcolor.Blue | tmp | tmp1 | tmp2); 
 8002912:	f891 0030 	ldrb.w	r0, [r1, #48]	; 0x30
 8002916:	ea40 6505 	orr.w	r5, r0, r5, lsl #24
 800291a:	ea45 2404 	orr.w	r4, r5, r4, lsl #8
 800291e:	ea44 4409 	orr.w	r4, r4, r9, lsl #16
 8002922:	619c      	str	r4, [r3, #24]

  /* Specifies the constant alpha value */
  LTDC_LAYER(hltdc, LayerIdx)->CACR &= ~(LTDC_LxCACR_CONSTA);
 8002924:	6958      	ldr	r0, [r3, #20]
 8002926:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
 800292a:	6158      	str	r0, [r3, #20]
  LTDC_LAYER(hltdc, LayerIdx)->CACR = (pLayerCfg->Alpha);
 800292c:	6948      	ldr	r0, [r1, #20]
 800292e:	6158      	str	r0, [r3, #20]

  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
 8002930:	69d8      	ldr	r0, [r3, #28]
 8002932:	f420 60e0 	bic.w	r0, r0, #1792	; 0x700
 8002936:	f020 0007 	bic.w	r0, r0, #7
 800293a:	61d8      	str	r0, [r3, #28]
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);
 800293c:	69cd      	ldr	r5, [r1, #28]
 800293e:	6a0c      	ldr	r4, [r1, #32]
 8002940:	432c      	orrs	r4, r5
 8002942:	61dc      	str	r4, [r3, #28]

  /* Configures the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8002944:	6a98      	ldr	r0, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 8002946:	6a48      	ldr	r0, [r1, #36]	; 0x24
  /* Specifies the blending factors */
  LTDC_LAYER(hltdc, LayerIdx)->BFCR &= ~(LTDC_LxBFCR_BF2 | LTDC_LxBFCR_BF1);
  LTDC_LAYER(hltdc, LayerIdx)->BFCR = (pLayerCfg->BlendingFactor1 | pLayerCfg->BlendingFactor2);

  /* Configures the color frame buffer start address */
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
 8002948:	f8c3 8028 	str.w	r8, [r3, #40]	; 0x28
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);
 800294c:	6298      	str	r0, [r3, #40]	; 0x28

  if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
 800294e:	b14e      	cbz	r6, 8002964 <LTDC_SetConfig+0xce>
  {
    tmp = 4U;
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
 8002950:	2e01      	cmp	r6, #1
 8002952:	d009      	beq.n	8002968 <LTDC_SetConfig+0xd2>
  {
    tmp = 3U;
  }
  else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
 8002954:	1eb0      	subs	r0, r6, #2
 8002956:	2802      	cmp	r0, #2
 8002958:	d908      	bls.n	800296c <LTDC_SetConfig+0xd6>
    (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
      (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
 800295a:	2e07      	cmp	r6, #7
  {
    tmp = 2U;
  }
  else
  {
    tmp = 1U;
 800295c:	bf0c      	ite	eq
 800295e:	2002      	moveq	r0, #2
 8002960:	2001      	movne	r0, #1
 8002962:	e004      	b.n	800296e <LTDC_SetConfig+0xd8>
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR &= ~(LTDC_LxCFBAR_CFBADD);
  LTDC_LAYER(hltdc, LayerIdx)->CFBAR = (pLayerCfg->FBStartAdress);

  if(pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB8888)
  {
    tmp = 4U;
 8002964:	2004      	movs	r0, #4
 8002966:	e002      	b.n	800296e <LTDC_SetConfig+0xd8>
  }
  else if (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB888)
  {
    tmp = 3U;
 8002968:	2003      	movs	r0, #3
 800296a:	e000      	b.n	800296e <LTDC_SetConfig+0xd8>
  else if((pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB4444) || \
    (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_RGB565)   || \
      (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_ARGB1555) || \
        (pLayerCfg->PixelFormat == LTDC_PIXEL_FORMAT_AL88))
  {
    tmp = 2U;
 800296c:	2002      	movs	r0, #2
  {
    tmp = 1U;
  }

  /* Configures the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
 800296e:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 8002970:	f004 24e0 	and.w	r4, r4, #3758153728	; 0xe000e000
 8002974:	62dc      	str	r4, [r3, #44]	; 0x2c
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 8002976:	6a8c      	ldr	r4, [r1, #40]	; 0x28

  /* Configures the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8002978:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
    tmp = 1U;
  }

  /* Configures the color frame buffer pitch in byte */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  &= ~(LTDC_LxCFBLR_CFBLL | LTDC_LxCFBLR_CFBP);
  LTDC_LAYER(hltdc, LayerIdx)->CFBLR  = (((pLayerCfg->ImageWidth * tmp) << 16U) | (((pLayerCfg->WindowX1 - pLayerCfg->WindowX0) * tmp)  + 3U));
 800297a:	ebcc 0707 	rsb	r7, ip, r7
 800297e:	4344      	muls	r4, r0
 8002980:	4378      	muls	r0, r7
 8002982:	3003      	adds	r0, #3
 8002984:	ea40 4004 	orr.w	r0, r0, r4, lsl #16
 8002988:	62d8      	str	r0, [r3, #44]	; 0x2c

  /* Configures the frame buffer line number */
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  &= ~(LTDC_LxCFBLNR_CFBLNBR);
 800298a:	6b18      	ldr	r0, [r3, #48]	; 0x30
 800298c:	f420 60ff 	bic.w	r0, r0, #2040	; 0x7f8
 8002990:	f020 0007 	bic.w	r0, r0, #7
 8002994:	6318      	str	r0, [r3, #48]	; 0x30
  LTDC_LAYER(hltdc, LayerIdx)->CFBLNR  = (pLayerCfg->ImageHeight);
 8002996:	6319      	str	r1, [r3, #48]	; 0x30

  /* Enable LTDC_Layer by setting LEN bit */  
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_LEN;
 8002998:	f852 300e 	ldr.w	r3, [r2, lr]
 800299c:	f043 0301 	orr.w	r3, r3, #1
 80029a0:	f842 300e 	str.w	r3, [r2, lr]
 80029a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080029a8 <HAL_LTDC_Init>:
  * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_Init(LTDC_HandleTypeDef *hltdc)
{
 80029a8:	b538      	push	{r3, r4, r5, lr}
  uint32_t tmp = 0U, tmp1 = 0U;

  /* Check the LTDC peripheral state */
  if(hltdc == NULL)
 80029aa:	4604      	mov	r4, r0
 80029ac:	2800      	cmp	r0, #0
 80029ae:	d06a      	beq.n	8002a86 <HAL_LTDC_Init+0xde>
  assert_param(IS_LTDC_HSPOL(hltdc->Init.HSPolarity));
  assert_param(IS_LTDC_VSPOL(hltdc->Init.VSPolarity));
  assert_param(IS_LTDC_DEPOL(hltdc->Init.DEPolarity));
  assert_param(IS_LTDC_PCPOL(hltdc->Init.PCPolarity));

  if(hltdc->State == HAL_LTDC_STATE_RESET)
 80029b0:	f890 30a1 	ldrb.w	r3, [r0, #161]	; 0xa1
 80029b4:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80029b8:	b91b      	cbnz	r3, 80029c2 <HAL_LTDC_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hltdc->Lock = HAL_UNLOCKED;
 80029ba:	f880 20a0 	strb.w	r2, [r0, #160]	; 0xa0
    /* Init the low level hardware */
    HAL_LTDC_MspInit(hltdc);
 80029be:	f001 fc23 	bl	8004208 <HAL_LTDC_MspInit>
  }
  
  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 80029c2:	2302      	movs	r3, #2
 80029c4:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1

  /* Configures the HS, VS, DE and PC polarity */
  hltdc->Instance->GCR &= ~(LTDC_GCR_HSPOL | LTDC_GCR_VSPOL | LTDC_GCR_DEPOL | LTDC_GCR_PCPOL);
 80029c8:	6823      	ldr	r3, [r4, #0]
 80029ca:	699a      	ldr	r2, [r3, #24]
 80029cc:	f022 4270 	bic.w	r2, r2, #4026531840	; 0xf0000000
 80029d0:	619a      	str	r2, [r3, #24]
  hltdc->Instance->GCR |=  (uint32_t)(hltdc->Init.HSPolarity | hltdc->Init.VSPolarity | \
 80029d2:	6999      	ldr	r1, [r3, #24]
 80029d4:	6862      	ldr	r2, [r4, #4]
 80029d6:	4311      	orrs	r1, r2
 80029d8:	68a2      	ldr	r2, [r4, #8]
 80029da:	4311      	orrs	r1, r2
 80029dc:	68e2      	ldr	r2, [r4, #12]
 80029de:	4311      	orrs	r1, r2
 80029e0:	6922      	ldr	r2, [r4, #16]
 80029e2:	430a      	orrs	r2, r1
 80029e4:	619a      	str	r2, [r3, #24]
  hltdc->Init.DEPolarity | hltdc->Init.PCPolarity);

  /* Sets Synchronization size */
  hltdc->Instance->SSCR &= ~(LTDC_SSCR_VSH | LTDC_SSCR_HSW);
 80029e6:	6899      	ldr	r1, [r3, #8]
 80029e8:	4a28      	ldr	r2, [pc, #160]	; (8002a8c <HAL_LTDC_Init+0xe4>)
 80029ea:	400a      	ands	r2, r1
 80029ec:	609a      	str	r2, [r3, #8]
  tmp = (hltdc->Init.HorizontalSync << 16U);
  hltdc->Instance->SSCR |= (tmp | hltdc->Init.VerticalSync);
 80029ee:	6898      	ldr	r0, [r3, #8]
 80029f0:	69a2      	ldr	r2, [r4, #24]
 80029f2:	6961      	ldr	r1, [r4, #20]
 80029f4:	4302      	orrs	r2, r0
 80029f6:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 80029fa:	609a      	str	r2, [r3, #8]

  /* Sets Accumulated Back porch */
  hltdc->Instance->BPCR &= ~(LTDC_BPCR_AVBP | LTDC_BPCR_AHBP);
 80029fc:	68d9      	ldr	r1, [r3, #12]
 80029fe:	4a23      	ldr	r2, [pc, #140]	; (8002a8c <HAL_LTDC_Init+0xe4>)
 8002a00:	400a      	ands	r2, r1
 8002a02:	60da      	str	r2, [r3, #12]
  tmp = (hltdc->Init.AccumulatedHBP << 16U);
  hltdc->Instance->BPCR |= (tmp | hltdc->Init.AccumulatedVBP);
 8002a04:	68d8      	ldr	r0, [r3, #12]
 8002a06:	6a22      	ldr	r2, [r4, #32]
 8002a08:	69e1      	ldr	r1, [r4, #28]
 8002a0a:	4302      	orrs	r2, r0
 8002a0c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002a10:	60da      	str	r2, [r3, #12]

  /* Sets Accumulated Active Width */
  hltdc->Instance->AWCR &= ~(LTDC_AWCR_AAH | LTDC_AWCR_AAW);
 8002a12:	6919      	ldr	r1, [r3, #16]
 8002a14:	4a1d      	ldr	r2, [pc, #116]	; (8002a8c <HAL_LTDC_Init+0xe4>)
 8002a16:	400a      	ands	r2, r1
 8002a18:	611a      	str	r2, [r3, #16]
  tmp = (hltdc->Init.AccumulatedActiveW << 16U);
  hltdc->Instance->AWCR |= (tmp | hltdc->Init.AccumulatedActiveH);
 8002a1a:	6918      	ldr	r0, [r3, #16]
 8002a1c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8002a1e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8002a20:	4302      	orrs	r2, r0
 8002a22:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002a26:	611a      	str	r2, [r3, #16]

  /* Sets Total Width */
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
 8002a28:	6959      	ldr	r1, [r3, #20]
 8002a2a:	4a18      	ldr	r2, [pc, #96]	; (8002a8c <HAL_LTDC_Init+0xe4>)
 8002a2c:	400a      	ands	r2, r1
 8002a2e:	615a      	str	r2, [r3, #20]
  tmp = (hltdc->Init.TotalWidth << 16U);
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);
 8002a30:	6958      	ldr	r0, [r3, #20]
 8002a32:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8002a34:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002a36:	4302      	orrs	r2, r0
 8002a38:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 8002a3c:	615a      	str	r2, [r3, #20]

  /* Sets the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8002a3e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  tmp = (hltdc->Init.TotalWidth << 16U);
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);

  /* Sets the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
 8002a40:	f894 0036 	ldrb.w	r0, [r4, #54]	; 0x36
  hltdc->Instance->TWCR &= ~(LTDC_TWCR_TOTALH | LTDC_TWCR_TOTALW);
  tmp = (hltdc->Init.TotalWidth << 16U);
  hltdc->Instance->TWCR |= (tmp | hltdc->Init.TotalHeigh);

  /* Sets the background color value */
  tmp = ((uint32_t)(hltdc->Init.Backcolor.Green) << 8U);
 8002a44:	f894 2035 	ldrb.w	r2, [r4, #53]	; 0x35
  tmp1 = ((uint32_t)(hltdc->Init.Backcolor.Red) << 16U);
  hltdc->Instance->BCCR &= ~(LTDC_BCCR_BCBLUE | LTDC_BCCR_BCGREEN | LTDC_BCCR_BCRED);
 8002a48:	f001 417f 	and.w	r1, r1, #4278190080	; 0xff000000
 8002a4c:	62d9      	str	r1, [r3, #44]	; 0x2c
  hltdc->Instance->BCCR |= (tmp1 | tmp | hltdc->Init.Backcolor.Blue);
 8002a4e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8002a50:	f894 5034 	ldrb.w	r5, [r4, #52]	; 0x34
 8002a54:	4329      	orrs	r1, r5
 8002a56:	ea41 2202 	orr.w	r2, r1, r2, lsl #8
 8002a5a:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 8002a5e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Enable the transfer Error interrupt */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_TE);
 8002a60:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a62:	f042 0204 	orr.w	r2, r2, #4
 8002a66:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable the FIFO underrun interrupt */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_FU);
 8002a68:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a6a:	f042 0202 	orr.w	r2, r2, #2
 8002a6e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);
 8002a70:	699a      	ldr	r2, [r3, #24]
 8002a72:	f042 0201 	orr.w	r2, r2, #1
 8002a76:	619a      	str	r2, [r3, #24]

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 8002a78:	2000      	movs	r0, #0

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002a7a:	2301      	movs	r3, #1

  /* Enable LTDC by setting LTDCEN bit */
  __HAL_LTDC_ENABLE(hltdc);

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;  
 8002a7c:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002a80:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1

  return HAL_OK;
 8002a84:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t tmp = 0U, tmp1 = 0U;

  /* Check the LTDC peripheral state */
  if(hltdc == NULL)
  {
    return HAL_ERROR;
 8002a86:	2001      	movs	r0, #1

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;

  return HAL_OK;
}
 8002a88:	bd38      	pop	{r3, r4, r5, pc}
 8002a8a:	bf00      	nop
 8002a8c:	f000f800 	.word	0xf000f800

08002a90 <HAL_LTDC_DeInit>:
  *                the configuration information for the LTDC.
  * @retval None
  */

HAL_StatusTypeDef HAL_LTDC_DeInit(LTDC_HandleTypeDef *hltdc)
{
 8002a90:	b510      	push	{r4, lr}
 8002a92:	4604      	mov	r4, r0
  /* DeInit the low level hardware */
  HAL_LTDC_MspDeInit(hltdc); 
 8002a94:	f001 fc5a 	bl	800434c <HAL_LTDC_MspDeInit>

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;
 8002a98:	2000      	movs	r0, #0
 8002a9a:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hltdc);
 8002a9e:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0

  /* Initialize the error code */
  hltdc->ErrorCode = HAL_LTDC_ERROR_NONE;

  /* Initialize the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_RESET;
 8002aa2:	f884 00a1 	strb.w	r0, [r4, #161]	; 0xa1

  /* Release Lock */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002aa6:	bd10      	pop	{r4, pc}

08002aa8 <HAL_LTDC_ErrorCallback>:
 8002aa8:	4770      	bx	lr

08002aaa <HAL_LTDC_ReloadEventCallback>:
  * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.
  * @retval None
  */
__weak void HAL_LTDC_ReloadEventCallback(LTDC_HandleTypeDef *hltdc)
{
 8002aaa:	4770      	bx	lr

08002aac <HAL_LTDC_IRQHandler>:
  * @retval HAL status
  */
void HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc)
{
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_TE) != RESET)
 8002aac:	6803      	ldr	r3, [r0, #0]
 8002aae:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002ab0:	0751      	lsls	r1, r2, #29
  * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the LTDC.  
  * @retval HAL status
  */
void HAL_LTDC_IRQHandler(LTDC_HandleTypeDef *hltdc)
{
 8002ab2:	b510      	push	{r4, lr}
 8002ab4:	4604      	mov	r4, r0
  /* Transfer Error Interrupt management ***************************************/
  if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_TE) != RESET)
 8002ab6:	d515      	bpl.n	8002ae4 <HAL_LTDC_IRQHandler+0x38>
  {
    if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_TE) != RESET)
 8002ab8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002aba:	0752      	lsls	r2, r2, #29
 8002abc:	d512      	bpl.n	8002ae4 <HAL_LTDC_IRQHandler+0x38>
    {
      /* Disable the transfer Error interrupt */
      __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_TE);
 8002abe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002ac0:	f022 0204 	bic.w	r2, r2, #4
 8002ac4:	635a      	str	r2, [r3, #52]	; 0x34

      /* Clear the transfer error flag */
      __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_TE);
 8002ac6:	2204      	movs	r2, #4
 8002ac8:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Update error code */
      hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;
 8002aca:	f8d0 30a4 	ldr.w	r3, [r0, #164]	; 0xa4
 8002ace:	f043 0301 	orr.w	r3, r3, #1
 8002ad2:	f8c0 30a4 	str.w	r3, [r0, #164]	; 0xa4

      /* Change LTDC state */
      hltdc->State = HAL_LTDC_STATE_ERROR;

      /* Process unlocked */
      __HAL_UNLOCK(hltdc);
 8002ad6:	2300      	movs	r3, #0

      /* Update error code */
      hltdc->ErrorCode |= HAL_LTDC_ERROR_TE;

      /* Change LTDC state */
      hltdc->State = HAL_LTDC_STATE_ERROR;
 8002ad8:	f880 20a1 	strb.w	r2, [r0, #161]	; 0xa1

      /* Process unlocked */
      __HAL_UNLOCK(hltdc);
 8002adc:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0

      /* Transfer error Callback */
      HAL_LTDC_ErrorCallback(hltdc);
 8002ae0:	f7ff ffe2 	bl	8002aa8 <HAL_LTDC_ErrorCallback>
    }
  }
  /* FIFO underrun Interrupt management ***************************************/
  if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_FU) != RESET)
 8002ae4:	6823      	ldr	r3, [r4, #0]
 8002ae6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002ae8:	0790      	lsls	r0, r2, #30
 8002aea:	d516      	bpl.n	8002b1a <HAL_LTDC_IRQHandler+0x6e>
  {
    if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_FU) != RESET)
 8002aec:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002aee:	0791      	lsls	r1, r2, #30
 8002af0:	d513      	bpl.n	8002b1a <HAL_LTDC_IRQHandler+0x6e>
    {
      /* Disable the FIFO underrun interrupt */
      __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_FU);
 8002af2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002af4:	f022 0202 	bic.w	r2, r2, #2
 8002af8:	635a      	str	r2, [r3, #52]	; 0x34

      /* Clear the FIFO underrun flag */
      __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_FU);
 8002afa:	2202      	movs	r2, #2
 8002afc:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Update error code */
      hltdc->ErrorCode |= HAL_LTDC_ERROR_FU;
 8002afe:	f8d4 30a4 	ldr.w	r3, [r4, #164]	; 0xa4
 8002b02:	4313      	orrs	r3, r2
 8002b04:	f8c4 30a4 	str.w	r3, [r4, #164]	; 0xa4

      /* Change LTDC state */
      hltdc->State = HAL_LTDC_STATE_ERROR;
 8002b08:	2304      	movs	r3, #4
 8002b0a:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1

      /* Process unlocked */
      __HAL_UNLOCK(hltdc);
 8002b0e:	2300      	movs	r3, #0
 8002b10:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
      
      /* Transfer error Callback */
      HAL_LTDC_ErrorCallback(hltdc);
 8002b14:	4620      	mov	r0, r4
 8002b16:	f7ff ffc7 	bl	8002aa8 <HAL_LTDC_ErrorCallback>
    }
  }
  /* Line Interrupt management ************************************************/
  if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_LI) != RESET)
 8002b1a:	6823      	ldr	r3, [r4, #0]
 8002b1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002b1e:	07d2      	lsls	r2, r2, #31
 8002b20:	d510      	bpl.n	8002b44 <HAL_LTDC_IRQHandler+0x98>
  {
    if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_LI) != RESET)
 8002b22:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002b24:	07d0      	lsls	r0, r2, #31
 8002b26:	d50d      	bpl.n	8002b44 <HAL_LTDC_IRQHandler+0x98>
    {
      /* Disable the Line interrupt */
      __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_LI);
 8002b28:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002b2a:	f022 0201 	bic.w	r2, r2, #1
 8002b2e:	635a      	str	r2, [r3, #52]	; 0x34

      /* Clear the Line interrupt flag */  
      __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);
 8002b30:	2201      	movs	r2, #1
 8002b32:	63da      	str	r2, [r3, #60]	; 0x3c

      /* Change LTDC state */
      hltdc->State = HAL_LTDC_STATE_READY;

      /* Process unlocked */
      __HAL_UNLOCK(hltdc);
 8002b34:	2300      	movs	r3, #0

      /* Clear the Line interrupt flag */  
      __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_LI);

      /* Change LTDC state */
      hltdc->State = HAL_LTDC_STATE_READY;
 8002b36:	f884 20a1 	strb.w	r2, [r4, #161]	; 0xa1

      /* Process unlocked */
      __HAL_UNLOCK(hltdc);
 8002b3a:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0

      /* Line interrupt Callback */
      HAL_LTDC_LineEventCallback(hltdc);
 8002b3e:	4620      	mov	r0, r4
 8002b40:	f001 fc10 	bl	8004364 <HAL_LTDC_LineEventCallback>
    }
  }
  /* Register reload Interrupt management ***************************************/
  if(__HAL_LTDC_GET_FLAG(hltdc, LTDC_FLAG_RR) != RESET)
 8002b44:	6823      	ldr	r3, [r4, #0]
 8002b46:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002b48:	0711      	lsls	r1, r2, #28
 8002b4a:	d511      	bpl.n	8002b70 <HAL_LTDC_IRQHandler+0xc4>
  {
    if(__HAL_LTDC_GET_IT_SOURCE(hltdc, LTDC_IT_RR) != RESET)
 8002b4c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002b4e:	0712      	lsls	r2, r2, #28
 8002b50:	d50e      	bpl.n	8002b70 <HAL_LTDC_IRQHandler+0xc4>
    {
      /* Disable the register reload interrupt */
      __HAL_LTDC_DISABLE_IT(hltdc, LTDC_IT_RR);
 8002b52:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002b54:	f022 0208 	bic.w	r2, r2, #8
 8002b58:	635a      	str	r2, [r3, #52]	; 0x34
      
      /* Clear the register reload flag */
      __HAL_LTDC_CLEAR_FLAG(hltdc, LTDC_FLAG_RR);
 8002b5a:	2208      	movs	r2, #8
 8002b5c:	63da      	str	r2, [r3, #60]	; 0x3c
      
      /* Change LTDC state */
      hltdc->State = HAL_LTDC_STATE_READY;
 8002b5e:	2301      	movs	r3, #1
 8002b60:	f884 30a1 	strb.w	r3, [r4, #161]	; 0xa1
      
      /* Process unlocked */
      __HAL_UNLOCK(hltdc);
 8002b64:	2300      	movs	r3, #0
 8002b66:	f884 30a0 	strb.w	r3, [r4, #160]	; 0xa0
      
      /* Register reload interrupt Callback */
      HAL_LTDC_ReloadEventCallback(hltdc);
 8002b6a:	4620      	mov	r0, r4
 8002b6c:	f7ff ff9d 	bl	8002aaa <HAL_LTDC_ReloadEventCallback>
 8002b70:	bd10      	pop	{r4, pc}

08002b72 <HAL_LTDC_ConfigLayer>:
  *                    This parameter can be one of the following values:
  *                    0 or 1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{   
 8002b72:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002b74:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002b78:	2b01      	cmp	r3, #1
  *                    This parameter can be one of the following values:
  *                    0 or 1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigLayer(LTDC_HandleTypeDef *hltdc, LTDC_LayerCfgTypeDef *pLayerCfg, uint32_t LayerIdx)
{   
 8002b7a:	4606      	mov	r6, r0
 8002b7c:	468e      	mov	lr, r1
 8002b7e:	4694      	mov	ip, r2
 8002b80:	f04f 0002 	mov.w	r0, #2
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002b84:	d01d      	beq.n	8002bc2 <HAL_LTDC_ConfigLayer+0x50>
 8002b86:	2701      	movs	r7, #1
 8002b88:	f886 70a0 	strb.w	r7, [r6, #160]	; 0xa0
  
  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002b8c:	f886 00a1 	strb.w	r0, [r6, #161]	; 0xa1
  assert_param(IS_LTDC_ALPHA(pLayerCfg->Alpha0));
  assert_param(IS_LTDC_CFBLL(pLayerCfg->ImageWidth));
  assert_param(IS_LTDC_CFBLNBR(pLayerCfg->ImageHeight));

  /* Copy new layer configuration into handle structure */
  hltdc->LayerCfg[LayerIdx] = *pLayerCfg;  
 8002b90:	2434      	movs	r4, #52	; 0x34
 8002b92:	460d      	mov	r5, r1
 8002b94:	fb04 6402 	mla	r4, r4, r2, r6
 8002b98:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002b9a:	3438      	adds	r4, #56	; 0x38
 8002b9c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002b9e:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002ba0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002ba2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 8002ba4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002ba6:	682b      	ldr	r3, [r5, #0]
 8002ba8:	6023      	str	r3, [r4, #0]

  /* Configure the LTDC Layer */  
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002baa:	4630      	mov	r0, r6
 8002bac:	4662      	mov	r2, ip
 8002bae:	4671      	mov	r1, lr
 8002bb0:	f7ff fe71 	bl	8002896 <LTDC_SetConfig>

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002bb4:	6833      	ldr	r3, [r6, #0]

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002bb6:	2000      	movs	r0, #0

  /* Configure the LTDC Layer */  
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002bb8:	625f      	str	r7, [r3, #36]	; 0x24

  /* Initialize the LTDC state*/
  hltdc->State  = HAL_LTDC_STATE_READY;
 8002bba:	f886 70a1 	strb.w	r7, [r6, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002bbe:	f886 00a0 	strb.w	r0, [r6, #160]	; 0xa0

  return HAL_OK;
}
 8002bc2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08002bc4 <HAL_LTDC_ConfigColorKeying>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
{
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002bc4:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002bc8:	2b01      	cmp	r3, #1
  *                   This parameter can be one of the following values:
  *                   0 or 1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
{
 8002bca:	b510      	push	{r4, lr}
 8002bcc:	f04f 0302 	mov.w	r3, #2
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002bd0:	d012      	beq.n	8002bf8 <HAL_LTDC_ConfigColorKeying+0x34>

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Configures the default color values */
  LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
 8002bd2:	6804      	ldr	r4, [r0, #0]
{
  /* Process locked */
  __HAL_LOCK(hltdc);

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002bd4:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Configures the default color values */
  LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
 8002bd8:	f104 0384 	add.w	r3, r4, #132	; 0x84
 8002bdc:	eb03 12c2 	add.w	r2, r3, r2, lsl #7
 8002be0:	68d3      	ldr	r3, [r2, #12]
 8002be2:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8002be6:	60d3      	str	r3, [r2, #12]
  LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002be8:	2301      	movs	r3, #1
  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Configures the default color values */
  LTDC_LAYER(hltdc, LayerIdx)->CKCR &=  ~(LTDC_LxCKCR_CKBLUE | LTDC_LxCKCR_CKGREEN | LTDC_LxCKCR_CKRED);
  LTDC_LAYER(hltdc, LayerIdx)->CKCR  = RGBValue;
 8002bea:	60d1      	str	r1, [r2, #12]

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002bec:	6263      	str	r3, [r4, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002bee:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002bf2:	2300      	movs	r3, #0
 8002bf4:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t RGBValue, uint32_t LayerIdx)
{
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002bf8:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002bfa:	bd10      	pop	{r4, pc}

08002bfc <HAL_LTDC_ConfigCLUT>:
  *                   This parameter can be one of the following values:
  *                   0 or 1
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ConfigCLUT(LTDC_HandleTypeDef *hltdc, uint32_t *pCLUT, uint32_t CLUTSize, uint32_t LayerIdx)
{
 8002bfc:	b5f0      	push	{r4, r5, r6, r7, lr}
  uint32_t tmp = 0U;
  uint32_t counter = 0U;
  uint32_t pcounter = 0U;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002bfe:	f890 40a0 	ldrb.w	r4, [r0, #160]	; 0xa0
 8002c02:	2c01      	cmp	r4, #1
 8002c04:	f04f 0402 	mov.w	r4, #2
 8002c08:	d02e      	beq.n	8002c68 <HAL_LTDC_ConfigCLUT+0x6c>
 8002c0a:	2501      	movs	r5, #1
 8002c0c:	f880 50a0 	strb.w	r5, [r0, #160]	; 0xa0
  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx)); 

  for(counter = 0U; (counter < CLUTSize); counter++)
  {
    if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
 8002c10:	2534      	movs	r5, #52	; 0x34

  /* Process locked */
  __HAL_LOCK(hltdc);

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;  
 8002c12:	f880 40a1 	strb.w	r4, [r0, #161]	; 0xa1
    }
    pcounter = (uint32_t)pCLUT + sizeof(*pCLUT);
    pCLUT = (uint32_t *)pcounter;

    /* Specifies the C-LUT address and RGB value */
    LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
 8002c16:	01df      	lsls	r7, r3, #7
  hltdc->State = HAL_LTDC_STATE_BUSY;  

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx)); 

  for(counter = 0U; (counter < CLUTSize); counter++)
 8002c18:	2400      	movs	r4, #0
  {
    if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
 8002c1a:	fb05 0303 	mla	r3, r5, r3, r0
  hltdc->State = HAL_LTDC_STATE_BUSY;  

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx)); 

  for(counter = 0U; (counter < CLUTSize); counter++)
 8002c1e:	4294      	cmp	r4, r2
 8002c20:	d01a      	beq.n	8002c58 <HAL_LTDC_ConfigCLUT+0x5c>
  {
    if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
 8002c22:	6c9d      	ldr	r5, [r3, #72]	; 0x48
 8002c24:	2d06      	cmp	r5, #6
 8002c26:	f851 5024 	ldr.w	r5, [r1, r4, lsl #2]
    {
      tmp  = (((counter + 16U*counter) << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
    }
    else
    { 
      tmp  = ((counter << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c2a:	bf15      	itete	ne
 8002c2c:	f831 6024 	ldrhne.w	r6, [r1, r4, lsl #2]

  for(counter = 0U; (counter < CLUTSize); counter++)
  {
    if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
    {
      tmp  = (((counter + 16U*counter) << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c30:	eb04 1604 	addeq.w	r6, r4, r4, lsl #4
    }
    else
    { 
      tmp  = ((counter << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c34:	f405 057f 	andne.w	r5, r5, #16711680	; 0xff0000

  for(counter = 0U; (counter < CLUTSize); counter++)
  {
    if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
    {
      tmp  = (((counter + 16U*counter) << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c38:	f025 457f 	biceq.w	r5, r5, #4278190080	; 0xff000000
    }
    else
    { 
      tmp  = ((counter << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c3c:	bf14      	ite	ne
 8002c3e:	4335      	orrne	r5, r6

  for(counter = 0U; (counter < CLUTSize); counter++)
  {
    if(hltdc->LayerCfg[LayerIdx].PixelFormat == LTDC_PIXEL_FORMAT_AL44)
    {
      tmp  = (((counter + 16U*counter) << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c40:	ea45 6506 	orreq.w	r5, r5, r6, lsl #24
    }
    pcounter = (uint32_t)pCLUT + sizeof(*pCLUT);
    pCLUT = (uint32_t *)pcounter;

    /* Specifies the C-LUT address and RGB value */
    LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
 8002c44:	6806      	ldr	r6, [r0, #0]
 8002c46:	f106 0684 	add.w	r6, r6, #132	; 0x84
 8002c4a:	443e      	add	r6, r7
    {
      tmp  = (((counter + 16U*counter) << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
    }
    else
    { 
      tmp  = ((counter << 24U) | ((uint32_t)(*pCLUT) & 0xFFU) | ((uint32_t)(*pCLUT) & 0xFF00U) | ((uint32_t)(*pCLUT) & 0xFF0000U));
 8002c4c:	bf18      	it	ne
 8002c4e:	ea45 6504 	orrne.w	r5, r5, r4, lsl #24
    }
    pcounter = (uint32_t)pCLUT + sizeof(*pCLUT);
    pCLUT = (uint32_t *)pcounter;

    /* Specifies the C-LUT address and RGB value */
    LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
 8002c52:	6435      	str	r5, [r6, #64]	; 0x40
  hltdc->State = HAL_LTDC_STATE_BUSY;  

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx)); 

  for(counter = 0U; (counter < CLUTSize); counter++)
 8002c54:	3401      	adds	r4, #1
 8002c56:	e7e2      	b.n	8002c1e <HAL_LTDC_ConfigCLUT+0x22>
    /* Specifies the C-LUT address and RGB value */
    LTDC_LAYER(hltdc, LayerIdx)->CLUTWR  = tmp;
  }
  
  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY; 
 8002c58:	2301      	movs	r3, #1
 8002c5a:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);  
 8002c5e:	2300      	movs	r3, #0
 8002c60:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0

  return HAL_OK;
 8002c64:	4618      	mov	r0, r3
 8002c66:	bdf0      	pop	{r4, r5, r6, r7, pc}
  uint32_t tmp = 0U;
  uint32_t counter = 0U;
  uint32_t pcounter = 0U;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002c68:	4620      	mov	r0, r4

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);  

  return HAL_OK;
}
 8002c6a:	bdf0      	pop	{r4, r5, r6, r7, pc}

08002c6c <HAL_LTDC_EnableColorKeying>:
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{  
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002c6c:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002c70:	2b01      	cmp	r3, #1
  *                   This parameter can be one of the following values:
  *                   0 or 1
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{  
 8002c72:	b510      	push	{r4, lr}
 8002c74:	f04f 0302 	mov.w	r3, #2
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002c78:	d010      	beq.n	8002c9c <HAL_LTDC_EnableColorKeying+0x30>

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Enable LTDC color keying by setting COLKEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8002c7a:	6802      	ldr	r2, [r0, #0]
{  
  /* Process locked */
  __HAL_LOCK(hltdc);

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002c7c:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Enable LTDC color keying by setting COLKEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_COLKEN;
 8002c80:	f102 0484 	add.w	r4, r2, #132	; 0x84
 8002c84:	01c9      	lsls	r1, r1, #7
 8002c86:	5863      	ldr	r3, [r4, r1]
 8002c88:	f043 0302 	orr.w	r3, r3, #2
 8002c8c:	5063      	str	r3, [r4, r1]

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002c8e:	2301      	movs	r3, #1
 8002c90:	6253      	str	r3, [r2, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY; 
 8002c92:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002c96:	2300      	movs	r3, #0
 8002c98:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_EnableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{  
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002c9c:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;  
}
 8002c9e:	bd10      	pop	{r4, pc}

08002ca0 <HAL_LTDC_DisableColorKeying>:
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002ca0:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002ca4:	2b01      	cmp	r3, #1
  *                   This parameter can be one of the following values:
  *                   0 or 1
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
 8002ca6:	b510      	push	{r4, lr}
 8002ca8:	f04f 0302 	mov.w	r3, #2
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002cac:	d010      	beq.n	8002cd0 <HAL_LTDC_DisableColorKeying+0x30>

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Disable LTDC color keying by setting COLKEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
 8002cae:	6802      	ldr	r2, [r0, #0]
{
  /* Process locked */
  __HAL_LOCK(hltdc);

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002cb0:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Disable LTDC color keying by setting COLKEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR &= ~(uint32_t)LTDC_LxCR_COLKEN;
 8002cb4:	f102 0484 	add.w	r4, r2, #132	; 0x84
 8002cb8:	01c9      	lsls	r1, r1, #7
 8002cba:	5863      	ldr	r3, [r4, r1]
 8002cbc:	f023 0302 	bic.w	r3, r3, #2
 8002cc0:	5063      	str	r3, [r4, r1]

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002cc2:	2301      	movs	r3, #1
 8002cc4:	6253      	str	r3, [r2, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY; 
 8002cc6:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002cca:	2300      	movs	r3, #0
 8002ccc:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_DisableColorKeying(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002cd0:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002cd2:	bd10      	pop	{r4, pc}

08002cd4 <HAL_LTDC_EnableCLUT>:
  */
HAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002cd4:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002cd8:	2b01      	cmp	r3, #1
  *                   This parameter can be one of the following values:
  *                   0 or 1
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{
 8002cda:	b510      	push	{r4, lr}
 8002cdc:	f04f 0302 	mov.w	r3, #2

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002ce0:	d010      	beq.n	8002d04 <HAL_LTDC_EnableCLUT+0x30>

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Disable LTDC color lookup table by setting CLUTEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
 8002ce2:	6802      	ldr	r2, [r0, #0]

  /* Process locked */
  __HAL_LOCK(hltdc);

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002ce4:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Disable LTDC color lookup table by setting CLUTEN bit */
  LTDC_LAYER(hltdc, LayerIdx)->CR |= (uint32_t)LTDC_LxCR_CLUTEN;
 8002ce8:	f102 0484 	add.w	r4, r2, #132	; 0x84
 8002cec:	01c9      	lsls	r1, r1, #7
 8002cee:	5863      	ldr	r3, [r4, r1]
 8002cf0:	f043 0310 	orr.w	r3, r3, #16
 8002cf4:	5063      	str	r3, [r4, r1]

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002cf6:	2301      	movs	r3, #1
 8002cf8:	6253      	str	r3, [r2, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY; 
 8002cfa:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002cfe:	2300      	movs	r3, #0
 8002d00:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0
  */
HAL_StatusTypeDef HAL_LTDC_EnableCLUT(LTDC_HandleTypeDef *hltdc, uint32_t LayerIdx)
{

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d04:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002d06:	bd10      	pop	{r4, pc}

08002d08 <HAL_LTDC_SetWindowPosition>:
  *                         This parameter can be one of the following values:
  *                         0 or 1
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
{
 8002d08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002d0c:	4617      	mov	r7, r2
  LTDC_LayerCfgTypeDef *pLayerCfg;
  
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d0e:	f890 20a0 	ldrb.w	r2, [r0, #160]	; 0xa0
 8002d12:	2a01      	cmp	r2, #1
  *                         This parameter can be one of the following values:
  *                         0 or 1
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
{
 8002d14:	4605      	mov	r5, r0
 8002d16:	f04f 0402 	mov.w	r4, #2
  LTDC_LayerCfgTypeDef *pLayerCfg;
  
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d1a:	d020      	beq.n	8002d5e <HAL_LTDC_SetWindowPosition+0x56>

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002d1c:	f880 40a1 	strb.w	r4, [r0, #161]	; 0xa1
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));

  /* update horizontal start/stop */
  pLayerCfg->WindowX0 = X0;
 8002d20:	2434      	movs	r4, #52	; 0x34
 8002d22:	435c      	muls	r4, r3
 8002d24:	1906      	adds	r6, r0, r4
HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;
  
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d26:	f04f 0801 	mov.w	r8, #1
 8002d2a:	f880 80a0 	strb.w	r8, [r0, #160]	; 0xa0
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));

  /* update horizontal start/stop */
  pLayerCfg->WindowX0 = X0;
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
 8002d2e:	6e32      	ldr	r2, [r6, #96]	; 0x60
  assert_param(IS_LTDC_HCONFIGSP(pLayerCfg->WindowX1));
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));

  /* update horizontal start/stop */
  pLayerCfg->WindowX0 = X0;
 8002d30:	63b1      	str	r1, [r6, #56]	; 0x38
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
 8002d32:	4411      	add	r1, r2

  /* update vertical start/stop */
  pLayerCfg->WindowY0 = Y0;
  pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
 8002d34:	6e72      	ldr	r2, [r6, #100]	; 0x64
  assert_param(IS_LTDC_VCONFIGST(pLayerCfg->WindowY0));
  assert_param(IS_LTDC_VCONFIGSP(pLayerCfg->WindowY1));

  /* update horizontal start/stop */
  pLayerCfg->WindowX0 = X0;
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;
 8002d36:	63f1      	str	r1, [r6, #60]	; 0x3c

  /* update vertical start/stop */
  pLayerCfg->WindowY0 = Y0;
 8002d38:	6437      	str	r7, [r6, #64]	; 0x40

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
 8002d3a:	f104 0138 	add.w	r1, r4, #56	; 0x38
  pLayerCfg->WindowX0 = X0;
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;

  /* update vertical start/stop */
  pLayerCfg->WindowY0 = Y0;
  pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
 8002d3e:	4417      	add	r7, r2

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002d40:	4401      	add	r1, r0
 8002d42:	461a      	mov	r2, r3
  pLayerCfg->WindowX0 = X0;
  pLayerCfg->WindowX1 = X0 + pLayerCfg->ImageWidth;

  /* update vertical start/stop */
  pLayerCfg->WindowY0 = Y0;
  pLayerCfg->WindowY1 = Y0 + pLayerCfg->ImageHeight;
 8002d44:	6477      	str	r7, [r6, #68]	; 0x44

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002d46:	f7ff fda6 	bl	8002896 <LTDC_SetConfig>

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002d4a:	682b      	ldr	r3, [r5, #0]

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002d4c:	2000      	movs	r0, #0

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002d4e:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002d52:	f885 80a1 	strb.w	r8, [r5, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002d56:	f885 00a0 	strb.w	r0, [r5, #160]	; 0xa0

  return HAL_OK;
 8002d5a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
HAL_StatusTypeDef HAL_LTDC_SetWindowPosition(LTDC_HandleTypeDef *hltdc, uint32_t X0, uint32_t Y0, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;
  
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d5e:	4620      	mov	r0, r4

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002d60:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002d64 <HAL_LTDC_SetAlpha>:
HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d64:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002d68:	2b01      	cmp	r3, #1
  *                   This parameter can be one of the following values:
  *                   0 or 1
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
{
 8002d6a:	b570      	push	{r4, r5, r6, lr}
 8002d6c:	f04f 0302 	mov.w	r3, #2
 8002d70:	4604      	mov	r4, r0
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d72:	d015      	beq.n	8002da0 <HAL_LTDC_SetAlpha+0x3c>

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002d74:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];

  /* Reconfigure the Alpha value */
  pLayerCfg->Alpha = Alpha;
 8002d78:	2334      	movs	r3, #52	; 0x34
 8002d7a:	4353      	muls	r3, r2
 8002d7c:	18c6      	adds	r6, r0, r3
HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002d7e:	2501      	movs	r5, #1
 8002d80:	f880 50a0 	strb.w	r5, [r0, #160]	; 0xa0

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];

  /* Reconfigure the Alpha value */
  pLayerCfg->Alpha = Alpha;
 8002d84:	64f1      	str	r1, [r6, #76]	; 0x4c
  /* Check the parameters */
  assert_param(IS_LTDC_ALPHA(Alpha));
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
 8002d86:	f103 0138 	add.w	r1, r3, #56	; 0x38

  /* Reconfigure the Alpha value */
  pLayerCfg->Alpha = Alpha;

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002d8a:	4401      	add	r1, r0
 8002d8c:	f7ff fd83 	bl	8002896 <LTDC_SetConfig>

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002d90:	6823      	ldr	r3, [r4, #0]

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002d92:	2000      	movs	r0, #0

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002d94:	625d      	str	r5, [r3, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002d96:	f884 50a1 	strb.w	r5, [r4, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002d9a:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0

  return HAL_OK;
 8002d9e:	bd70      	pop	{r4, r5, r6, pc}
HAL_StatusTypeDef HAL_LTDC_SetAlpha(LTDC_HandleTypeDef *hltdc, uint32_t Alpha, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002da0:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002da2:	bd70      	pop	{r4, r5, r6, pc}

08002da4 <HAL_LTDC_SetAddress>:
HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002da4:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002da8:	2b01      	cmp	r3, #1
  *                   This parameter can be one of the following values:
  *                   0 or 1.
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
{
 8002daa:	b570      	push	{r4, r5, r6, lr}
 8002dac:	f04f 0302 	mov.w	r3, #2
 8002db0:	4604      	mov	r4, r0
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002db2:	d015      	beq.n	8002de0 <HAL_LTDC_SetAddress+0x3c>

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002db4:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];

  /* Reconfigure the Address */
  pLayerCfg->FBStartAdress = Address;
 8002db8:	2334      	movs	r3, #52	; 0x34
 8002dba:	4353      	muls	r3, r2
 8002dbc:	18c6      	adds	r6, r0, r3
HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002dbe:	2501      	movs	r5, #1
 8002dc0:	f880 50a0 	strb.w	r5, [r0, #160]	; 0xa0

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];

  /* Reconfigure the Address */
  pLayerCfg->FBStartAdress = Address;
 8002dc4:	65f1      	str	r1, [r6, #92]	; 0x5c

  /* Check the parameters */
  assert_param(IS_LTDC_LAYER(LayerIdx));

  /* Get layer configuration from handle structure */
  pLayerCfg = &hltdc->LayerCfg[LayerIdx];
 8002dc6:	f103 0138 	add.w	r1, r3, #56	; 0x38

  /* Reconfigure the Address */
  pLayerCfg->FBStartAdress = Address;

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);
 8002dca:	4401      	add	r1, r0
 8002dcc:	f7ff fd63 	bl	8002896 <LTDC_SetConfig>

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002dd0:	6823      	ldr	r3, [r4, #0]

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002dd2:	2000      	movs	r0, #0

  /* Set LTDC parameters */
  LTDC_SetConfig(hltdc, pLayerCfg, LayerIdx);

  /* Sets the Reload type */
  hltdc->Instance->SRCR = LTDC_SRCR_IMR;
 8002dd4:	625d      	str	r5, [r3, #36]	; 0x24

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002dd6:	f884 50a1 	strb.w	r5, [r4, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002dda:	f884 00a0 	strb.w	r0, [r4, #160]	; 0xa0

  return HAL_OK;
 8002dde:	bd70      	pop	{r4, r5, r6, pc}
HAL_StatusTypeDef HAL_LTDC_SetAddress(LTDC_HandleTypeDef *hltdc, uint32_t Address, uint32_t LayerIdx)
{
  LTDC_LayerCfgTypeDef *pLayerCfg;

  /* Process locked */
  __HAL_LOCK(hltdc);
 8002de0:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002de2:	bd70      	pop	{r4, r5, r6, pc}

08002de4 <HAL_LTDC_ProgramLineEvent>:
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ProgramLineEvent(LTDC_HandleTypeDef *hltdc, uint32_t Line)
{
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002de4:	f890 30a0 	ldrb.w	r3, [r0, #160]	; 0xa0
 8002de8:	2b01      	cmp	r3, #1
 8002dea:	f04f 0302 	mov.w	r3, #2
 8002dee:	d00e      	beq.n	8002e0e <HAL_LTDC_ProgramLineEvent+0x2a>

  /* Check the parameters */
  assert_param(IS_LTDC_LIPOS(Line));

  /* Enable the Line interrupt */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_LI);
 8002df0:	6802      	ldr	r2, [r0, #0]
{
  /* Process locked */
  __HAL_LOCK(hltdc);

  /* Change LTDC peripheral state */
  hltdc->State = HAL_LTDC_STATE_BUSY;
 8002df2:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Check the parameters */
  assert_param(IS_LTDC_LIPOS(Line));

  /* Enable the Line interrupt */
  __HAL_LTDC_ENABLE_IT(hltdc, LTDC_IT_LI);
 8002df6:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8002df8:	f043 0301 	orr.w	r3, r3, #1
 8002dfc:	6353      	str	r3, [r2, #52]	; 0x34

  /* Sets the Line Interrupt position */
  LTDC->LIPCR = (uint32_t)Line;
 8002dfe:	4b05      	ldr	r3, [pc, #20]	; (8002e14 <HAL_LTDC_ProgramLineEvent+0x30>)
 8002e00:	6419      	str	r1, [r3, #64]	; 0x40

  /* Change the LTDC state*/
  hltdc->State = HAL_LTDC_STATE_READY;
 8002e02:	2301      	movs	r3, #1
 8002e04:	f880 30a1 	strb.w	r3, [r0, #161]	; 0xa1

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);
 8002e08:	2300      	movs	r3, #0
 8002e0a:	f880 30a0 	strb.w	r3, [r0, #160]	; 0xa0
  * @retval  HAL status
  */
HAL_StatusTypeDef HAL_LTDC_ProgramLineEvent(LTDC_HandleTypeDef *hltdc, uint32_t Line)
{
  /* Process locked */
  __HAL_LOCK(hltdc);
 8002e0e:	4618      	mov	r0, r3

  /* Process unlocked */
  __HAL_UNLOCK(hltdc);

  return HAL_OK;
}
 8002e10:	4770      	bx	lr
 8002e12:	bf00      	nop
 8002e14:	40016800 	.word	0x40016800

08002e18 <HAL_RCC_OscConfig>:
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002e18:	6803      	ldr	r3, [r0, #0]
  *         supported by this API. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8002e1a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8002e1e:	4604      	mov	r4, r0
 uint32_t tickstart = 0U;  
 
  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));
  /*------------------------------- HSE Configuration ------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002e20:	07d8      	lsls	r0, r3, #31
 8002e22:	d403      	bmi.n	8002e2c <HAL_RCC_OscConfig+0x14>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002e24:	6823      	ldr	r3, [r4, #0]
 8002e26:	0799      	lsls	r1, r3, #30
 8002e28:	d437      	bmi.n	8002e9a <HAL_RCC_OscConfig+0x82>
 8002e2a:	e087      	b.n	8002f3c <HAL_RCC_OscConfig+0x124>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8002e2c:	4ba7      	ldr	r3, [pc, #668]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8002e2e:	689a      	ldr	r2, [r3, #8]
 8002e30:	f002 020c 	and.w	r2, r2, #12
 8002e34:	2a04      	cmp	r2, #4
 8002e36:	d007      	beq.n	8002e48 <HAL_RCC_OscConfig+0x30>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002e38:	689a      	ldr	r2, [r3, #8]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));
    /* When the HSE is used as system clock or clock source for PLL in these cases HSE will not disabled */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||\
 8002e3a:	f002 020c 	and.w	r2, r2, #12
 8002e3e:	2a08      	cmp	r2, #8
 8002e40:	d10b      	bne.n	8002e5a <HAL_RCC_OscConfig+0x42>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSE)))
 8002e42:	685b      	ldr	r3, [r3, #4]
 8002e44:	025a      	lsls	r2, r3, #9
 8002e46:	d508      	bpl.n	8002e5a <HAL_RCC_OscConfig+0x42>
    {
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002e48:	4ba0      	ldr	r3, [pc, #640]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8002e4a:	681b      	ldr	r3, [r3, #0]
 8002e4c:	039b      	lsls	r3, r3, #14
 8002e4e:	d5e9      	bpl.n	8002e24 <HAL_RCC_OscConfig+0xc>
 8002e50:	6863      	ldr	r3, [r4, #4]
 8002e52:	2b00      	cmp	r3, #0
 8002e54:	d1e6      	bne.n	8002e24 <HAL_RCC_OscConfig+0xc>
      {
        return HAL_ERROR;
 8002e56:	2001      	movs	r0, #1
 8002e58:	e134      	b.n	80030c4 <HAL_RCC_OscConfig+0x2ac>
      }
    }
    else
    {
      /* Set the new HSE configuration ---------------------------------------*/
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002e5a:	4b9d      	ldr	r3, [pc, #628]	; (80030d0 <HAL_RCC_OscConfig+0x2b8>)
 8002e5c:	7922      	ldrb	r2, [r4, #4]
 8002e5e:	701a      	strb	r2, [r3, #0]
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
 8002e60:	6863      	ldr	r3, [r4, #4]
 8002e62:	b16b      	cbz	r3, 8002e80 <HAL_RCC_OscConfig+0x68>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002e64:	f7fe fe30 	bl	8001ac8 <HAL_GetTick>
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002e68:	4d98      	ldr	r5, [pc, #608]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
      
      /* Check the HSE State */
      if((RCC_OscInitStruct->HSEState) != RCC_HSE_OFF)
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002e6a:	4606      	mov	r6, r0
      
        /* Wait till HSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8002e6c:	682b      	ldr	r3, [r5, #0]
 8002e6e:	039f      	lsls	r7, r3, #14
 8002e70:	d4d8      	bmi.n	8002e24 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002e72:	f7fe fe29 	bl	8001ac8 <HAL_GetTick>
 8002e76:	1b80      	subs	r0, r0, r6
 8002e78:	2864      	cmp	r0, #100	; 0x64
 8002e7a:	d9f7      	bls.n	8002e6c <HAL_RCC_OscConfig+0x54>
          {
            return HAL_TIMEOUT;
 8002e7c:	2003      	movs	r0, #3
 8002e7e:	e121      	b.n	80030c4 <HAL_RCC_OscConfig+0x2ac>
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002e80:	f7fe fe22 	bl	8001ac8 <HAL_GetTick>

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002e84:	4d91      	ldr	r5, [pc, #580]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
        }
      }
      else
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002e86:	4606      	mov	r6, r0

        /* Wait till HSE is bypassed or disabled */
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 8002e88:	682b      	ldr	r3, [r5, #0]
 8002e8a:	0398      	lsls	r0, r3, #14
 8002e8c:	d5ca      	bpl.n	8002e24 <HAL_RCC_OscConfig+0xc>
        {
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8002e8e:	f7fe fe1b 	bl	8001ac8 <HAL_GetTick>
 8002e92:	1b80      	subs	r0, r0, r6
 8002e94:	2864      	cmp	r0, #100	; 0x64
 8002e96:	d9f7      	bls.n	8002e88 <HAL_RCC_OscConfig+0x70>
 8002e98:	e7f0      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8002e9a:	4b8c      	ldr	r3, [pc, #560]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8002e9c:	689a      	ldr	r2, [r3, #8]
 8002e9e:	f012 0f0c 	tst.w	r2, #12
 8002ea2:	d007      	beq.n	8002eb4 <HAL_RCC_OscConfig+0x9c>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002ea4:	689a      	ldr	r2, [r3, #8]
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));
    
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
 8002ea6:	f002 020c 	and.w	r2, r2, #12
 8002eaa:	2a08      	cmp	r2, #8
 8002eac:	d117      	bne.n	8002ede <HAL_RCC_OscConfig+0xc6>
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
 8002eae:	685b      	ldr	r3, [r3, #4]
 8002eb0:	0259      	lsls	r1, r3, #9
 8002eb2:	d414      	bmi.n	8002ede <HAL_RCC_OscConfig+0xc6>
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002eb4:	4b85      	ldr	r3, [pc, #532]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8002eb6:	681a      	ldr	r2, [r3, #0]
 8002eb8:	0792      	lsls	r2, r2, #30
 8002eba:	d502      	bpl.n	8002ec2 <HAL_RCC_OscConfig+0xaa>
 8002ebc:	68e2      	ldr	r2, [r4, #12]
 8002ebe:	2a01      	cmp	r2, #1
 8002ec0:	d1c9      	bne.n	8002e56 <HAL_RCC_OscConfig+0x3e>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002ec2:	681a      	ldr	r2, [r3, #0]
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002ec4:	21f8      	movs	r1, #248	; 0xf8
 8002ec6:	fa91 f1a1 	rbit	r1, r1
 8002eca:	6920      	ldr	r0, [r4, #16]
 8002ecc:	fab1 f181 	clz	r1, r1
 8002ed0:	fa00 f101 	lsl.w	r1, r0, r1
 8002ed4:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
 8002ed8:	430a      	orrs	r2, r1
 8002eda:	601a      	str	r2, [r3, #0]
    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||\
      ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && ((RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) == RCC_PLLCFGR_PLLSRC_HSI)))
    {
      /* When HSI is used as system clock it will not disabled */
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 8002edc:	e02e      	b.n	8002f3c <HAL_RCC_OscConfig+0x124>
      }
    }
    else
    {
      /* Check the HSI State */
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8002ede:	68e2      	ldr	r2, [r4, #12]
 8002ee0:	4b7c      	ldr	r3, [pc, #496]	; (80030d4 <HAL_RCC_OscConfig+0x2bc>)
 8002ee2:	b1ea      	cbz	r2, 8002f20 <HAL_RCC_OscConfig+0x108>
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();
 8002ee4:	2201      	movs	r2, #1
 8002ee6:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002ee8:	f7fe fdee 	bl	8001ac8 <HAL_GetTick>

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002eec:	4d77      	ldr	r5, [pc, #476]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Enable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_ENABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002eee:	4606      	mov	r6, r0

        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8002ef0:	682b      	ldr	r3, [r5, #0]
 8002ef2:	4876      	ldr	r0, [pc, #472]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8002ef4:	079b      	lsls	r3, r3, #30
 8002ef6:	d405      	bmi.n	8002f04 <HAL_RCC_OscConfig+0xec>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002ef8:	f7fe fde6 	bl	8001ac8 <HAL_GetTick>
 8002efc:	1b80      	subs	r0, r0, r6
 8002efe:	2802      	cmp	r0, #2
 8002f00:	d9f6      	bls.n	8002ef0 <HAL_RCC_OscConfig+0xd8>
 8002f02:	e7bb      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
            return HAL_TIMEOUT;
          }       
        } 
                
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002f04:	6803      	ldr	r3, [r0, #0]
 8002f06:	22f8      	movs	r2, #248	; 0xf8
 8002f08:	fa92 f2a2 	rbit	r2, r2
 8002f0c:	6921      	ldr	r1, [r4, #16]
 8002f0e:	fab2 f282 	clz	r2, r2
 8002f12:	fa01 f202 	lsl.w	r2, r1, r2
 8002f16:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 8002f1a:	4313      	orrs	r3, r2
 8002f1c:	6003      	str	r3, [r0, #0]
 8002f1e:	e00d      	b.n	8002f3c <HAL_RCC_OscConfig+0x124>
      }
      else
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();
 8002f20:	601a      	str	r2, [r3, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002f22:	f7fe fdd1 	bl	8001ac8 <HAL_GetTick>
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002f26:	4d69      	ldr	r5, [pc, #420]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
      {
        /* Disable the Internal High Speed oscillator (HSI). */
        __HAL_RCC_HSI_DISABLE();

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8002f28:	4606      	mov	r6, r0
      
        /* Wait till HSI is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 8002f2a:	682b      	ldr	r3, [r5, #0]
 8002f2c:	079f      	lsls	r7, r3, #30
 8002f2e:	d505      	bpl.n	8002f3c <HAL_RCC_OscConfig+0x124>
        {
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8002f30:	f7fe fdca 	bl	8001ac8 <HAL_GetTick>
 8002f34:	1b80      	subs	r0, r0, r6
 8002f36:	2802      	cmp	r0, #2
 8002f38:	d9f7      	bls.n	8002f2a <HAL_RCC_OscConfig+0x112>
 8002f3a:	e79f      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
        } 
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002f3c:	6823      	ldr	r3, [r4, #0]
 8002f3e:	071e      	lsls	r6, r3, #28
 8002f40:	d403      	bmi.n	8002f4a <HAL_RCC_OscConfig+0x132>
        }       
      } 
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/ 
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002f42:	6823      	ldr	r3, [r4, #0]
 8002f44:	075d      	lsls	r5, r3, #29
 8002f46:	d545      	bpl.n	8002fd4 <HAL_RCC_OscConfig+0x1bc>
 8002f48:	e01f      	b.n	8002f8a <HAL_RCC_OscConfig+0x172>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8002f4a:	6962      	ldr	r2, [r4, #20]
 8002f4c:	4b62      	ldr	r3, [pc, #392]	; (80030d8 <HAL_RCC_OscConfig+0x2c0>)
 8002f4e:	b172      	cbz	r2, 8002f6e <HAL_RCC_OscConfig+0x156>
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8002f50:	2201      	movs	r2, #1
 8002f52:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002f54:	f7fe fdb8 	bl	8001ac8 <HAL_GetTick>
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002f58:	4d5c      	ldr	r5, [pc, #368]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002f5a:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8002f5c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002f5e:	0798      	lsls	r0, r3, #30
 8002f60:	d4ef      	bmi.n	8002f42 <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002f62:	f7fe fdb1 	bl	8001ac8 <HAL_GetTick>
 8002f66:	1b80      	subs	r0, r0, r6
 8002f68:	2802      	cmp	r0, #2
 8002f6a:	d9f7      	bls.n	8002f5c <HAL_RCC_OscConfig+0x144>
 8002f6c:	e786      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
 8002f6e:	601a      	str	r2, [r3, #0]
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002f70:	f7fe fdaa 	bl	8001ac8 <HAL_GetTick>
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002f74:	4d55      	ldr	r5, [pc, #340]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
    {
      /* Disable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_DISABLE();
      
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002f76:	4606      	mov	r6, r0
      
      /* Wait till LSI is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 8002f78:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 8002f7a:	0799      	lsls	r1, r3, #30
 8002f7c:	d5e1      	bpl.n	8002f42 <HAL_RCC_OscConfig+0x12a>
      {
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8002f7e:	f7fe fda3 	bl	8001ac8 <HAL_GetTick>
 8002f82:	1b80      	subs	r0, r0, r6
 8002f84:	2802      	cmp	r0, #2
 8002f86:	d9f7      	bls.n	8002f78 <HAL_RCC_OscConfig+0x160>
 8002f88:	e778      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8002f8a:	2300      	movs	r3, #0
 8002f8c:	9301      	str	r3, [sp, #4]
 8002f8e:	4b4f      	ldr	r3, [pc, #316]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8002f90:	4d52      	ldr	r5, [pc, #328]	; (80030dc <HAL_RCC_OscConfig+0x2c4>)
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 8002f92:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8002f94:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002f98:	641a      	str	r2, [r3, #64]	; 0x40
 8002f9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002f9c:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002fa0:	9301      	str	r3, [sp, #4]
 8002fa2:	9b01      	ldr	r3, [sp, #4]
    
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 8002fa4:	682b      	ldr	r3, [r5, #0]
 8002fa6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002faa:	602b      	str	r3, [r5, #0]
    
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
 8002fac:	f7fe fd8c 	bl	8001ac8 <HAL_GetTick>
 8002fb0:	4606      	mov	r6, r0
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8002fb2:	682b      	ldr	r3, [r5, #0]
 8002fb4:	05da      	lsls	r2, r3, #23
 8002fb6:	d510      	bpl.n	8002fda <HAL_RCC_OscConfig+0x1c2>
        return HAL_TIMEOUT;
      }      
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002fb8:	4b49      	ldr	r3, [pc, #292]	; (80030e0 <HAL_RCC_OscConfig+0x2c8>)
 8002fba:	7a22      	ldrb	r2, [r4, #8]
 8002fbc:	701a      	strb	r2, [r3, #0]
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
 8002fbe:	68a3      	ldr	r3, [r4, #8]
 8002fc0:	b1bb      	cbz	r3, 8002ff2 <HAL_RCC_OscConfig+0x1da>
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002fc2:	f7fe fd81 	bl	8001ac8 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002fc6:	4d41      	ldr	r5, [pc, #260]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
    /* Check the LSE State */
    if((RCC_OscInitStruct->LSEState) != RCC_LSE_OFF)
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002fc8:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002fca:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8002fce:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8002fd0:	079b      	lsls	r3, r3, #30
 8002fd2:	d508      	bpl.n	8002fe6 <HAL_RCC_OscConfig+0x1ce>
    }
  }
  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8002fd4:	69a2      	ldr	r2, [r4, #24]
 8002fd6:	b9da      	cbnz	r2, 8003010 <HAL_RCC_OscConfig+0x1f8>
 8002fd8:	e059      	b.n	800308e <HAL_RCC_OscConfig+0x276>
    /* Wait for Backup domain Write protection enable */
    tickstart = HAL_GetTick();
    
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8002fda:	f7fe fd75 	bl	8001ac8 <HAL_GetTick>
 8002fde:	1b80      	subs	r0, r0, r6
 8002fe0:	2802      	cmp	r0, #2
 8002fe2:	d9e6      	bls.n	8002fb2 <HAL_RCC_OscConfig+0x19a>
 8002fe4:	e74a      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002fe6:	f7fe fd6f 	bl	8001ac8 <HAL_GetTick>
 8002fea:	1b80      	subs	r0, r0, r6
 8002fec:	42b8      	cmp	r0, r7
 8002fee:	d9ee      	bls.n	8002fce <HAL_RCC_OscConfig+0x1b6>
 8002ff0:	e744      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002ff2:	f7fe fd69 	bl	8001ac8 <HAL_GetTick>
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002ff6:	4d35      	ldr	r5, [pc, #212]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002ff8:	4606      	mov	r6, r0
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8002ffa:	f241 3788 	movw	r7, #5000	; 0x1388
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
      
      /* Wait till LSE is ready */  
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8002ffe:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8003000:	0798      	lsls	r0, r3, #30
 8003002:	d5e7      	bpl.n	8002fd4 <HAL_RCC_OscConfig+0x1bc>
      {
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8003004:	f7fe fd60 	bl	8001ac8 <HAL_GetTick>
 8003008:	1b80      	subs	r0, r0, r6
 800300a:	42b8      	cmp	r0, r7
 800300c:	d9f7      	bls.n	8002ffe <HAL_RCC_OscConfig+0x1e6>
 800300e:	e735      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8003010:	4d2e      	ldr	r5, [pc, #184]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8003012:	68ab      	ldr	r3, [r5, #8]
 8003014:	f003 030c 	and.w	r3, r3, #12
 8003018:	2b08      	cmp	r3, #8
 800301a:	f43f af1c 	beq.w	8002e56 <HAL_RCC_OscConfig+0x3e>
 800301e:	4e31      	ldr	r6, [pc, #196]	; (80030e4 <HAL_RCC_OscConfig+0x2cc>)
 8003020:	2300      	movs	r3, #0
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003022:	2a02      	cmp	r2, #2
        assert_param(IS_RCC_PLLN_VALUE(RCC_OscInitStruct->PLL.PLLN));
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8003024:	6033      	str	r3, [r6, #0]
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
  {
    /* Check if the PLL is used as system clock or not */
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
    { 
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8003026:	d141      	bne.n	80030ac <HAL_RCC_OscConfig+0x294>
      
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
        
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003028:	f7fe fd4e 	bl	8001ac8 <HAL_GetTick>
 800302c:	4680      	mov	r8, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 800302e:	682b      	ldr	r3, [r5, #0]
 8003030:	4f26      	ldr	r7, [pc, #152]	; (80030cc <HAL_RCC_OscConfig+0x2b4>)
 8003032:	0199      	lsls	r1, r3, #6
 8003034:	d42d      	bmi.n	8003092 <HAL_RCC_OscConfig+0x27a>
 8003036:	f647 72c0 	movw	r2, #32704	; 0x7fc0
 800303a:	fa92 f2a2 	rbit	r2, r2
 800303e:	f44f 3340 	mov.w	r3, #196608	; 0x30000
            return HAL_TIMEOUT;
          }
        }        

        /* Configure the main PLL clock source, multiplication and division factors. */
        WRITE_REG(RCC->PLLCFGR, (RCC_OscInitStruct->PLL.PLLSource                                            | \
 8003042:	fab2 fe82 	clz	lr, r2
 8003046:	fa93 f3a3 	rbit	r3, r3
 800304a:	f04f 6270 	mov.w	r2, #251658240	; 0xf000000
 800304e:	fab3 f583 	clz	r5, r3
 8003052:	fa92 f2a2 	rbit	r2, r2
 8003056:	69e0      	ldr	r0, [r4, #28]
 8003058:	6a23      	ldr	r3, [r4, #32]
 800305a:	fab2 f182 	clz	r1, r2
 800305e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8003060:	4303      	orrs	r3, r0
 8003062:	fa02 f20e 	lsl.w	r2, r2, lr
 8003066:	ea43 0002 	orr.w	r0, r3, r2
 800306a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800306c:	085a      	lsrs	r2, r3, #1
 800306e:	3a01      	subs	r2, #1
 8003070:	fa02 f305 	lsl.w	r3, r2, r5
 8003074:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003076:	4303      	orrs	r3, r0
 8003078:	408a      	lsls	r2, r1
 800307a:	4313      	orrs	r3, r2
 800307c:	607b      	str	r3, [r7, #4]
                                 RCC_OscInitStruct->PLL.PLLM                                                 | \
                                 (RCC_OscInitStruct->PLL.PLLN << POSITION_VAL(RCC_PLLCFGR_PLLN))             | \
                                 (((RCC_OscInitStruct->PLL.PLLP >> 1U) - 1U) << POSITION_VAL(RCC_PLLCFGR_PLLP)) | \
                                 (RCC_OscInitStruct->PLL.PLLQ << POSITION_VAL(RCC_PLLCFGR_PLLQ))));
        /* Enable the main PLL. */
        __HAL_RCC_PLL_ENABLE();
 800307e:	2301      	movs	r3, #1
 8003080:	6033      	str	r3, [r6, #0]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8003082:	f7fe fd21 	bl	8001ac8 <HAL_GetTick>
 8003086:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 8003088:	683b      	ldr	r3, [r7, #0]
 800308a:	019a      	lsls	r2, r3, #6
 800308c:	d508      	bpl.n	80030a0 <HAL_RCC_OscConfig+0x288>
    else
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
 800308e:	2000      	movs	r0, #0
 8003090:	e018      	b.n	80030c4 <HAL_RCC_OscConfig+0x2ac>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8003092:	f7fe fd19 	bl	8001ac8 <HAL_GetTick>
 8003096:	ebc8 0000 	rsb	r0, r8, r0
 800309a:	2802      	cmp	r0, #2
 800309c:	d9c7      	bls.n	800302e <HAL_RCC_OscConfig+0x216>
 800309e:	e6ed      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
        tickstart = HAL_GetTick();
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80030a0:	f7fe fd12 	bl	8001ac8 <HAL_GetTick>
 80030a4:	1b00      	subs	r0, r0, r4
 80030a6:	2802      	cmp	r0, #2
 80030a8:	d9ee      	bls.n	8003088 <HAL_RCC_OscConfig+0x270>
 80030aa:	e6e7      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80030ac:	f7fe fd0c 	bl	8001ac8 <HAL_GetTick>
 80030b0:	4604      	mov	r4, r0
        
        /* Wait till PLL is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != RESET)
 80030b2:	682b      	ldr	r3, [r5, #0]
 80030b4:	019b      	lsls	r3, r3, #6
 80030b6:	d5ea      	bpl.n	800308e <HAL_RCC_OscConfig+0x276>
        {
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80030b8:	f7fe fd06 	bl	8001ac8 <HAL_GetTick>
 80030bc:	1b00      	subs	r0, r0, r4
 80030be:	2802      	cmp	r0, #2
 80030c0:	d9f7      	bls.n	80030b2 <HAL_RCC_OscConfig+0x29a>
 80030c2:	e6db      	b.n	8002e7c <HAL_RCC_OscConfig+0x64>
    {
      return HAL_ERROR;
    }
  }
  return HAL_OK;
}
 80030c4:	b002      	add	sp, #8
 80030c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80030ca:	bf00      	nop
 80030cc:	40023800 	.word	0x40023800
 80030d0:	40023802 	.word	0x40023802
 80030d4:	42470000 	.word	0x42470000
 80030d8:	42470e80 	.word	0x42470e80
 80030dc:	40007000 	.word	0x40007000
 80030e0:	40023870 	.word	0x40023870
 80030e4:	42470060 	.word	0x42470060

080030e8 <HAL_RCC_GetSysClockFreq>:
{
  uint32_t pllm = 0U, pllvco = 0U, pllp = 0U;
  uint32_t sysclockfreq = 0U;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80030e8:	491b      	ldr	r1, [pc, #108]	; (8003158 <HAL_RCC_GetSysClockFreq+0x70>)
 80030ea:	688b      	ldr	r3, [r1, #8]
 80030ec:	f003 030c 	and.w	r3, r3, #12
 80030f0:	2b04      	cmp	r3, #4
 80030f2:	d02c      	beq.n	800314e <HAL_RCC_GetSysClockFreq+0x66>
 80030f4:	2b08      	cmp	r3, #8
 80030f6:	d12c      	bne.n	8003152 <HAL_RCC_GetSysClockFreq+0x6a>
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80030f8:	6848      	ldr	r0, [r1, #4]
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 80030fa:	684b      	ldr	r3, [r1, #4]
    }
    case RCC_CFGR_SWS_PLL:  /* PLL used as system clock  source */
    {
      /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLP */
      pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
 80030fc:	f000 003f 	and.w	r0, r0, #63	; 0x3f
      if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_HSI)
 8003100:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8003104:	f647 72c0 	movw	r2, #32704	; 0x7fc0
      {
        /* HSE used as PLL clock source */
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
 8003108:	684b      	ldr	r3, [r1, #4]
 800310a:	fa92 f2a2 	rbit	r2, r2
 800310e:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8003112:	fab2 f282 	clz	r2, r2
 8003116:	ea01 0103 	and.w	r1, r1, r3
 800311a:	fa21 f102 	lsr.w	r1, r1, r2
 800311e:	bf14      	ite	ne
 8003120:	4a0e      	ldrne	r2, [pc, #56]	; (800315c <HAL_RCC_GetSysClockFreq+0x74>)
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 8003122:	4a0f      	ldreq	r2, [pc, #60]	; (8003160 <HAL_RCC_GetSysClockFreq+0x78>)
 8003124:	fbb2 f0f0 	udiv	r0, r2, r0
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 8003128:	4a0b      	ldr	r2, [pc, #44]	; (8003158 <HAL_RCC_GetSysClockFreq+0x70>)
        pllvco = ((HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));
      }
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
 800312a:	fb00 f301 	mul.w	r3, r0, r1
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 800312e:	6852      	ldr	r2, [r2, #4]
 8003130:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8003134:	fa90 f0a0 	rbit	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8003138:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
      else
      {
        /* HSI used as PLL clock source */
        pllvco = ((HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> POSITION_VAL(RCC_PLLCFGR_PLLN)));    
      }
      pllp = ((((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >> POSITION_VAL(RCC_PLLCFGR_PLLP)) + 1U) *2U);
 800313c:	fab0 f080 	clz	r0, r0
      
      sysclockfreq = pllvco/pllp;
 8003140:	fa22 f000 	lsr.w	r0, r2, r0
 8003144:	3001      	adds	r0, #1
 8003146:	0040      	lsls	r0, r0, #1
 8003148:	fbb3 f0f0 	udiv	r0, r3, r0
 800314c:	4770      	bx	lr
      sysclockfreq = HSI_VALUE;
       break;
    }
    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
    {
      sysclockfreq = HSE_VALUE;
 800314e:	4803      	ldr	r0, [pc, #12]	; (800315c <HAL_RCC_GetSysClockFreq+0x74>)
 8003150:	4770      	bx	lr
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */
    {
      sysclockfreq = HSI_VALUE;
 8003152:	4803      	ldr	r0, [pc, #12]	; (8003160 <HAL_RCC_GetSysClockFreq+0x78>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8003154:	4770      	bx	lr
 8003156:	bf00      	nop
 8003158:	40023800 	.word	0x40023800
 800315c:	007a1200 	.word	0x007a1200
 8003160:	00f42400 	.word	0x00f42400

08003164 <HAL_RCC_ClockConfig>:
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8003164:	4b55      	ldr	r3, [pc, #340]	; (80032bc <HAL_RCC_ClockConfig+0x158>)
 8003166:	681a      	ldr	r2, [r3, #0]
 8003168:	f002 020f 	and.w	r2, r2, #15
 800316c:	428a      	cmp	r2, r1
  *         HPRE[3:0] bits to ensure that HCLK not exceed the maximum allowed frequency
  *         (for more details refer to section above "Initialization/de-initialization functions")
  * @retval None
  */
HAL_StatusTypeDef HAL_RCC_ClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t FLatency)
{
 800316e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003172:	4605      	mov	r5, r0
 8003174:	460e      	mov	r6, r1
  /* To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    must be correctly programmed according to the frequency of the CPU clock 
    (HCLK) and the supply voltage of the device. */
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
 8003176:	d30a      	bcc.n	800318e <HAL_RCC_ClockConfig+0x2a>
      return HAL_ERROR;
    }
  }
 
  /*-------------------------- HCLK Configuration --------------------------*/
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8003178:	6829      	ldr	r1, [r5, #0]
 800317a:	0788      	lsls	r0, r1, #30
 800317c:	d511      	bpl.n	80031a2 <HAL_RCC_ClockConfig+0x3e>
  {
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800317e:	4850      	ldr	r0, [pc, #320]	; (80032c0 <HAL_RCC_ClockConfig+0x15c>)
 8003180:	6883      	ldr	r3, [r0, #8]
 8003182:	f023 02f0 	bic.w	r2, r3, #240	; 0xf0
 8003186:	68ab      	ldr	r3, [r5, #8]
 8003188:	4313      	orrs	r3, r2
 800318a:	6083      	str	r3, [r0, #8]
 800318c:	e009      	b.n	80031a2 <HAL_RCC_ClockConfig+0x3e>
  
  /* Increasing the number of wait states because of higher CPU frequency */
  if(FLatency > (FLASH->ACR & FLASH_ACR_LATENCY))
  {    
    /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 800318e:	b2ca      	uxtb	r2, r1
 8003190:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 8003192:	681b      	ldr	r3, [r3, #0]
 8003194:	f003 030f 	and.w	r3, r3, #15
 8003198:	4299      	cmp	r1, r3
 800319a:	d0ed      	beq.n	8003178 <HAL_RCC_ClockConfig+0x14>
    {
      return HAL_ERROR;
 800319c:	2001      	movs	r0, #1
 800319e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    assert_param(IS_RCC_HCLK(RCC_ClkInitStruct->AHBCLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
  }
  
  /*------------------------- SYSCLK Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 80031a2:	07c9      	lsls	r1, r1, #31
 80031a4:	d406      	bmi.n	80031b4 <HAL_RCC_ClockConfig+0x50>
      }
    }
  }    
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
 80031a6:	4b45      	ldr	r3, [pc, #276]	; (80032bc <HAL_RCC_ClockConfig+0x158>)
 80031a8:	681a      	ldr	r2, [r3, #0]
 80031aa:	f002 020f 	and.w	r2, r2, #15
 80031ae:	4296      	cmp	r6, r2
 80031b0:	d351      	bcc.n	8003256 <HAL_RCC_ClockConfig+0xf2>
 80031b2:	e057      	b.n	8003264 <HAL_RCC_ClockConfig+0x100>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
  {    
    assert_param(IS_RCC_SYSCLKSOURCE(RCC_ClkInitStruct->SYSCLKSource));
    
    /* HSE is selected as System Clock Source */
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80031b4:	686b      	ldr	r3, [r5, #4]
 80031b6:	4a42      	ldr	r2, [pc, #264]	; (80032c0 <HAL_RCC_ClockConfig+0x15c>)
 80031b8:	2b01      	cmp	r3, #1
 80031ba:	d103      	bne.n	80031c4 <HAL_RCC_ClockConfig+0x60>
    {
      /* Check the HSE ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80031bc:	6812      	ldr	r2, [r2, #0]
 80031be:	f412 3f00 	tst.w	r2, #131072	; 0x20000
 80031c2:	e008      	b.n	80031d6 <HAL_RCC_ClockConfig+0x72>
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 80031c4:	1e99      	subs	r1, r3, #2
 80031c6:	2901      	cmp	r1, #1
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80031c8:	6812      	ldr	r2, [r2, #0]
      {
        return HAL_ERROR;
      }
    }
    /* PLL is selected as System Clock Source */
    else if((RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)   || 
 80031ca:	d802      	bhi.n	80031d2 <HAL_RCC_ClockConfig+0x6e>
            (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK))
    {
      /* Check the PLL ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == RESET)
 80031cc:	f012 7f00 	tst.w	r2, #33554432	; 0x2000000
 80031d0:	e001      	b.n	80031d6 <HAL_RCC_ClockConfig+0x72>
    }
    /* HSI is selected as System Clock Source */
    else
    {
      /* Check the HSI ready flag */  
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 80031d2:	f012 0f02 	tst.w	r2, #2
 80031d6:	d0e1      	beq.n	800319c <HAL_RCC_ClockConfig+0x38>
      {
        return HAL_ERROR;
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 80031d8:	4c39      	ldr	r4, [pc, #228]	; (80032c0 <HAL_RCC_ClockConfig+0x15c>)
 80031da:	68a2      	ldr	r2, [r4, #8]
 80031dc:	f022 0203 	bic.w	r2, r2, #3
 80031e0:	4313      	orrs	r3, r2
 80031e2:	60a3      	str	r3, [r4, #8]
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80031e4:	f7fe fc70 	bl	8001ac8 <HAL_GetTick>
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80031e8:	686b      	ldr	r3, [r5, #4]
 80031ea:	2b01      	cmp	r3, #1
      }
    }
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80031ec:	4607      	mov	r7, r0
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80031ee:	f241 3888 	movw	r8, #5000	; 0x1388
    
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
    /* Get Start Tick*/
    tickstart = HAL_GetTick();
    
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80031f2:	d10c      	bne.n	800320e <HAL_RCC_ClockConfig+0xaa>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSE)
 80031f4:	68a3      	ldr	r3, [r4, #8]
 80031f6:	f003 030c 	and.w	r3, r3, #12
 80031fa:	2b04      	cmp	r3, #4
 80031fc:	d0d3      	beq.n	80031a6 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 80031fe:	f7fe fc63 	bl	8001ac8 <HAL_GetTick>
 8003202:	1bc0      	subs	r0, r0, r7
 8003204:	4540      	cmp	r0, r8
 8003206:	d9f5      	bls.n	80031f4 <HAL_RCC_ClockConfig+0x90>
        {
          return HAL_TIMEOUT;
 8003208:	2003      	movs	r0, #3
 800320a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800320e:	2b02      	cmp	r3, #2
 8003210:	d10a      	bne.n	8003228 <HAL_RCC_ClockConfig+0xc4>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 8003212:	68a3      	ldr	r3, [r4, #8]
 8003214:	f003 030c 	and.w	r3, r3, #12
 8003218:	2b08      	cmp	r3, #8
 800321a:	d0c4      	beq.n	80031a6 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 800321c:	f7fe fc54 	bl	8001ac8 <HAL_GetTick>
 8003220:	1bc0      	subs	r0, r0, r7
 8003222:	4540      	cmp	r0, r8
 8003224:	d9f5      	bls.n	8003212 <HAL_RCC_ClockConfig+0xae>
 8003226:	e7ef      	b.n	8003208 <HAL_RCC_ClockConfig+0xa4>
        {
          return HAL_TIMEOUT;
        }
      }
    }
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLRCLK)
 8003228:	2b03      	cmp	r3, #3
 800322a:	d10f      	bne.n	800324c <HAL_RCC_ClockConfig+0xe8>
    {
      while (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLRCLK)
 800322c:	68a3      	ldr	r3, [r4, #8]
 800322e:	f003 030c 	and.w	r3, r3, #12
 8003232:	2b0c      	cmp	r3, #12
 8003234:	d0b7      	beq.n	80031a6 <HAL_RCC_ClockConfig+0x42>
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003236:	f7fe fc47 	bl	8001ac8 <HAL_GetTick>
 800323a:	1bc0      	subs	r0, r0, r7
 800323c:	4540      	cmp	r0, r8
 800323e:	d9f5      	bls.n	800322c <HAL_RCC_ClockConfig+0xc8>
 8003240:	e7e2      	b.n	8003208 <HAL_RCC_ClockConfig+0xa4>
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
      {
        if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8003242:	f7fe fc41 	bl	8001ac8 <HAL_GetTick>
 8003246:	1bc0      	subs	r0, r0, r7
 8003248:	4540      	cmp	r0, r8
 800324a:	d8dd      	bhi.n	8003208 <HAL_RCC_ClockConfig+0xa4>
        }
      }
    }
    else
    {
      while(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_HSI)
 800324c:	68a3      	ldr	r3, [r4, #8]
 800324e:	f013 0f0c 	tst.w	r3, #12
 8003252:	d1f6      	bne.n	8003242 <HAL_RCC_ClockConfig+0xde>
 8003254:	e7a7      	b.n	80031a6 <HAL_RCC_ClockConfig+0x42>
  
  /* Decreasing the number of wait states because of lower CPU frequency */
  if(FLatency < (FLASH->ACR & FLASH_ACR_LATENCY))
  { 
     /* Program the new number of wait states to the LATENCY bits in the FLASH_ACR register */
    __HAL_FLASH_SET_LATENCY(FLatency);
 8003256:	b2f2      	uxtb	r2, r6
 8003258:	701a      	strb	r2, [r3, #0]
    
    /* Check that the new number of wait states is taken into account to access the Flash
    memory by reading the FLASH_ACR register */
    if((FLASH->ACR & FLASH_ACR_LATENCY) != FLatency)
 800325a:	681b      	ldr	r3, [r3, #0]
 800325c:	f003 030f 	and.w	r3, r3, #15
 8003260:	429e      	cmp	r6, r3
 8003262:	d19b      	bne.n	800319c <HAL_RCC_ClockConfig+0x38>
      return HAL_ERROR;
    }
 }

  /*-------------------------- PCLK1 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003264:	6829      	ldr	r1, [r5, #0]
 8003266:	074a      	lsls	r2, r1, #29
 8003268:	d506      	bpl.n	8003278 <HAL_RCC_ClockConfig+0x114>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB1CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800326a:	4815      	ldr	r0, [pc, #84]	; (80032c0 <HAL_RCC_ClockConfig+0x15c>)
 800326c:	6883      	ldr	r3, [r0, #8]
 800326e:	f423 52e0 	bic.w	r2, r3, #7168	; 0x1c00
 8003272:	68eb      	ldr	r3, [r5, #12]
 8003274:	4313      	orrs	r3, r2
 8003276:	6083      	str	r3, [r0, #8]
  }
  
  /*-------------------------- PCLK2 Configuration ---------------------------*/ 
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003278:	070b      	lsls	r3, r1, #28
 800327a:	d507      	bpl.n	800328c <HAL_RCC_ClockConfig+0x128>
  {
    assert_param(IS_RCC_PCLK(RCC_ClkInitStruct->APB2CLKDivider));
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800327c:	4a10      	ldr	r2, [pc, #64]	; (80032c0 <HAL_RCC_ClockConfig+0x15c>)
 800327e:	6929      	ldr	r1, [r5, #16]
 8003280:	6893      	ldr	r3, [r2, #8]
 8003282:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8003286:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 800328a:	6093      	str	r3, [r2, #8]
  }

  /* Update the SystemCoreClock global variable */
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> POSITION_VAL(RCC_CFGR_HPRE)];
 800328c:	f7ff ff2c 	bl	80030e8 <HAL_RCC_GetSysClockFreq>
 8003290:	4b0b      	ldr	r3, [pc, #44]	; (80032c0 <HAL_RCC_ClockConfig+0x15c>)
 8003292:	22f0      	movs	r2, #240	; 0xf0
 8003294:	689b      	ldr	r3, [r3, #8]
 8003296:	fa92 f2a2 	rbit	r2, r2
 800329a:	fab2 f282 	clz	r2, r2
 800329e:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80032a2:	40d3      	lsrs	r3, r2
 80032a4:	4a07      	ldr	r2, [pc, #28]	; (80032c4 <HAL_RCC_ClockConfig+0x160>)
 80032a6:	5cd3      	ldrb	r3, [r2, r3]
 80032a8:	40d8      	lsrs	r0, r3
 80032aa:	4b07      	ldr	r3, [pc, #28]	; (80032c8 <HAL_RCC_ClockConfig+0x164>)
 80032ac:	6018      	str	r0, [r3, #0]

  /* Configure the source of time base considering new system clocks settings*/
  HAL_InitTick (TICK_INT_PRIORITY);
 80032ae:	2000      	movs	r0, #0
 80032b0:	f7fe fbd4 	bl	8001a5c <HAL_InitTick>
  
  return HAL_OK;
 80032b4:	2000      	movs	r0, #0
}
 80032b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80032ba:	bf00      	nop
 80032bc:	40023c00 	.word	0x40023c00
 80032c0:	40023800 	.word	0x40023800
 80032c4:	08009bcb 	.word	0x08009bcb
 80032c8:	20000058 	.word	0x20000058

080032cc <HAL_RCC_GetPCLK1Freq>:
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{  
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE1)>> POSITION_VAL(RCC_CFGR_PPRE1)]);
 80032cc:	4b08      	ldr	r3, [pc, #32]	; (80032f0 <HAL_RCC_GetPCLK1Freq+0x24>)
 80032ce:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 80032d2:	689b      	ldr	r3, [r3, #8]
 80032d4:	fa92 f2a2 	rbit	r2, r2
 80032d8:	fab2 f282 	clz	r2, r2
 80032dc:	f403 53e0 	and.w	r3, r3, #7168	; 0x1c00
 80032e0:	40d3      	lsrs	r3, r2
 80032e2:	4a04      	ldr	r2, [pc, #16]	; (80032f4 <HAL_RCC_GetPCLK1Freq+0x28>)
 80032e4:	5cd3      	ldrb	r3, [r2, r3]
 80032e6:	4a04      	ldr	r2, [pc, #16]	; (80032f8 <HAL_RCC_GetPCLK1Freq+0x2c>)
 80032e8:	6810      	ldr	r0, [r2, #0]
}
 80032ea:	40d8      	lsrs	r0, r3
 80032ec:	4770      	bx	lr
 80032ee:	bf00      	nop
 80032f0:	40023800 	.word	0x40023800
 80032f4:	08009bcb 	.word	0x08009bcb
 80032f8:	20000058 	.word	0x20000058

080032fc <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBAHBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2)>> POSITION_VAL(RCC_CFGR_PPRE2)]);
 80032fc:	4b08      	ldr	r3, [pc, #32]	; (8003320 <HAL_RCC_GetPCLK2Freq+0x24>)
 80032fe:	f44f 4260 	mov.w	r2, #57344	; 0xe000
 8003302:	689b      	ldr	r3, [r3, #8]
 8003304:	fa92 f2a2 	rbit	r2, r2
 8003308:	fab2 f282 	clz	r2, r2
 800330c:	f403 4360 	and.w	r3, r3, #57344	; 0xe000
 8003310:	40d3      	lsrs	r3, r2
 8003312:	4a04      	ldr	r2, [pc, #16]	; (8003324 <HAL_RCC_GetPCLK2Freq+0x28>)
 8003314:	5cd3      	ldrb	r3, [r2, r3]
 8003316:	4a04      	ldr	r2, [pc, #16]	; (8003328 <HAL_RCC_GetPCLK2Freq+0x2c>)
 8003318:	6810      	ldr	r0, [r2, #0]
} 
 800331a:	40d8      	lsrs	r0, r3
 800331c:	4770      	bx	lr
 800331e:	bf00      	nop
 8003320:	40023800 	.word	0x40023800
 8003324:	08009bcb 	.word	0x08009bcb
 8003328:	20000058 	.word	0x20000058

0800332c <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 800332c:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  
  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/
  /*----------------------- Common configuration SAI/I2S ----------------------*/
  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division   
     factor is common parameters for both peripherals */ 
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) || 
 8003330:	6803      	ldr	r3, [r0, #0]
 8003332:	079a      	lsls	r2, r3, #30
  *         the backup registers) and RCC_BDCR register are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8003334:	4604      	mov	r4, r0
  
  /*----------------------- SAI/I2S Configuration (PLLI2S) -------------------*/
  /*----------------------- Common configuration SAI/I2S ----------------------*/
  /* In Case of SAI or I2S Clock Configuration through PLLI2S, PLLI2SN division   
     factor is common parameters for both peripherals */ 
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S) || 
 8003336:	d105      	bne.n	8003344 <HAL_RCCEx_PeriphCLKConfig+0x18>
    
  /*----------------------- SAI/LTDC Configuration (PLLSAI) ------------------*/
  /*----------------------- Common configuration SAI/LTDC --------------------*/
  /* In Case of SAI or LTDC Clock Configuration through PLLSAI, PLLSAIN division
     factor is common parameters for both peripherals */ 
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == RCC_PERIPHCLK_SAI_PLLSAI) || 
 8003338:	6823      	ldr	r3, [r4, #0]
 800333a:	f013 0f0c 	tst.w	r3, #12
 800333e:	f000 80d5 	beq.w	80034ec <HAL_RCCEx_PeriphCLKConfig+0x1c0>
 8003342:	e057      	b.n	80033f4 <HAL_RCCEx_PeriphCLKConfig+0xc8>
  {
    /* check for Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
        
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();    
 8003344:	4da5      	ldr	r5, [pc, #660]	; (80035dc <HAL_RCCEx_PeriphCLKConfig+0x2b0>)
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8003346:	4ea6      	ldr	r6, [pc, #664]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
  {
    /* check for Parameters */
    assert_param(IS_RCC_PLLI2SN_VALUE(PeriphClkInit->PLLI2S.PLLI2SN));
        
    /* Disable the PLLI2S */
    __HAL_RCC_PLLI2S_DISABLE();    
 8003348:	2300      	movs	r3, #0
 800334a:	602b      	str	r3, [r5, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 800334c:	f7fe fbbc 	bl	8001ac8 <HAL_GetTick>
 8003350:	4607      	mov	r7, r0
    /* Wait till PLLI2S is disabled */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  != RESET)
 8003352:	6833      	ldr	r3, [r6, #0]
 8003354:	011b      	lsls	r3, r3, #4
 8003356:	d506      	bpl.n	8003366 <HAL_RCCEx_PeriphCLKConfig+0x3a>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 8003358:	f7fe fbb6 	bl	8001ac8 <HAL_GetTick>
 800335c:	1bc0      	subs	r0, r0, r7
 800335e:	2802      	cmp	r0, #2
 8003360:	d9f7      	bls.n	8003352 <HAL_RCCEx_PeriphCLKConfig+0x26>
      {
        /* return in case of Timeout detected */
        return HAL_TIMEOUT;
 8003362:	2003      	movs	r0, #3
 8003364:	e137      	b.n	80035d6 <HAL_RCCEx_PeriphCLKConfig+0x2aa>
    }
    
    /*---------------------------- I2S configuration -------------------------------*/
    /* In Case of I2S Clock Configuration through PLLI2S, PLLI2SR must be added   
      only for I2S configuration */     
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == (RCC_PERIPHCLK_I2S))
 8003366:	6820      	ldr	r0, [r4, #0]
 8003368:	07c7      	lsls	r7, r0, #31
 800336a:	d514      	bpl.n	8003396 <HAL_RCCEx_PeriphCLKConfig+0x6a>
 800336c:	f647 71c0 	movw	r1, #32704	; 0x7fc0
 8003370:	fa91 f1a1 	rbit	r1, r1
 8003374:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
      /* check for Parameters */
      assert_param(IS_RCC_PLLI2SR_VALUE(PeriphClkInit->PLLI2S.PLLI2SR));
      /* Configure the PLLI2S division factors */
      /* PLLI2S_VCO = f(VCO clock) = f(PLLI2S clock input) * (PLLI2SN/PLLM) */
      /* I2SCLK = f(PLLI2S clock output) = f(VCO clock) / PLLI2SR */
      __HAL_RCC_PLLI2S_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SR);
 8003378:	fab1 f181 	clz	r1, r1
 800337c:	fa93 f3a3 	rbit	r3, r3
 8003380:	fab3 f283 	clz	r2, r3
 8003384:	6863      	ldr	r3, [r4, #4]
 8003386:	fa03 f101 	lsl.w	r1, r3, r1
 800338a:	68a3      	ldr	r3, [r4, #8]
 800338c:	4093      	lsls	r3, r2
 800338e:	4a94      	ldr	r2, [pc, #592]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003390:	430b      	orrs	r3, r1
 8003392:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
    }
  
    /*---------------------------- SAI configuration -------------------------------*/ 
    /* In Case of SAI Clock Configuration through PLLI2S, PLLI2SQ and PLLI2S_DIVQ must  
       be added only for SAI configuration */     
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLI2S) == (RCC_PERIPHCLK_SAI_PLLI2S))
 8003396:	0786      	lsls	r6, r0, #30
 8003398:	d51d      	bpl.n	80033d6 <HAL_RCCEx_PeriphCLKConfig+0xaa>
      /* Check the PLLI2S division factors */
      assert_param(IS_RCC_PLLI2SQ_VALUE(PeriphClkInit->PLLI2S.PLLI2SQ));
      assert_param(IS_RCC_PLLI2S_DIVQ_VALUE(PeriphClkInit->PLLI2SDivQ));
      
      /* Read PLLI2SR value from PLLI2SCFGR register (this value is not need for SAI configuration) */
      tmpreg1 = ((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> POSITION_VAL(RCC_PLLI2SCFGR_PLLI2SR));
 800339a:	4e91      	ldr	r6, [pc, #580]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800339c:	f04f 43e0 	mov.w	r3, #1879048192	; 0x70000000
 80033a0:	f8d6 1084 	ldr.w	r1, [r6, #132]	; 0x84
 80033a4:	fa93 f3a3 	rbit	r3, r3
 80033a8:	fab3 f083 	clz	r0, r3
      /* Configure the PLLI2S division factors */      
      /* PLLI2S_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLI2S_VCO Output = PLLI2S_VCO Input * PLLI2SN */
      /* SAI_CLK(first level) = PLLI2S_VCO Output/PLLI2SQ */
      __HAL_RCC_PLLI2S_SAICLK_CONFIG(PeriphClkInit->PLLI2S.PLLI2SN , PeriphClkInit->PLLI2S.PLLI2SQ , tmpreg1);
 80033ac:	68e3      	ldr	r3, [r4, #12]
 80033ae:	6862      	ldr	r2, [r4, #4]
 80033b0:	061b      	lsls	r3, r3, #24
 80033b2:	ea43 1282 	orr.w	r2, r3, r2, lsl #6
 80033b6:	f001 43e0 	and.w	r3, r1, #1879048192	; 0x70000000
 80033ba:	40c3      	lsrs	r3, r0
 80033bc:	ea42 7303 	orr.w	r3, r2, r3, lsl #28
 80033c0:	f8c6 3084 	str.w	r3, [r6, #132]	; 0x84
      /* SAI_CLK_x = SAI_CLK(first level)/PLLI2SDIVQ */ 
      __HAL_RCC_PLLI2S_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLI2SDivQ);
 80033c4:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
 80033c8:	69e2      	ldr	r2, [r4, #28]
 80033ca:	f023 031f 	bic.w	r3, r3, #31
 80033ce:	3a01      	subs	r2, #1
 80033d0:	4313      	orrs	r3, r2
 80033d2:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    }
    
    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
 80033d6:	2301      	movs	r3, #1
 80033d8:	602b      	str	r3, [r5, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 80033da:	f7fe fb75 	bl	8001ac8 <HAL_GetTick>
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80033de:	4d80      	ldr	r5, [pc, #512]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
    }
    
    /* Enable the PLLI2S */
    __HAL_RCC_PLLI2S_ENABLE();
    /* Get tick */
    tickstart = HAL_GetTick();
 80033e0:	4606      	mov	r6, r0
    /* Wait till PLLI2S is ready */
    while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLI2SRDY)  == RESET)
 80033e2:	682b      	ldr	r3, [r5, #0]
 80033e4:	0118      	lsls	r0, r3, #4
 80033e6:	d4a7      	bmi.n	8003338 <HAL_RCCEx_PeriphCLKConfig+0xc>
    {
      if((HAL_GetTick() - tickstart ) > PLLI2S_TIMEOUT_VALUE)
 80033e8:	f7fe fb6e 	bl	8001ac8 <HAL_GetTick>
 80033ec:	1b80      	subs	r0, r0, r6
 80033ee:	2802      	cmp	r0, #2
 80033f0:	d9f7      	bls.n	80033e2 <HAL_RCCEx_PeriphCLKConfig+0xb6>
 80033f2:	e7b6      	b.n	8003362 <HAL_RCCEx_PeriphCLKConfig+0x36>
  {
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
 
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE(); 
 80033f4:	4d7b      	ldr	r5, [pc, #492]	; (80035e4 <HAL_RCCEx_PeriphCLKConfig+0x2b8>)
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 80033f6:	4f7a      	ldr	r7, [pc, #488]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
  {
    /* Check the PLLSAI division factors */
    assert_param(IS_RCC_PLLSAIN_VALUE(PeriphClkInit->PLLSAI.PLLSAIN));
 
    /* Disable PLLSAI Clock */
    __HAL_RCC_PLLSAI_DISABLE(); 
 80033f8:	2300      	movs	r3, #0
 80033fa:	602b      	str	r3, [r5, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 80033fc:	f7fe fb64 	bl	8001ac8 <HAL_GetTick>
 8003400:	4680      	mov	r8, r0
    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
 8003402:	683b      	ldr	r3, [r7, #0]
 8003404:	4e76      	ldr	r6, [pc, #472]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003406:	009a      	lsls	r2, r3, #2
 8003408:	f100 8088 	bmi.w	800351c <HAL_RCCEx_PeriphCLKConfig+0x1f0>
    }
    
    /*---------------------------- SAI configuration -------------------------*/
    /* In Case of SAI Clock Configuration through PLLSAI, PLLSAIQ and PLLSAI_DIVQ must  
       be added only for SAI configuration */     
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI_PLLSAI) == (RCC_PERIPHCLK_SAI_PLLSAI))
 800340c:	6827      	ldr	r7, [r4, #0]
 800340e:	077b      	lsls	r3, r7, #29
 8003410:	d531      	bpl.n	8003476 <HAL_RCCEx_PeriphCLKConfig+0x14a>
    {
      assert_param(IS_RCC_PLLSAIQ_VALUE(PeriphClkInit->PLLSAI.PLLSAIQ));
      assert_param(IS_RCC_PLLSAI_DIVQ_VALUE(PeriphClkInit->PLLSAIDivQ));
      
      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIR) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIR));
 8003412:	f8d6 2088 	ldr.w	r2, [r6, #136]	; 0x88
 8003416:	f04f 41e0 	mov.w	r1, #1879048192	; 0x70000000
 800341a:	fa91 fca1 	rbit	ip, r1
 800341e:	f647 78c0 	movw	r8, #32704	; 0x7fc0
 8003422:	fabc fc8c 	clz	ip, ip
 8003426:	fa98 f8a8 	rbit	r8, r8
 800342a:	f04f 6e70 	mov.w	lr, #251658240	; 0xf000000
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* SAI_CLK(first level) = PLLSAI_VCO Output/PLLSAIQ */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , PeriphClkInit->PLLSAI.PLLSAIQ, tmpreg1);
 800342e:	fab8 f888 	clz	r8, r8
 8003432:	fa9e f0ae 	rbit	r0, lr
 8003436:	fab0 fe80 	clz	lr, r0
 800343a:	fa91 f1a1 	rbit	r1, r1
 800343e:	6920      	ldr	r0, [r4, #16]
 8003440:	fa00 f308 	lsl.w	r3, r0, r8
 8003444:	6960      	ldr	r0, [r4, #20]
 8003446:	f002 42e0 	and.w	r2, r2, #1879048192	; 0x70000000
 800344a:	fa22 f20c 	lsr.w	r2, r2, ip
 800344e:	fab1 f181 	clz	r1, r1
 8003452:	fa00 f00e 	lsl.w	r0, r0, lr
 8003456:	4318      	orrs	r0, r3
 8003458:	fa02 f301 	lsl.w	r3, r2, r1
 800345c:	4303      	orrs	r3, r0
 800345e:	f8c6 3088 	str.w	r3, [r6, #136]	; 0x88
      /* SAI_CLK_x = SAI_CLK(first level)/PLLSAIDIVQ */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVQ_CONFIG(PeriphClkInit->PLLSAIDivQ);
 8003462:	f8d6 308c 	ldr.w	r3, [r6, #140]	; 0x8c
 8003466:	6a22      	ldr	r2, [r4, #32]
 8003468:	f423 53f8 	bic.w	r3, r3, #7936	; 0x1f00
 800346c:	3a01      	subs	r2, #1
 800346e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003472:	f8c6 308c 	str.w	r3, [r6, #140]	; 0x8c
    }
    
    /*---------------------------- LTDC configuration ------------------------*/
    if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == (RCC_PERIPHCLK_LTDC))
 8003476:	073e      	lsls	r6, r7, #28
 8003478:	d52f      	bpl.n	80034da <HAL_RCCEx_PeriphCLKConfig+0x1ae>
    {
      assert_param(IS_RCC_PLLSAIR_VALUE(PeriphClkInit->PLLSAI.PLLSAIR));
      assert_param(IS_RCC_PLLSAI_DIVR_VALUE(PeriphClkInit->PLLSAIDivR));
      
      /* Read PLLSAIR value from PLLSAICFGR register (this value is not need for SAI configuration) */
      tmpreg1 = ((RCC->PLLSAICFGR & RCC_PLLSAICFGR_PLLSAIQ) >> POSITION_VAL(RCC_PLLSAICFGR_PLLSAIQ));
 800347a:	4f59      	ldr	r7, [pc, #356]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800347c:	f04f 6170 	mov.w	r1, #251658240	; 0xf000000
 8003480:	f8d7 2088 	ldr.w	r2, [r7, #136]	; 0x88
 8003484:	fa91 fea1 	rbit	lr, r1
 8003488:	f647 7cc0 	movw	ip, #32704	; 0x7fc0
 800348c:	fabe fe8e 	clz	lr, lr
 8003490:	fa9c fcac 	rbit	ip, ip
      /* PLLSAI_VCO Input  = PLL_SOURCE/PLLM */
      /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN */
      /* LTDC_CLK(first level) = PLLSAI_VCO Output/PLLSAIR */
      __HAL_RCC_PLLSAI_CONFIG(PeriphClkInit->PLLSAI.PLLSAIN , tmpreg1, PeriphClkInit->PLLSAI.PLLSAIR);
 8003494:	fabc fc8c 	clz	ip, ip
 8003498:	fa91 f1a1 	rbit	r1, r1
 800349c:	f04f 40e0 	mov.w	r0, #1879048192	; 0x70000000
 80034a0:	fab1 f181 	clz	r1, r1
 80034a4:	fa90 f0a0 	rbit	r0, r0
 80034a8:	6923      	ldr	r3, [r4, #16]
 80034aa:	fab0 f680 	clz	r6, r0
 80034ae:	69a0      	ldr	r0, [r4, #24]
 80034b0:	f002 6270 	and.w	r2, r2, #251658240	; 0xf000000
 80034b4:	fa03 f30c 	lsl.w	r3, r3, ip
 80034b8:	fa22 f20e 	lsr.w	r2, r2, lr
 80034bc:	40b0      	lsls	r0, r6
 80034be:	4318      	orrs	r0, r3
 80034c0:	fa02 f301 	lsl.w	r3, r2, r1
 80034c4:	4303      	orrs	r3, r0
 80034c6:	f8c7 3088 	str.w	r3, [r7, #136]	; 0x88
      /* LTDC_CLK = LTDC_CLK(first level)/PLLSAIDIVR */ 
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
 80034ca:	f8d7 308c 	ldr.w	r3, [r7, #140]	; 0x8c
 80034ce:	f423 3240 	bic.w	r2, r3, #196608	; 0x30000
 80034d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80034d4:	4313      	orrs	r3, r2
 80034d6:	f8c7 308c 	str.w	r3, [r7, #140]	; 0x8c
    }    
    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
 80034da:	2301      	movs	r3, #1
 80034dc:	602b      	str	r3, [r5, #0]
    /* Get tick */
    tickstart = HAL_GetTick();
 80034de:	f7fe faf3 	bl	8001ac8 <HAL_GetTick>
    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80034e2:	4d3f      	ldr	r5, [pc, #252]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
      __HAL_RCC_PLLSAI_PLLSAICLKDIVR_CONFIG(PeriphClkInit->PLLSAIDivR);
    }    
    /* Enable PLLSAI Clock */
    __HAL_RCC_PLLSAI_ENABLE();
    /* Get tick */
    tickstart = HAL_GetTick();
 80034e4:	4606      	mov	r6, r0
    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
 80034e6:	682b      	ldr	r3, [r5, #0]
 80034e8:	0098      	lsls	r0, r3, #2
 80034ea:	d51f      	bpl.n	800352c <HAL_RCCEx_PeriphCLKConfig+0x200>
    }  
  }
  /*--------------------------------------------------------------------------*/
    
  /*---------------------------- RTC configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 80034ec:	6823      	ldr	r3, [r4, #0]
 80034ee:	0699      	lsls	r1, r3, #26
 80034f0:	d568      	bpl.n	80035c4 <HAL_RCCEx_PeriphCLKConfig+0x298>
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80034f2:	2300      	movs	r3, #0
 80034f4:	9301      	str	r3, [sp, #4]
 80034f6:	4b3a      	ldr	r3, [pc, #232]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
      
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 80034f8:	4d3b      	ldr	r5, [pc, #236]	; (80035e8 <HAL_RCCEx_PeriphCLKConfig+0x2bc>)
  {
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));
    
    /* Enable Power Clock*/
    __HAL_RCC_PWR_CLK_ENABLE();
 80034fa:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80034fc:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8003500:	641a      	str	r2, [r3, #64]	; 0x40
 8003502:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8003504:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003508:	9301      	str	r3, [sp, #4]
 800350a:	9b01      	ldr	r3, [sp, #4]
      
    /* Enable write access to Backup domain */
    PWR->CR |= PWR_CR_DBP;
 800350c:	682b      	ldr	r3, [r5, #0]
 800350e:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003512:	602b      	str	r3, [r5, #0]
      
    /* Get tick */
    tickstart = HAL_GetTick();
 8003514:	f7fe fad8 	bl	8001ac8 <HAL_GetTick>
 8003518:	4606      	mov	r6, r0
      
    while((PWR->CR & PWR_CR_DBP) == RESET)
 800351a:	e013      	b.n	8003544 <HAL_RCCEx_PeriphCLKConfig+0x218>
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLSAI is disabled */
    while(__HAL_RCC_PLLSAI_GET_FLAG() != RESET)
    {
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 800351c:	f7fe fad4 	bl	8001ac8 <HAL_GetTick>
 8003520:	ebc8 0000 	rsb	r0, r8, r0
 8003524:	2802      	cmp	r0, #2
 8003526:	f67f af6c 	bls.w	8003402 <HAL_RCCEx_PeriphCLKConfig+0xd6>
 800352a:	e71a      	b.n	8003362 <HAL_RCCEx_PeriphCLKConfig+0x36>
    /* Get tick */
    tickstart = HAL_GetTick();
    /* Wait till PLLSAI is ready */
    while(__HAL_RCC_PLLSAI_GET_FLAG() == RESET)
    {
      if((HAL_GetTick() - tickstart ) > PLLSAI_TIMEOUT_VALUE)
 800352c:	f7fe facc 	bl	8001ac8 <HAL_GetTick>
 8003530:	1b80      	subs	r0, r0, r6
 8003532:	2802      	cmp	r0, #2
 8003534:	d9d7      	bls.n	80034e6 <HAL_RCCEx_PeriphCLKConfig+0x1ba>
 8003536:	e714      	b.n	8003362 <HAL_RCCEx_PeriphCLKConfig+0x36>
    /* Get tick */
    tickstart = HAL_GetTick();
      
    while((PWR->CR & PWR_CR_DBP) == RESET)
    {
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 8003538:	f7fe fac6 	bl	8001ac8 <HAL_GetTick>
 800353c:	1b80      	subs	r0, r0, r6
 800353e:	2802      	cmp	r0, #2
 8003540:	f63f af0f 	bhi.w	8003362 <HAL_RCCEx_PeriphCLKConfig+0x36>
    PWR->CR |= PWR_CR_DBP;
      
    /* Get tick */
    tickstart = HAL_GetTick();
      
    while((PWR->CR & PWR_CR_DBP) == RESET)
 8003544:	682b      	ldr	r3, [r5, #0]
 8003546:	05d9      	lsls	r1, r3, #23
 8003548:	d5f6      	bpl.n	8003538 <HAL_RCCEx_PeriphCLKConfig+0x20c>
      {
        return HAL_TIMEOUT;
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
 800354a:	4d25      	ldr	r5, [pc, #148]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 800354c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 800354e:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8003552:	d10f      	bne.n	8003574 <HAL_RCCEx_PeriphCLKConfig+0x248>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003554:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003556:	f402 7340 	and.w	r3, r2, #768	; 0x300
 800355a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800355e:	4b20      	ldr	r3, [pc, #128]	; (80035e0 <HAL_RCCEx_PeriphCLKConfig+0x2b4>)
 8003560:	d127      	bne.n	80035b2 <HAL_RCCEx_PeriphCLKConfig+0x286>
 8003562:	6899      	ldr	r1, [r3, #8]
 8003564:	f421 10f8 	bic.w	r0, r1, #2031616	; 0x1f0000
 8003568:	f022 4170 	bic.w	r1, r2, #4026531840	; 0xf0000000
 800356c:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 8003570:	4301      	orrs	r1, r0
 8003572:	e021      	b.n	80035b8 <HAL_RCCEx_PeriphCLKConfig+0x28c>
        return HAL_TIMEOUT;
      }
    }
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8003574:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003576:	f402 7240 	and.w	r2, r2, #768	; 0x300
 800357a:	4293      	cmp	r3, r2
 800357c:	d0ea      	beq.n	8003554 <HAL_RCCEx_PeriphCLKConfig+0x228>
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 800357e:	6f2b      	ldr	r3, [r5, #112]	; 0x70
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
 8003580:	4a1a      	ldr	r2, [pc, #104]	; (80035ec <HAL_RCCEx_PeriphCLKConfig+0x2c0>)
 8003582:	2101      	movs	r1, #1
 8003584:	6011      	str	r1, [r2, #0]
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    tmpreg1 = (RCC->BDCR & RCC_BDCR_RTCSEL);
    if((tmpreg1 != 0x00000000U) && ((tmpreg1) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
    {
      /* Store the content of BDCR register before the reset of Backup Domain */
      tmpreg1 = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8003586:	f423 7340 	bic.w	r3, r3, #768	; 0x300
      /* RTC Clock selection can be changed only if the Backup Domain is reset */
      __HAL_RCC_BACKUPRESET_FORCE();
      __HAL_RCC_BACKUPRESET_RELEASE();
 800358a:	2100      	movs	r1, #0
 800358c:	6011      	str	r1, [r2, #0]
      /* Restore the Content of BDCR register */
      RCC->BDCR = tmpreg1;
 800358e:	672b      	str	r3, [r5, #112]	; 0x70

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
 8003590:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8003592:	07da      	lsls	r2, r3, #31
 8003594:	d5de      	bpl.n	8003554 <HAL_RCCEx_PeriphCLKConfig+0x228>
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 8003596:	f7fe fa97 	bl	8001ac8 <HAL_GetTick>
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800359a:	f241 3788 	movw	r7, #5000	; 0x1388

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if(HAL_IS_BIT_SET(RCC->BDCR, RCC_BDCR_LSEON))
      {
        /* Get tick */
        tickstart = HAL_GetTick();
 800359e:	4606      	mov	r6, r0
        
        /* Wait till LSE is ready */  
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80035a0:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80035a2:	079b      	lsls	r3, r3, #30
 80035a4:	d4d6      	bmi.n	8003554 <HAL_RCCEx_PeriphCLKConfig+0x228>
        {
          if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80035a6:	f7fe fa8f 	bl	8001ac8 <HAL_GetTick>
 80035aa:	1b80      	subs	r0, r0, r6
 80035ac:	42b8      	cmp	r0, r7
 80035ae:	d9f7      	bls.n	80035a0 <HAL_RCCEx_PeriphCLKConfig+0x274>
 80035b0:	e6d7      	b.n	8003362 <HAL_RCCEx_PeriphCLKConfig+0x36>
            return HAL_TIMEOUT;
          }
        }
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80035b2:	6899      	ldr	r1, [r3, #8]
 80035b4:	f421 11f8 	bic.w	r1, r1, #2031616	; 0x1f0000
 80035b8:	6099      	str	r1, [r3, #8]
 80035ba:	6f19      	ldr	r1, [r3, #112]	; 0x70
 80035bc:	f3c2 020b 	ubfx	r2, r2, #0, #12
 80035c0:	430a      	orrs	r2, r1
 80035c2:	671a      	str	r2, [r3, #112]	; 0x70
  }
  /*--------------------------------------------------------------------------*/

  /*---------------------------- TIM configuration ---------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == (RCC_PERIPHCLK_TIM))
 80035c4:	6820      	ldr	r0, [r4, #0]
 80035c6:	f010 0010 	ands.w	r0, r0, #16
  {
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 80035ca:	bf1f      	itttt	ne
 80035cc:	4b08      	ldrne	r3, [pc, #32]	; (80035f0 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80035ce:	f894 202c 	ldrbne.w	r2, [r4, #44]	; 0x2c
 80035d2:	601a      	strne	r2, [r3, #0]
  }
  return HAL_OK;
 80035d4:	2000      	movne	r0, #0
}
 80035d6:	b002      	add	sp, #8
 80035d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80035dc:	42470068 	.word	0x42470068
 80035e0:	40023800 	.word	0x40023800
 80035e4:	42470070 	.word	0x42470070
 80035e8:	40007000 	.word	0x40007000
 80035ec:	42470e40 	.word	0x42470e40
 80035f0:	424711e0 	.word	0x424711e0

080035f4 <HAL_RNG_MspInit>:
 80035f4:	4770      	bx	lr

080035f6 <HAL_RNG_Init>:
  * @param  hrng: pointer to a RNG_HandleTypeDef structure that contains
  *                the configuration information for RNG.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{ 
 80035f6:	b510      	push	{r4, lr}
  /* Check the RNG handle allocation */
  if(hrng == NULL)
 80035f8:	4604      	mov	r4, r0
 80035fa:	b1b8      	cbz	r0, 800362c <HAL_RNG_Init+0x36>
  {
    return HAL_ERROR;
  }
  
  __HAL_LOCK(hrng);
 80035fc:	7903      	ldrb	r3, [r0, #4]
 80035fe:	2b01      	cmp	r3, #1
 8003600:	d016      	beq.n	8003630 <HAL_RNG_Init+0x3a>
 8003602:	2301      	movs	r3, #1
 8003604:	7103      	strb	r3, [r0, #4]
  
  if(hrng->State == HAL_RNG_STATE_RESET)
 8003606:	7943      	ldrb	r3, [r0, #5]
 8003608:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800360c:	b913      	cbnz	r3, 8003614 <HAL_RNG_Init+0x1e>
  {  
    /* Allocate lock resource and initialize it */
    hrng->Lock = HAL_UNLOCKED;
 800360e:	7102      	strb	r2, [r0, #4]
    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
 8003610:	f7ff fff0 	bl	80035f4 <HAL_RNG_MspInit>
  
  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 8003614:	6822      	ldr	r2, [r4, #0]
    /* Init the low level hardware */
    HAL_RNG_MspInit(hrng);
  }
  
  /* Change RNG peripheral state */
  hrng->State = HAL_RNG_STATE_BUSY;
 8003616:	2302      	movs	r3, #2
 8003618:	7163      	strb	r3, [r4, #5]

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);
 800361a:	6813      	ldr	r3, [r2, #0]
 800361c:	f043 0304 	orr.w	r3, r3, #4
 8003620:	6013      	str	r3, [r2, #0]

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
  
  __HAL_UNLOCK(hrng);
 8003622:	2000      	movs	r0, #0

  /* Enable the RNG Peripheral */
  __HAL_RNG_ENABLE(hrng);

  /* Initialize the RNG state */
  hrng->State = HAL_RNG_STATE_READY;
 8003624:	2301      	movs	r3, #1
 8003626:	7163      	strb	r3, [r4, #5]
  
  __HAL_UNLOCK(hrng);
 8003628:	7120      	strb	r0, [r4, #4]
  
  /* Return function status */
  return HAL_OK;
 800362a:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_RNG_Init(RNG_HandleTypeDef *hrng)
{ 
  /* Check the RNG handle allocation */
  if(hrng == NULL)
  {
    return HAL_ERROR;
 800362c:	2001      	movs	r0, #1
 800362e:	bd10      	pop	{r4, pc}
  }
  
  __HAL_LOCK(hrng);
 8003630:	2002      	movs	r0, #2
  
  __HAL_UNLOCK(hrng);
  
  /* Return function status */
  return HAL_OK;
}
 8003632:	bd10      	pop	{r4, pc}

08003634 <HAL_SDRAM_MspInit>:
 8003634:	4770      	bx	lr

08003636 <HAL_SDRAM_Init>:
  *                the configuration information for SDRAM module.
  * @param  Timing: Pointer to SDRAM control timing structure 
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
 8003636:	b538      	push	{r3, r4, r5, lr}
 8003638:	460d      	mov	r5, r1
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
 800363a:	4604      	mov	r4, r0
 800363c:	b1c8      	cbz	r0, 8003672 <HAL_SDRAM_Init+0x3c>
  {
    return HAL_ERROR;
  }
  
  if(hsdram->State == HAL_SDRAM_STATE_RESET)
 800363e:	f890 302c 	ldrb.w	r3, [r0, #44]	; 0x2c
 8003642:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003646:	b91b      	cbnz	r3, 8003650 <HAL_SDRAM_Init+0x1a>
  {  
    /* Allocate lock resource and initialize it */
    hsdram->Lock = HAL_UNLOCKED;
 8003648:	f880 202d 	strb.w	r2, [r0, #45]	; 0x2d
    /* Initialize the low level hardware (MSP) */
    HAL_SDRAM_MspInit(hsdram);
 800364c:	f7ff fff2 	bl	8003634 <HAL_SDRAM_MspInit>
  }
  
  /* Initialize the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8003650:	2302      	movs	r3, #2
 8003652:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  /* Initialize SDRAM control Interface */
  FMC_SDRAM_Init(hsdram->Instance, &(hsdram->Init));
 8003656:	1d21      	adds	r1, r4, #4
 8003658:	6820      	ldr	r0, [r4, #0]
 800365a:	f000 fc13 	bl	8003e84 <FMC_SDRAM_Init>
  
  /* Initialize SDRAM timing Interface */
  FMC_SDRAM_Timing_Init(hsdram->Instance, Timing, hsdram->Init.SDBank); 
 800365e:	6862      	ldr	r2, [r4, #4]
 8003660:	6820      	ldr	r0, [r4, #0]
 8003662:	4629      	mov	r1, r5
 8003664:	f000 fc4f 	bl	8003f06 <FMC_SDRAM_Timing_Init>
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 8003668:	2301      	movs	r3, #1
 800366a:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  return HAL_OK;
 800366e:	2000      	movs	r0, #0
 8003670:	bd38      	pop	{r3, r4, r5, pc}
HAL_StatusTypeDef HAL_SDRAM_Init(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_TimingTypeDef *Timing)
{   
  /* Check the SDRAM handle parameter */
  if(hsdram == NULL)
  {
    return HAL_ERROR;
 8003672:	2001      	movs	r0, #1
  
  /* Update the SDRAM controller state */
  hsdram->State = HAL_SDRAM_STATE_READY;
  
  return HAL_OK;
}
 8003674:	bd38      	pop	{r3, r4, r5, pc}

08003676 <HAL_SDRAM_SendCommand>:
  * @param  Command: SDRAM command structure
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8003676:	b538      	push	{r3, r4, r5, lr}
 8003678:	4604      	mov	r4, r0
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 800367a:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 800367e:	b2c0      	uxtb	r0, r0
 8003680:	2802      	cmp	r0, #2
  * @param  Command: SDRAM command structure
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */  
HAL_StatusTypeDef HAL_SDRAM_SendCommand(SDRAM_HandleTypeDef *hsdram, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8003682:	460d      	mov	r5, r1
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 8003684:	d00d      	beq.n	80036a2 <HAL_SDRAM_SendCommand+0x2c>
  {
    return HAL_BUSY;
  }
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 8003686:	2302      	movs	r3, #2
 8003688:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  /* Send SDRAM command */
  FMC_SDRAM_SendCommand(hsdram->Instance, Command, Timeout);
 800368c:	6820      	ldr	r0, [r4, #0]
 800368e:	f000 fc86 	bl	8003f9e <FMC_SDRAM_SendCommand>
  
  /* Update the SDRAM controller state */
  if(Command->CommandMode == FMC_SDRAM_CMD_PALL)
 8003692:	682b      	ldr	r3, [r5, #0]
 8003694:	2b02      	cmp	r3, #2
  {
    hsdram->State = HAL_SDRAM_STATE_PRECHARGED;
 8003696:	bf0c      	ite	eq
 8003698:	2305      	moveq	r3, #5
  }
  else
  {
    hsdram->State = HAL_SDRAM_STATE_READY;
 800369a:	2301      	movne	r3, #1
 800369c:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  }
  
  return HAL_OK;  
 80036a0:	2000      	movs	r0, #0
}
 80036a2:	bd38      	pop	{r3, r4, r5, pc}

080036a4 <HAL_SDRAM_ProgramRefreshRate>:
  *                the configuration information for SDRAM module.  
  * @param  RefreshRate: The SDRAM refresh rate value       
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SDRAM_ProgramRefreshRate(SDRAM_HandleTypeDef *hsdram, uint32_t RefreshRate)
{
 80036a4:	b510      	push	{r4, lr}
 80036a6:	4604      	mov	r4, r0
  /* Check the SDRAM controller state */
  if(hsdram->State == HAL_SDRAM_STATE_BUSY)
 80036a8:	f890 002c 	ldrb.w	r0, [r0, #44]	; 0x2c
 80036ac:	b2c0      	uxtb	r0, r0
 80036ae:	2802      	cmp	r0, #2
 80036b0:	d009      	beq.n	80036c6 <HAL_SDRAM_ProgramRefreshRate+0x22>
  {
    return HAL_BUSY;
  } 
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_BUSY;
 80036b2:	2302      	movs	r3, #2
 80036b4:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  /* Program the refresh rate */
  FMC_SDRAM_ProgramRefreshRate(hsdram->Instance ,RefreshRate);
 80036b8:	6820      	ldr	r0, [r4, #0]
 80036ba:	f000 fc96 	bl	8003fea <FMC_SDRAM_ProgramRefreshRate>
  
  /* Update the SDRAM state */
  hsdram->State = HAL_SDRAM_STATE_READY;
 80036be:	2301      	movs	r3, #1
 80036c0:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
  
  return HAL_OK;   
 80036c4:	2000      	movs	r0, #0
}
 80036c6:	bd10      	pop	{r4, pc}

080036c8 <SPI_WaitFlagStateUntilTimeout>:
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFlagStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Flag, uint32_t State, uint32_t Timeout, uint32_t Tickstart)
{
 80036c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80036cc:	9e06      	ldr	r6, [sp, #24]
 80036ce:	4604      	mov	r4, r0
 80036d0:	4688      	mov	r8, r1
 80036d2:	4617      	mov	r7, r2
 80036d4:	461d      	mov	r5, r3
  while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
 80036d6:	6822      	ldr	r2, [r4, #0]
 80036d8:	6893      	ldr	r3, [r2, #8]
 80036da:	ea38 0303 	bics.w	r3, r8, r3
 80036de:	bf0c      	ite	eq
 80036e0:	2301      	moveq	r3, #1
 80036e2:	2300      	movne	r3, #0
 80036e4:	429f      	cmp	r7, r3
 80036e6:	d033      	beq.n	8003750 <SPI_WaitFlagStateUntilTimeout+0x88>
  {
    if(Timeout != HAL_MAX_DELAY)
 80036e8:	1c6b      	adds	r3, r5, #1
 80036ea:	d0f5      	beq.n	80036d8 <SPI_WaitFlagStateUntilTimeout+0x10>
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 80036ec:	b94d      	cbnz	r5, 8003702 <SPI_WaitFlagStateUntilTimeout+0x3a>
        /* Disable the SPI and reset the CRC: the CRC value should be cleared
        on both master and slave sides in order to resynchronize the master
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 80036ee:	6823      	ldr	r3, [r4, #0]
 80036f0:	685a      	ldr	r2, [r3, #4]
 80036f2:	f022 02e0 	bic.w	r2, r2, #224	; 0xe0
 80036f6:	605a      	str	r2, [r3, #4]

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 80036f8:	6862      	ldr	r2, [r4, #4]
 80036fa:	f5b2 7f82 	cmp.w	r2, #260	; 0x104
 80036fe:	d111      	bne.n	8003724 <SPI_WaitFlagStateUntilTimeout+0x5c>
 8003700:	e005      	b.n	800370e <SPI_WaitFlagStateUntilTimeout+0x46>
{
  while((((hspi->Instance->SR & Flag) == (Flag)) ? SET : RESET) != State)
  {
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U) || ((HAL_GetTick()-Tickstart) >= Timeout))
 8003702:	f7fe f9e1 	bl	8001ac8 <HAL_GetTick>
 8003706:	1b80      	subs	r0, r0, r6
 8003708:	4285      	cmp	r5, r0
 800370a:	d8e4      	bhi.n	80036d6 <SPI_WaitFlagStateUntilTimeout+0xe>
 800370c:	e7ef      	b.n	80036ee <SPI_WaitFlagStateUntilTimeout+0x26>
        and slave for their respective CRC calculation */

        /* Disable TXE, RXNE and ERR interrupts for the interrupt process */
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));

        if((hspi->Init.Mode == SPI_MODE_MASTER)&&((hspi->Init.Direction == SPI_DIRECTION_1LINE)||(hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 800370e:	68a2      	ldr	r2, [r4, #8]
 8003710:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 8003714:	d002      	beq.n	800371c <SPI_WaitFlagStateUntilTimeout+0x54>
 8003716:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 800371a:	d103      	bne.n	8003724 <SPI_WaitFlagStateUntilTimeout+0x5c>
        {
          /* Disable SPI peripheral */
          __HAL_SPI_DISABLE(hspi);
 800371c:	681a      	ldr	r2, [r3, #0]
 800371e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003722:	601a      	str	r2, [r3, #0]
        }

        /* Reset CRC Calculation */
        if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8003724:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003726:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 800372a:	d108      	bne.n	800373e <SPI_WaitFlagStateUntilTimeout+0x76>
        {
          SPI_RESET_CRC(hspi);
 800372c:	6819      	ldr	r1, [r3, #0]
 800372e:	f64d 72ff 	movw	r2, #57343	; 0xdfff
 8003732:	400a      	ands	r2, r1
 8003734:	601a      	str	r2, [r3, #0]
 8003736:	681a      	ldr	r2, [r3, #0]
 8003738:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800373c:	601a      	str	r2, [r3, #0]
        }

        hspi->State= HAL_SPI_STATE_READY;
 800373e:	2301      	movs	r3, #1
 8003740:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

        /* Process Unlocked */
        __HAL_UNLOCK(hspi);
 8003744:	2300      	movs	r3, #0
 8003746:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
 800374a:	2003      	movs	r0, #3
 800374c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8003750:	2000      	movs	r0, #0
}
 8003752:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08003756 <SPI_CheckFlag_BSY>:
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8003756:	b513      	push	{r0, r1, r4, lr}
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8003758:	460b      	mov	r3, r1
 800375a:	9200      	str	r2, [sp, #0]
 800375c:	2180      	movs	r1, #128	; 0x80
 800375e:	2200      	movs	r2, #0
  * @param Timeout: Timeout duration
  * @param Tickstart: tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_CheckFlag_BSY(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8003760:	4604      	mov	r4, r0
  /* Control the BSY flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_BSY, RESET, Timeout, Tickstart) != HAL_OK)
 8003762:	f7ff ffb1 	bl	80036c8 <SPI_WaitFlagStateUntilTimeout>
 8003766:	b120      	cbz	r0, 8003772 <SPI_CheckFlag_BSY+0x1c>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8003768:	6d63      	ldr	r3, [r4, #84]	; 0x54
 800376a:	f043 0320 	orr.w	r3, r3, #32
 800376e:	6563      	str	r3, [r4, #84]	; 0x54
    return HAL_TIMEOUT;
 8003770:	2003      	movs	r0, #3
  }
  return HAL_OK;
}
 8003772:	b002      	add	sp, #8
 8003774:	bd10      	pop	{r4, pc}

08003776 <HAL_SPI_MspInit>:
 8003776:	4770      	bx	lr

08003778 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8003778:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 800377a:	4604      	mov	r4, r0
 800377c:	2800      	cmp	r0, #0
 800377e:	d036      	beq.n	80037ee <HAL_SPI_Init+0x76>
  if(hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
  {
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8003780:	2300      	movs	r3, #0
 8003782:	6283      	str	r3, [r0, #40]	; 0x28
#endif /* USE_SPI_CRC */

  if(hspi->State == HAL_SPI_STATE_RESET)
 8003784:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 8003788:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800378c:	b91b      	cbnz	r3, 8003796 <HAL_SPI_Init+0x1e>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 800378e:	f880 2050 	strb.w	r2, [r0, #80]	; 0x50

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8003792:	f7ff fff0 	bl	8003776 <HAL_SPI_MspInit>
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 8003796:	68a1      	ldr	r1, [r4, #8]
 8003798:	6860      	ldr	r0, [r4, #4]
 800379a:	4308      	orrs	r0, r1
 800379c:	68e1      	ldr	r1, [r4, #12]
 800379e:	4308      	orrs	r0, r1
 80037a0:	6921      	ldr	r1, [r4, #16]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80037a2:	2302      	movs	r3, #2
  __HAL_SPI_DISABLE(hspi);

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80037a4:	4308      	orrs	r0, r1
 80037a6:	6961      	ldr	r1, [r4, #20]

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 80037a8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80037ac:	6823      	ldr	r3, [r4, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80037ae:	4308      	orrs	r0, r1
 80037b0:	69e1      	ldr	r1, [r4, #28]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80037b2:	681a      	ldr	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80037b4:	4308      	orrs	r0, r1
 80037b6:	6a21      	ldr	r1, [r4, #32]
  }

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 80037b8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80037bc:	601a      	str	r2, [r3, #0]

  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Data size, Clock polarity and phase, NSS management,
  Communication speed, First bit and CRC calculation state */
  WRITE_REG(hspi->Instance->CR1, (hspi->Init.Mode | hspi->Init.Direction | hspi->Init.DataSize |
 80037be:	4308      	orrs	r0, r1
 80037c0:	69a2      	ldr	r2, [r4, #24]
 80037c2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 80037c4:	4308      	orrs	r0, r1
 80037c6:	f402 7100 	and.w	r1, r2, #512	; 0x200
 80037ca:	4301      	orrs	r1, r0
 80037cc:	6019      	str	r1, [r3, #0]
                                  hspi->Init.CLKPolarity | hspi->Init.CLKPhase | (hspi->Init.NSS & SPI_CR1_SSM) |
                                  hspi->Init.BaudRatePrescaler | hspi->Init.FirstBit  | hspi->Init.CRCCalculation) );

  /* Configure : NSS management */
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) | hspi->Init.TIMode));
 80037ce:	0c12      	lsrs	r2, r2, #16
 80037d0:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80037d2:	f002 0204 	and.w	r2, r2, #4
 80037d6:	430a      	orrs	r2, r1
 80037d8:	605a      	str	r2, [r3, #4]
  }
#endif /* USE_SPI_CRC */

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 80037da:	69da      	ldr	r2, [r3, #28]
 80037dc:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
 80037e0:	61da      	str	r2, [r3, #28]
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80037e2:	2000      	movs	r0, #0
  hspi->State     = HAL_SPI_STATE_READY;
 80037e4:	2301      	movs	r3, #1
#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
#endif /* USE_SPI_CRC */

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 80037e6:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State     = HAL_SPI_STATE_READY;
 80037e8:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51

  return HAL_OK;
 80037ec:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 80037ee:	2001      	movs	r0, #1

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State     = HAL_SPI_STATE_READY;

  return HAL_OK;
}
 80037f0:	bd10      	pop	{r4, pc}

080037f2 <HAL_SPI_MspDeInit>:
 80037f2:	4770      	bx	lr

080037f4 <HAL_SPI_DeInit>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
 80037f4:	b510      	push	{r4, lr}
  /* Check the SPI handle allocation */
  if(hspi == NULL)
 80037f6:	4604      	mov	r4, r0
 80037f8:	b180      	cbz	r0, 800381c <HAL_SPI_DeInit+0x28>
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));

  hspi->State = HAL_SPI_STATE_BUSY;

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
 80037fa:	6802      	ldr	r2, [r0, #0]
  }

  /* Check SPI Instance parameter */
  assert_param(IS_SPI_ALL_INSTANCE(hspi->Instance));

  hspi->State = HAL_SPI_STATE_BUSY;
 80037fc:	2302      	movs	r3, #2
 80037fe:	f880 3051 	strb.w	r3, [r0, #81]	; 0x51

  /* Disable the SPI Peripheral Clock */
  __HAL_SPI_DISABLE(hspi);
 8003802:	6813      	ldr	r3, [r2, #0]
 8003804:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8003808:	6013      	str	r3, [r2, #0]

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_SPI_MspDeInit(hspi);
 800380a:	f7ff fff2 	bl	80037f2 <HAL_SPI_MspDeInit>

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800380e:	2000      	movs	r0, #0
 8003810:	6560      	str	r0, [r4, #84]	; 0x54
  hspi->State = HAL_SPI_STATE_RESET;

  /* Release Lock */
  __HAL_UNLOCK(hspi);
 8003812:	f884 0050 	strb.w	r0, [r4, #80]	; 0x50

  /* DeInit the low level hardware: GPIO, CLOCK, NVIC... */
  HAL_SPI_MspDeInit(hspi);

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
  hspi->State = HAL_SPI_STATE_RESET;
 8003816:	f884 0051 	strb.w	r0, [r4, #81]	; 0x51

  /* Release Lock */
  __HAL_UNLOCK(hspi);

  return HAL_OK;
 800381a:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_SPI_DeInit(SPI_HandleTypeDef *hspi)
{
  /* Check the SPI handle allocation */
  if(hspi == NULL)
  {
    return HAL_ERROR;
 800381c:	2001      	movs	r0, #1

  /* Release Lock */
  __HAL_UNLOCK(hspi);

  return HAL_OK;
}
 800381e:	bd10      	pop	{r4, pc}

08003820 <HAL_SPI_Transmit>:
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 8003820:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8003824:	461e      	mov	r6, r3

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8003826:	f890 3050 	ldrb.w	r3, [r0, #80]	; 0x50
 800382a:	2b01      	cmp	r3, #1
  * @param  Size: amount of data to be sent
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Transmit(SPI_HandleTypeDef *hspi, uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
 800382c:	4604      	mov	r4, r0
 800382e:	460d      	mov	r5, r1
 8003830:	4690      	mov	r8, r2

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8003832:	f000 809e 	beq.w	8003972 <HAL_SPI_Transmit+0x152>
 8003836:	2301      	movs	r3, #1
 8003838:	f880 3050 	strb.w	r3, [r0, #80]	; 0x50

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 800383c:	f7fe f944 	bl	8001ac8 <HAL_GetTick>
 8003840:	4607      	mov	r7, r0

  if(hspi->State != HAL_SPI_STATE_READY)
 8003842:	f894 0051 	ldrb.w	r0, [r4, #81]	; 0x51
 8003846:	b2c0      	uxtb	r0, r0
 8003848:	2801      	cmp	r0, #1
 800384a:	f040 808a 	bne.w	8003962 <HAL_SPI_Transmit+0x142>
  {
    errorcode = HAL_BUSY;
    goto error;
  }

  if((pData == NULL ) || (Size == 0U))
 800384e:	2d00      	cmp	r5, #0
 8003850:	f000 8088 	beq.w	8003964 <HAL_SPI_Transmit+0x144>
 8003854:	f1b8 0f00 	cmp.w	r8, #0
 8003858:	f000 8084 	beq.w	8003964 <HAL_SPI_Transmit+0x144>
    errorcode = HAL_ERROR;
    goto error;
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 800385c:	2303      	movs	r3, #3
 800385e:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8003862:	2300      	movs	r3, #0
 8003864:	6563      	str	r3, [r4, #84]	; 0x54
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8003866:	63a3      	str	r3, [r4, #56]	; 0x38
  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
  hspi->TxXferCount = Size;
 8003868:	f8a4 8036 	strh.w	r8, [r4, #54]	; 0x36

  /*Init field not used in handle to zero */
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
  hspi->RxXferSize  = 0U;
 800386c:	87a3      	strh	r3, [r4, #60]	; 0x3c
  hspi->RxXferCount = 0U;
 800386e:	87e3      	strh	r3, [r4, #62]	; 0x3e
  hspi->TxISR       = NULL;
 8003870:	6463      	str	r3, [r4, #68]	; 0x44
  hspi->RxISR       = NULL;
 8003872:	6423      	str	r3, [r4, #64]	; 0x40

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003874:	68a3      	ldr	r3, [r4, #8]
  }

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8003876:	6325      	str	r5, [r4, #48]	; 0x30
  hspi->RxXferCount = 0U;
  hspi->TxISR       = NULL;
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8003878:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 800387c:	6823      	ldr	r3, [r4, #0]

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
  hspi->pTxBuffPtr  = (uint8_t *)pData;
  hspi->TxXferSize  = Size;
 800387e:	f8a4 8034 	strh.w	r8, [r4, #52]	; 0x34
  hspi->RxISR       = NULL;

  /* Configure communication direction : 1Line */
  if(hspi->Init.Direction == SPI_DIRECTION_1LINE)
  {
    SPI_1LINE_TX(hspi);
 8003882:	bf02      	ittt	eq
 8003884:	681a      	ldreq	r2, [r3, #0]
 8003886:	f442 4280 	orreq.w	r2, r2, #16384	; 0x4000
 800388a:	601a      	streq	r2, [r3, #0]
    SPI_RESET_CRC(hspi);
  }
#endif /* USE_SPI_CRC */

  /* Check if the SPI is already enabled */
  if((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 800388c:	681a      	ldr	r2, [r3, #0]
 800388e:	0652      	lsls	r2, r2, #25
  {
    /* Enable SPI peripheral */
    __HAL_SPI_ENABLE(hspi);
 8003890:	bf5e      	ittt	pl
 8003892:	681a      	ldrpl	r2, [r3, #0]
 8003894:	f042 0240 	orrpl.w	r2, r2, #64	; 0x40
 8003898:	601a      	strpl	r2, [r3, #0]
  }

  /* Transmit data in 16 Bit mode */
  if(hspi->Init.DataSize == SPI_DATASIZE_16BIT)
 800389a:	68e2      	ldr	r2, [r4, #12]
 800389c:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 80038a0:	6862      	ldr	r2, [r4, #4]
 80038a2:	d11e      	bne.n	80038e2 <HAL_SPI_Transmit+0xc2>
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE) || (hspi->TxXferCount == 0x01))
 80038a4:	b172      	cbz	r2, 80038c4 <HAL_SPI_Transmit+0xa4>
 80038a6:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80038a8:	b292      	uxth	r2, r2
 80038aa:	2a01      	cmp	r2, #1
 80038ac:	d103      	bne.n	80038b6 <HAL_SPI_Transmit+0x96>
 80038ae:	e009      	b.n	80038c4 <HAL_SPI_Transmit+0xa4>
          hspi->TxXferCount--;
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 80038b0:	b1ae      	cbz	r6, 80038de <HAL_SPI_Transmit+0xbe>
 80038b2:	1c71      	adds	r1, r6, #1
 80038b4:	d10e      	bne.n	80038d4 <HAL_SPI_Transmit+0xb4>
      hspi->Instance->DR = *((uint16_t *)pData);
      pData += sizeof(uint16_t);
      hspi->TxXferCount--;
    }
    /* Transmit data in 16 Bit mode */
    while (hspi->TxXferCount > 0U)
 80038b6:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80038b8:	b29b      	uxth	r3, r3
 80038ba:	b1d3      	cbz	r3, 80038f2 <HAL_SPI_Transmit+0xd2>
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 80038bc:	6823      	ldr	r3, [r4, #0]
 80038be:	689a      	ldr	r2, [r3, #8]
 80038c0:	0790      	lsls	r0, r2, #30
 80038c2:	d5f5      	bpl.n	80038b0 <HAL_SPI_Transmit+0x90>
      {
          hspi->Instance->DR = *((uint16_t *)pData);
 80038c4:	f835 2b02 	ldrh.w	r2, [r5], #2
 80038c8:	60da      	str	r2, [r3, #12]
          pData += sizeof(uint16_t);
          hspi->TxXferCount--;
 80038ca:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80038cc:	3b01      	subs	r3, #1
 80038ce:	b29b      	uxth	r3, r3
 80038d0:	86e3      	strh	r3, [r4, #54]	; 0x36
 80038d2:	e7f0      	b.n	80038b6 <HAL_SPI_Transmit+0x96>
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 80038d4:	f7fe f8f8 	bl	8001ac8 <HAL_GetTick>
 80038d8:	1bc0      	subs	r0, r0, r7
 80038da:	4286      	cmp	r6, r0
 80038dc:	d8eb      	bhi.n	80038b6 <HAL_SPI_Transmit+0x96>
        {
          errorcode = HAL_TIMEOUT;
 80038de:	2003      	movs	r0, #3
 80038e0:	e040      	b.n	8003964 <HAL_SPI_Transmit+0x144>
    }
  }
  /* Transmit data in 8 Bit mode */
  else
  {
    if((hspi->Init.Mode == SPI_MODE_SLAVE)|| (hspi->TxXferCount == 0x01))
 80038e2:	b1a2      	cbz	r2, 800390e <HAL_SPI_Transmit+0xee>
 80038e4:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80038e6:	b292      	uxth	r2, r2
 80038e8:	2a01      	cmp	r2, #1
 80038ea:	d010      	beq.n	800390e <HAL_SPI_Transmit+0xee>
    {
      *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
      pData += sizeof(uint8_t);
      hspi->TxXferCount--;
    }
    while (hspi->TxXferCount > 0U)
 80038ec:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80038ee:	b29b      	uxth	r3, r3
 80038f0:	b94b      	cbnz	r3, 8003906 <HAL_SPI_Transmit+0xe6>
      }
    }
  }

  /* Wait until TXE flag */
  if(SPI_WaitFlagStateUntilTimeout(hspi, SPI_FLAG_TXE, SET, Timeout, tickstart) != HAL_OK)
 80038f2:	9700      	str	r7, [sp, #0]
 80038f4:	4633      	mov	r3, r6
 80038f6:	2201      	movs	r2, #1
 80038f8:	2102      	movs	r1, #2
 80038fa:	4620      	mov	r0, r4
 80038fc:	f7ff fee4 	bl	80036c8 <SPI_WaitFlagStateUntilTimeout>
 8003900:	2800      	cmp	r0, #0
 8003902:	d1ec      	bne.n	80038de <HAL_SPI_Transmit+0xbe>
 8003904:	e015      	b.n	8003932 <HAL_SPI_Transmit+0x112>
      hspi->TxXferCount--;
    }
    while (hspi->TxXferCount > 0U)
    {
      /* Wait until TXE flag is set to send data */
      if(__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8003906:	6823      	ldr	r3, [r4, #0]
 8003908:	689a      	ldr	r2, [r3, #8]
 800390a:	0792      	lsls	r2, r2, #30
 800390c:	d507      	bpl.n	800391e <HAL_SPI_Transmit+0xfe>
      {
        *((__IO uint8_t*)&hspi->Instance->DR) = (*pData);
 800390e:	f815 2b01 	ldrb.w	r2, [r5], #1
 8003912:	731a      	strb	r2, [r3, #12]
        pData += sizeof(uint8_t);
        hspi->TxXferCount--;
 8003914:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 8003916:	3b01      	subs	r3, #1
 8003918:	b29b      	uxth	r3, r3
 800391a:	86e3      	strh	r3, [r4, #54]	; 0x36
 800391c:	e7e6      	b.n	80038ec <HAL_SPI_Transmit+0xcc>
      }
      else
      {
        /* Timeout management */
        if((Timeout == 0U) || ((Timeout != HAL_MAX_DELAY) && ((HAL_GetTick()-tickstart) >=  Timeout)))
 800391e:	2e00      	cmp	r6, #0
 8003920:	d0dd      	beq.n	80038de <HAL_SPI_Transmit+0xbe>
 8003922:	1c73      	adds	r3, r6, #1
 8003924:	d0e2      	beq.n	80038ec <HAL_SPI_Transmit+0xcc>
 8003926:	f7fe f8cf 	bl	8001ac8 <HAL_GetTick>
 800392a:	1bc0      	subs	r0, r0, r7
 800392c:	4286      	cmp	r6, r0
 800392e:	d8dd      	bhi.n	80038ec <HAL_SPI_Transmit+0xcc>
 8003930:	e7d5      	b.n	80038de <HAL_SPI_Transmit+0xbe>
    errorcode = HAL_TIMEOUT;
    goto error;
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
 8003932:	463a      	mov	r2, r7
 8003934:	4631      	mov	r1, r6
 8003936:	4620      	mov	r0, r4
 8003938:	f7ff ff0d 	bl	8003756 <SPI_CheckFlag_BSY>
 800393c:	b118      	cbz	r0, 8003946 <HAL_SPI_Transmit+0x126>
  {
    errorcode = HAL_ERROR;
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 800393e:	2320      	movs	r3, #32
 8003940:	6563      	str	r3, [r4, #84]	; 0x54
  }
  
  /* Check Busy flag */
  if(SPI_CheckFlag_BSY(hspi, Timeout, tickstart) != HAL_OK)
  {
    errorcode = HAL_ERROR;
 8003942:	2001      	movs	r0, #1
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
    goto error;
 8003944:	e00e      	b.n	8003964 <HAL_SPI_Transmit+0x144>
  }

  /* Clear overrun flag in 2 Lines communication mode because received is not read */
  if(hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8003946:	68a3      	ldr	r3, [r4, #8]
 8003948:	b933      	cbnz	r3, 8003958 <HAL_SPI_Transmit+0x138>
  {
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 800394a:	9303      	str	r3, [sp, #12]
 800394c:	6823      	ldr	r3, [r4, #0]
 800394e:	68da      	ldr	r2, [r3, #12]
 8003950:	9203      	str	r2, [sp, #12]
 8003952:	689b      	ldr	r3, [r3, #8]
 8003954:	9303      	str	r3, [sp, #12]
 8003956:	9b03      	ldr	r3, [sp, #12]
  {
     SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
  }
#endif /* USE_SPI_CRC */

  if(hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8003958:	6d60      	ldr	r0, [r4, #84]	; 0x54
  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();

  if(hspi->State != HAL_SPI_STATE_READY)
  {
    errorcode = HAL_BUSY;
 800395a:	3000      	adds	r0, #0
 800395c:	bf18      	it	ne
 800395e:	2001      	movne	r0, #1
 8003960:	e000      	b.n	8003964 <HAL_SPI_Transmit+0x144>
 8003962:	2002      	movs	r0, #2
  {
    errorcode = HAL_ERROR;
  }

error:
  hspi->State = HAL_SPI_STATE_READY;
 8003964:	2301      	movs	r3, #1
 8003966:	f884 3051 	strb.w	r3, [r4, #81]	; 0x51
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
 800396a:	2300      	movs	r3, #0
 800396c:	f884 3050 	strb.w	r3, [r4, #80]	; 0x50
  return errorcode;
 8003970:	e000      	b.n	8003974 <HAL_SPI_Transmit+0x154>

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES_OR_1LINE(hspi->Init.Direction));

  /* Process Locked */
  __HAL_LOCK(hspi);
 8003972:	2002      	movs	r0, #2
error:
  hspi->State = HAL_SPI_STATE_READY;
  /* Process Unlocked */
  __HAL_UNLOCK(hspi);
  return errorcode;
}
 8003974:	b004      	add	sp, #16
 8003976:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800397a <HAL_SPI_GetState>:
  * @retval SPI state
  */
HAL_SPI_StateTypeDef HAL_SPI_GetState(SPI_HandleTypeDef *hspi)
{
  /* Return SPI handle state */
  return hspi->State;
 800397a:	f890 0051 	ldrb.w	r0, [r0, #81]	; 0x51
}
 800397e:	4770      	bx	lr

08003980 <UART_EndRxTransfer>:
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003980:	6803      	ldr	r3, [r0, #0]
 8003982:	68da      	ldr	r2, [r3, #12]
 8003984:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8003988:	60da      	str	r2, [r3, #12]
  CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 800398a:	695a      	ldr	r2, [r3, #20]
 800398c:	f022 0201 	bic.w	r2, r2, #1
 8003990:	615a      	str	r2, [r3, #20]

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
 8003992:	2320      	movs	r3, #32
 8003994:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
 8003998:	4770      	bx	lr
	...

0800399c <UART_SetConfig>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 800399c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_UART_STOPBITS(huart->Init.StopBits));
  assert_param(IS_UART_PARITY(huart->Init.Parity));
  assert_param(IS_UART_MODE(huart->Init.Mode));

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;
 80039a0:	6807      	ldr	r7, [r0, #0]
 80039a2:	693b      	ldr	r3, [r7, #16]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
static void UART_SetConfig(UART_HandleTypeDef *huart)
{
 80039a4:	4604      	mov	r4, r0

  /*-------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = huart->Instance->CR2;

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
 80039a6:	f423 5240 	bic.w	r2, r3, #12288	; 0x3000

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80039aa:	68c3      	ldr	r3, [r0, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80039ac:	68a1      	ldr	r1, [r4, #8]
 80039ae:	69c0      	ldr	r0, [r0, #28]

  /* Clear STOP[13:12] bits */
  tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
 80039b0:	4313      	orrs	r3, r2
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80039b2:	6922      	ldr	r2, [r4, #16]

  /* Configure the UART Stop Bits: Set STOP[13:12] bits according to huart->Init.StopBits value */
  tmpreg |= (uint32_t)huart->Init.StopBits;
  
  /* Write to USART CR2 */
  WRITE_REG(huart->Instance->CR2, (uint32_t)tmpreg);
 80039b4:	613b      	str	r3, [r7, #16]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;
 80039b6:	68fb      	ldr	r3, [r7, #12]
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80039b8:	4311      	orrs	r1, r2
 80039ba:	6962      	ldr	r2, [r4, #20]

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80039bc:	f423 4316 	bic.w	r3, r3, #38400	; 0x9600
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80039c0:	430a      	orrs	r2, r1
 80039c2:	4302      	orrs	r2, r0

  /*-------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = huart->Instance->CR1;

  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS | USART_CR1_TE | \
 80039c4:	f023 030c 	bic.w	r3, r3, #12
  /* Configure the UART Word Length, Parity and mode: 
     Set the M bits according to huart->Init.WordLength value 
     Set PCE and PS bits according to huart->Init.Parity value
     Set TE and RE bits according to huart->Init.Mode value
     Set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg |= (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling;
 80039c8:	4313      	orrs	r3, r2
  
  /* Write to USART CR1 */
  WRITE_REG(huart->Instance->CR1, (uint32_t)tmpreg);
 80039ca:	60fb      	str	r3, [r7, #12]
  
  /*-------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = huart->Instance->CR3;
 80039cc:	697b      	ldr	r3, [r7, #20]
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
 80039ce:	f423 7240 	bic.w	r2, r3, #768	; 0x300
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 80039d2:	69a3      	ldr	r3, [r4, #24]
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80039d4:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
  
  /* Clear CTSE and RTSE bits */
  tmpreg &= (uint32_t)~((uint32_t)(USART_CR3_RTSE | USART_CR3_CTSE));
  
  /* Configure the UART HFC: Set CTSE and RTSE bits according to huart->Init.HwFlowCtl value */
  tmpreg |= huart->Init.HwFlowCtl;
 80039d8:	ea43 0302 	orr.w	r3, r3, r2
  
  /* Write to USART CR3 */
  WRITE_REG(huart->Instance->CR3, (uint32_t)tmpreg);
 80039dc:	617b      	str	r3, [r7, #20]
 80039de:	4b7c      	ldr	r3, [pc, #496]	; (8003bd0 <UART_SetConfig+0x234>)
  
  /* Check the Over Sampling */
  if(huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80039e0:	d17c      	bne.n	8003adc <UART_SetConfig+0x140>
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 80039e2:	429f      	cmp	r7, r3
 80039e4:	d003      	beq.n	80039ee <UART_SetConfig+0x52>
 80039e6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80039ea:	429f      	cmp	r7, r3
 80039ec:	d131      	bne.n	8003a52 <UART_SetConfig+0xb6>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 80039ee:	f7ff fc85 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 80039f2:	6863      	ldr	r3, [r4, #4]
 80039f4:	2519      	movs	r5, #25
 80039f6:	ea4f 0843 	mov.w	r8, r3, lsl #1
 80039fa:	4368      	muls	r0, r5
 80039fc:	fbb0 f8f8 	udiv	r8, r0, r8
 8003a00:	f7ff fc7c 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003a04:	6866      	ldr	r6, [r4, #4]
 8003a06:	4368      	muls	r0, r5
 8003a08:	0076      	lsls	r6, r6, #1
 8003a0a:	fbb0 f6f6 	udiv	r6, r0, r6
 8003a0e:	f7ff fc75 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003a12:	6863      	ldr	r3, [r4, #4]
 8003a14:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003a18:	005b      	lsls	r3, r3, #1
 8003a1a:	4368      	muls	r0, r5
 8003a1c:	fbb0 f0f3 	udiv	r0, r0, r3
 8003a20:	fbb0 f0f9 	udiv	r0, r0, r9
 8003a24:	fb09 6610 	mls	r6, r9, r0, r6
 8003a28:	f7ff fc68 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003a2c:	fbb8 f8f9 	udiv	r8, r8, r9
 8003a30:	6861      	ldr	r1, [r4, #4]
 8003a32:	00f6      	lsls	r6, r6, #3
 8003a34:	3632      	adds	r6, #50	; 0x32
 8003a36:	fbb6 f6f9 	udiv	r6, r6, r9
 8003a3a:	0076      	lsls	r6, r6, #1
 8003a3c:	4368      	muls	r0, r5
 8003a3e:	0049      	lsls	r1, r1, #1
 8003a40:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8003a44:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8003a48:	fbb0 faf1 	udiv	sl, r0, r1
 8003a4c:	f7ff fc56 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003a50:	e030      	b.n	8003ab4 <UART_SetConfig+0x118>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8003a52:	f7ff fc3b 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003a56:	6863      	ldr	r3, [r4, #4]
 8003a58:	2519      	movs	r5, #25
 8003a5a:	ea4f 0843 	mov.w	r8, r3, lsl #1
 8003a5e:	4368      	muls	r0, r5
 8003a60:	fbb0 f8f8 	udiv	r8, r0, r8
 8003a64:	f7ff fc32 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003a68:	6866      	ldr	r6, [r4, #4]
 8003a6a:	4368      	muls	r0, r5
 8003a6c:	0076      	lsls	r6, r6, #1
 8003a6e:	fbb0 f6f6 	udiv	r6, r0, r6
 8003a72:	f7ff fc2b 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003a76:	6863      	ldr	r3, [r4, #4]
 8003a78:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003a7c:	005b      	lsls	r3, r3, #1
 8003a7e:	4368      	muls	r0, r5
 8003a80:	fbb0 f0f3 	udiv	r0, r0, r3
 8003a84:	fbb0 f0f9 	udiv	r0, r0, r9
 8003a88:	fb09 6610 	mls	r6, r9, r0, r6
 8003a8c:	f7ff fc1e 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003a90:	fbb8 f8f9 	udiv	r8, r8, r9
 8003a94:	00f6      	lsls	r6, r6, #3
 8003a96:	6861      	ldr	r1, [r4, #4]
 8003a98:	3632      	adds	r6, #50	; 0x32
 8003a9a:	fbb6 f6f9 	udiv	r6, r6, r9
 8003a9e:	0076      	lsls	r6, r6, #1
 8003aa0:	4368      	muls	r0, r5
 8003aa2:	0049      	lsls	r1, r1, #1
 8003aa4:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8003aa8:	f406 76f8 	and.w	r6, r6, #496	; 0x1f0
 8003aac:	fbb0 faf1 	udiv	sl, r0, r1
 8003ab0:	f7ff fc0c 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003ab4:	4345      	muls	r5, r0
 8003ab6:	6860      	ldr	r0, [r4, #4]
 8003ab8:	0040      	lsls	r0, r0, #1
 8003aba:	fbb5 f0f0 	udiv	r0, r5, r0
 8003abe:	fbb0 f0f9 	udiv	r0, r0, r9
 8003ac2:	fb09 a210 	mls	r2, r9, r0, sl
 8003ac6:	00d2      	lsls	r2, r2, #3
 8003ac8:	3232      	adds	r2, #50	; 0x32
 8003aca:	fbb2 f3f9 	udiv	r3, r2, r9
 8003ace:	f003 0307 	and.w	r3, r3, #7
 8003ad2:	4443      	add	r3, r8
 8003ad4:	441e      	add	r6, r3
 8003ad6:	60be      	str	r6, [r7, #8]
 8003ad8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    }
  }
  else
  {
    /*-------------------------- USART BRR Configuration ---------------------*/
    if((huart->Instance == USART1) || (huart->Instance == USART6))
 8003adc:	429f      	cmp	r7, r3
 8003ade:	d002      	beq.n	8003ae6 <UART_SetConfig+0x14a>
 8003ae0:	4b3c      	ldr	r3, [pc, #240]	; (8003bd4 <UART_SetConfig+0x238>)
 8003ae2:	429f      	cmp	r7, r3
 8003ae4:	d130      	bne.n	8003b48 <UART_SetConfig+0x1ac>
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate);
 8003ae6:	f7ff fc09 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003aea:	6863      	ldr	r3, [r4, #4]
 8003aec:	2519      	movs	r5, #25
 8003aee:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8003af2:	4368      	muls	r0, r5
 8003af4:	fbb0 f8f8 	udiv	r8, r0, r8
 8003af8:	f7ff fc00 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003afc:	6866      	ldr	r6, [r4, #4]
 8003afe:	4368      	muls	r0, r5
 8003b00:	00b6      	lsls	r6, r6, #2
 8003b02:	fbb0 f6f6 	udiv	r6, r0, r6
 8003b06:	f7ff fbf9 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003b0a:	6863      	ldr	r3, [r4, #4]
 8003b0c:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003b10:	009b      	lsls	r3, r3, #2
 8003b12:	4368      	muls	r0, r5
 8003b14:	fbb0 f0f3 	udiv	r0, r0, r3
 8003b18:	fbb0 f0f9 	udiv	r0, r0, r9
 8003b1c:	fb09 6610 	mls	r6, r9, r0, r6
 8003b20:	f7ff fbec 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003b24:	fbb8 f8f9 	udiv	r8, r8, r9
 8003b28:	6861      	ldr	r1, [r4, #4]
 8003b2a:	0136      	lsls	r6, r6, #4
 8003b2c:	4368      	muls	r0, r5
 8003b2e:	0089      	lsls	r1, r1, #2
 8003b30:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8003b34:	3632      	adds	r6, #50	; 0x32
 8003b36:	fbb0 faf1 	udiv	sl, r0, r1
 8003b3a:	fbb6 f6f9 	udiv	r6, r6, r9
 8003b3e:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8003b42:	f7ff fbdb 	bl	80032fc <HAL_RCC_GetPCLK2Freq>
 8003b46:	e02f      	b.n	8003ba8 <UART_SetConfig+0x20c>
    }
    else
    {
      huart->Instance->BRR = UART_BRR_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate);
 8003b48:	f7ff fbc0 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003b4c:	6863      	ldr	r3, [r4, #4]
 8003b4e:	2519      	movs	r5, #25
 8003b50:	ea4f 0883 	mov.w	r8, r3, lsl #2
 8003b54:	4368      	muls	r0, r5
 8003b56:	fbb0 f8f8 	udiv	r8, r0, r8
 8003b5a:	f7ff fbb7 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003b5e:	6866      	ldr	r6, [r4, #4]
 8003b60:	4368      	muls	r0, r5
 8003b62:	00b6      	lsls	r6, r6, #2
 8003b64:	fbb0 f6f6 	udiv	r6, r0, r6
 8003b68:	f7ff fbb0 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003b6c:	6863      	ldr	r3, [r4, #4]
 8003b6e:	f04f 0964 	mov.w	r9, #100	; 0x64
 8003b72:	009b      	lsls	r3, r3, #2
 8003b74:	4368      	muls	r0, r5
 8003b76:	fbb0 f0f3 	udiv	r0, r0, r3
 8003b7a:	fbb0 f0f9 	udiv	r0, r0, r9
 8003b7e:	fb09 6610 	mls	r6, r9, r0, r6
 8003b82:	f7ff fba3 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003b86:	fbb8 f8f9 	udiv	r8, r8, r9
 8003b8a:	6861      	ldr	r1, [r4, #4]
 8003b8c:	0136      	lsls	r6, r6, #4
 8003b8e:	3632      	adds	r6, #50	; 0x32
 8003b90:	4368      	muls	r0, r5
 8003b92:	fbb6 f6f9 	udiv	r6, r6, r9
 8003b96:	0089      	lsls	r1, r1, #2
 8003b98:	ea4f 1808 	mov.w	r8, r8, lsl #4
 8003b9c:	f006 06f0 	and.w	r6, r6, #240	; 0xf0
 8003ba0:	fbb0 faf1 	udiv	sl, r0, r1
 8003ba4:	f7ff fb92 	bl	80032cc <HAL_RCC_GetPCLK1Freq>
 8003ba8:	4345      	muls	r5, r0
 8003baa:	6860      	ldr	r0, [r4, #4]
 8003bac:	0080      	lsls	r0, r0, #2
 8003bae:	fbb5 f0f0 	udiv	r0, r5, r0
 8003bb2:	fbb0 f0f9 	udiv	r0, r0, r9
 8003bb6:	fb09 a210 	mls	r2, r9, r0, sl
 8003bba:	0112      	lsls	r2, r2, #4
 8003bbc:	3232      	adds	r2, #50	; 0x32
 8003bbe:	fbb2 f3f9 	udiv	r3, r2, r9
 8003bc2:	f003 030f 	and.w	r3, r3, #15
 8003bc6:	4433      	add	r3, r6
 8003bc8:	4443      	add	r3, r8
 8003bca:	60bb      	str	r3, [r7, #8]
 8003bcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8003bd0:	40011000 	.word	0x40011000
 8003bd4:	40011400 	.word	0x40011400

08003bd8 <HAL_UART_Init>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
 8003bd8:	b510      	push	{r4, lr}
  /* Check the UART handle allocation */
  if(huart == NULL)
 8003bda:	4604      	mov	r4, r0
 8003bdc:	b340      	cbz	r0, 8003c30 <HAL_UART_Init+0x58>
    assert_param(IS_UART_INSTANCE(huart->Instance));
  }
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  assert_param(IS_UART_OVERSAMPLING(huart->Init.OverSampling));
  
  if(huart->gState == HAL_UART_STATE_RESET)
 8003bde:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8003be2:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8003be6:	b91b      	cbnz	r3, 8003bf0 <HAL_UART_Init+0x18>
  {  
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
 8003be8:	f880 2038 	strb.w	r2, [r0, #56]	; 0x38
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
 8003bec:	f7fc ff3a 	bl	8000a64 <HAL_UART_MspInit>
  }

  huart->gState = HAL_UART_STATE_BUSY;

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8003bf0:	6822      	ldr	r2, [r4, #0]
    huart->Lock = HAL_UNLOCKED;
    /* Init the low level hardware */
    HAL_UART_MspInit(huart);
  }

  huart->gState = HAL_UART_STATE_BUSY;
 8003bf2:	2324      	movs	r3, #36	; 0x24
 8003bf4:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39

  /* Disable the peripheral */
  __HAL_UART_DISABLE(huart);
 8003bf8:	68d3      	ldr	r3, [r2, #12]
 8003bfa:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8003bfe:	60d3      	str	r3, [r2, #12]
  
  /* Set the UART Communication parameters */
  UART_SetConfig(huart);
 8003c00:	4620      	mov	r0, r4
 8003c02:	f7ff fecb 	bl	800399c <UART_SetConfig>
  
  /* In asynchronous mode, the following bits must be kept cleared: 
     - LINEN and CLKEN bits in the USART_CR2 register,
     - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003c06:	6823      	ldr	r3, [r4, #0]
 8003c08:	691a      	ldr	r2, [r3, #16]
 8003c0a:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8003c0e:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003c10:	695a      	ldr	r2, [r3, #20]
 8003c12:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8003c16:	615a      	str	r2, [r3, #20]
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
 8003c18:	68da      	ldr	r2, [r3, #12]
 8003c1a:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8003c1e:	60da      	str	r2, [r3, #12]
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c20:	2000      	movs	r0, #0
  huart->gState= HAL_UART_STATE_READY;
 8003c22:	2320      	movs	r3, #32
  
  /* Enable the peripheral */
  __HAL_UART_ENABLE(huart);
  
  /* Initialize the UART state */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c24:	63e0      	str	r0, [r4, #60]	; 0x3c
  huart->gState= HAL_UART_STATE_READY;
 8003c26:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
  huart->RxState= HAL_UART_STATE_READY;
 8003c2a:	f884 303a 	strb.w	r3, [r4, #58]	; 0x3a
  
  return HAL_OK;
 8003c2e:	bd10      	pop	{r4, pc}
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
  /* Check the UART handle allocation */
  if(huart == NULL)
  {
    return HAL_ERROR;
 8003c30:	2001      	movs	r0, #1
  huart->ErrorCode = HAL_UART_ERROR_NONE;
  huart->gState= HAL_UART_STATE_READY;
  huart->RxState= HAL_UART_STATE_READY;
  
  return HAL_OK;
}
 8003c32:	bd10      	pop	{r4, pc}

08003c34 <HAL_UART_Transmit_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
 8003c34:	f890 3039 	ldrb.w	r3, [r0, #57]	; 0x39
 8003c38:	2b20      	cmp	r3, #32
 8003c3a:	d118      	bne.n	8003c6e <HAL_UART_Transmit_IT+0x3a>
  {
    if((pData == NULL ) || (Size == 0U)) 
 8003c3c:	b1a9      	cbz	r1, 8003c6a <HAL_UART_Transmit_IT+0x36>
 8003c3e:	b1a2      	cbz	r2, 8003c6a <HAL_UART_Transmit_IT+0x36>
    {
      return HAL_ERROR;
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 8003c40:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003c44:	2b01      	cmp	r3, #1
 8003c46:	d012      	beq.n	8003c6e <HAL_UART_Transmit_IT+0x3a>
    
    huart->pTxBuffPtr = pData;
 8003c48:	6201      	str	r1, [r0, #32]
    huart->TxXferSize = Size;
 8003c4a:	8482      	strh	r2, [r0, #36]	; 0x24
    huart->TxXferCount = Size;
 8003c4c:	84c2      	strh	r2, [r0, #38]	; 0x26

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c4e:	2300      	movs	r3, #0

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8003c50:	6801      	ldr	r1, [r0, #0]
    
    huart->pTxBuffPtr = pData;
    huart->TxXferSize = Size;
    huart->TxXferCount = Size;

    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c52:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003c54:	2221      	movs	r2, #33	; 0x21
 8003c56:	f880 2039 	strb.w	r2, [r0, #57]	; 0x39

    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8003c5a:	68ca      	ldr	r2, [r1, #12]

    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->gState = HAL_UART_STATE_BUSY_TX;

    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8003c5c:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    /* Enable the UART Transmit data register empty Interrupt */
    SET_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8003c60:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8003c64:	60ca      	str	r2, [r1, #12]
    
    return HAL_OK;
 8003c66:	4618      	mov	r0, r3
 8003c68:	4770      	bx	lr
  /* Check that a Tx process is not already ongoing */
  if(huart->gState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0U)) 
    {
      return HAL_ERROR;
 8003c6a:	2001      	movs	r0, #1
 8003c6c:	4770      	bx	lr
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;   
 8003c6e:	2002      	movs	r0, #2
  }
}
 8003c70:	4770      	bx	lr

08003c72 <HAL_UART_Receive_IT>:
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
{
  /* Check that a Rx process is not already ongoing */ 
  if(huart->RxState == HAL_UART_STATE_READY)
 8003c72:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8003c76:	2b20      	cmp	r3, #32
 8003c78:	d11c      	bne.n	8003cb4 <HAL_UART_Receive_IT+0x42>
  {
    if((pData == NULL ) || (Size == 0U)) 
 8003c7a:	b1c9      	cbz	r1, 8003cb0 <HAL_UART_Receive_IT+0x3e>
 8003c7c:	b1c2      	cbz	r2, 8003cb0 <HAL_UART_Receive_IT+0x3e>
    {
      return HAL_ERROR;
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
 8003c7e:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
 8003c82:	2b01      	cmp	r3, #1
 8003c84:	d016      	beq.n	8003cb4 <HAL_UART_Receive_IT+0x42>
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
 8003c86:	8582      	strh	r2, [r0, #44]	; 0x2c
    huart->RxXferCount = Size;
 8003c88:	85c2      	strh	r2, [r0, #46]	; 0x2e
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c8a:	2300      	movs	r3, #0
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003c8c:	2222      	movs	r2, #34	; 0x22
    
    huart->pRxBuffPtr = pData;
    huart->RxXferSize = Size;
    huart->RxXferCount = Size;
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003c8e:	63c3      	str	r3, [r0, #60]	; 0x3c
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003c90:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003c94:	6802      	ldr	r2, [r0, #0]
    }
    
    /* Process Locked */
    __HAL_LOCK(huart);
    
    huart->pRxBuffPtr = pData;
 8003c96:	6281      	str	r1, [r0, #40]	; 0x28
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003c98:	6951      	ldr	r1, [r2, #20]
    
    huart->ErrorCode = HAL_UART_ERROR_NONE;
    huart->RxState = HAL_UART_STATE_BUSY_RX;
    
    /* Process Unlocked */
    __HAL_UNLOCK(huart);
 8003c9a:	f880 3038 	strb.w	r3, [r0, #56]	; 0x38

    /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */
    SET_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003c9e:	f041 0101 	orr.w	r1, r1, #1
 8003ca2:	6151      	str	r1, [r2, #20]

    /* Enable the UART Parity Error and Data Register not empty Interrupts */
    SET_BIT(huart->Instance->CR1, USART_CR1_PEIE | USART_CR1_RXNEIE);
 8003ca4:	68d1      	ldr	r1, [r2, #12]
 8003ca6:	f441 7190 	orr.w	r1, r1, #288	; 0x120
 8003caa:	60d1      	str	r1, [r2, #12]
    
    return HAL_OK;
 8003cac:	4618      	mov	r0, r3
 8003cae:	4770      	bx	lr
  /* Check that a Rx process is not already ongoing */ 
  if(huart->RxState == HAL_UART_STATE_READY)
  {
    if((pData == NULL ) || (Size == 0U)) 
    {
      return HAL_ERROR;
 8003cb0:	2001      	movs	r0, #1
 8003cb2:	4770      	bx	lr
    
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY; 
 8003cb4:	2002      	movs	r0, #2
  }
}
 8003cb6:	4770      	bx	lr

08003cb8 <UART_Receive_IT>:
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8003cb8:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
 8003cbc:	2b22      	cmp	r3, #34	; 0x22
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_Receive_IT(UART_HandleTypeDef *huart)
{
 8003cbe:	b510      	push	{r4, lr}
  uint16_t* tmp;
  
  /* Check that a Rx process is ongoing */
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
 8003cc0:	d132      	bne.n	8003d28 <UART_Receive_IT+0x70>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8003cc2:	6883      	ldr	r3, [r0, #8]
 8003cc4:	6901      	ldr	r1, [r0, #16]
 8003cc6:	6802      	ldr	r2, [r0, #0]
 8003cc8:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8003ccc:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8003cce:	d10b      	bne.n	8003ce8 <UART_Receive_IT+0x30>
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8003cd0:	6852      	ldr	r2, [r2, #4]
  if(huart->RxState == HAL_UART_STATE_BUSY_RX) 
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
    {
      tmp = (uint16_t*) huart->pRxBuffPtr;
      if(huart->Init.Parity == UART_PARITY_NONE)
 8003cd2:	b921      	cbnz	r1, 8003cde <UART_Receive_IT+0x26>
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x01FFU);
 8003cd4:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8003cd8:	f823 2b02 	strh.w	r2, [r3], #2
 8003cdc:	e002      	b.n	8003ce4 <UART_Receive_IT+0x2c>
        huart->pRxBuffPtr += 2U;
      }
      else
      {
        *tmp = (uint16_t)(huart->Instance->DR & (uint16_t)0x00FFU);
 8003cde:	b2d2      	uxtb	r2, r2
 8003ce0:	f823 2b01 	strh.w	r2, [r3], #1
        huart->pRxBuffPtr += 1U;
 8003ce4:	6283      	str	r3, [r0, #40]	; 0x28
 8003ce6:	e00a      	b.n	8003cfe <UART_Receive_IT+0x46>
      }
    }
    else
    {
      if(huart->Init.Parity == UART_PARITY_NONE)
 8003ce8:	b919      	cbnz	r1, 8003cf2 <UART_Receive_IT+0x3a>
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x00FFU);
 8003cea:	1c59      	adds	r1, r3, #1
 8003cec:	6281      	str	r1, [r0, #40]	; 0x28
 8003cee:	6852      	ldr	r2, [r2, #4]
 8003cf0:	e004      	b.n	8003cfc <UART_Receive_IT+0x44>
      }
      else
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
 8003cf2:	6852      	ldr	r2, [r2, #4]
 8003cf4:	1c59      	adds	r1, r3, #1
 8003cf6:	6281      	str	r1, [r0, #40]	; 0x28
 8003cf8:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8003cfc:	701a      	strb	r2, [r3, #0]
      }
    }

    if(--huart->RxXferCount == 0U)
 8003cfe:	8dc4      	ldrh	r4, [r0, #46]	; 0x2e
 8003d00:	3c01      	subs	r4, #1
 8003d02:	b2a4      	uxth	r4, r4
 8003d04:	85c4      	strh	r4, [r0, #46]	; 0x2e
 8003d06:	b98c      	cbnz	r4, 8003d2c <UART_Receive_IT+0x74>
    {
      /* Disable the UART Parity Error Interrupt and RXNE interrupt*/
      CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE));
 8003d08:	6803      	ldr	r3, [r0, #0]
 8003d0a:	68da      	ldr	r2, [r3, #12]
 8003d0c:	f422 7290 	bic.w	r2, r2, #288	; 0x120
 8003d10:	60da      	str	r2, [r3, #12]

      /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */
      CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003d12:	695a      	ldr	r2, [r3, #20]
 8003d14:	f022 0201 	bic.w	r2, r2, #1
 8003d18:	615a      	str	r2, [r3, #20]

      /* Rx process is completed, restore huart->RxState to Ready */
      huart->RxState = HAL_UART_STATE_READY;
 8003d1a:	2320      	movs	r3, #32
 8003d1c:	f880 303a 	strb.w	r3, [r0, #58]	; 0x3a
     
      HAL_UART_RxCpltCallback(huart);
 8003d20:	f7fc fc3a 	bl	8000598 <HAL_UART_RxCpltCallback>
 8003d24:	4620      	mov	r0, r4
 8003d26:	bd10      	pop	{r4, pc}
    }
    return HAL_OK;
  }
  else
  {
    return HAL_BUSY;
 8003d28:	2002      	movs	r0, #2
 8003d2a:	bd10      	pop	{r4, pc}
      {
        *huart->pRxBuffPtr++ = (uint8_t)(huart->Instance->DR & (uint8_t)0x007FU);
      }
    }

    if(--huart->RxXferCount == 0U)
 8003d2c:	2000      	movs	r0, #0
  }
  else
  {
    return HAL_BUSY;
  }
}
 8003d2e:	bd10      	pop	{r4, pc}

08003d30 <HAL_UART_ErrorCallback>:
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
 __weak void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
{
 8003d30:	4770      	bx	lr
	...

08003d34 <HAL_UART_IRQHandler>:
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
 8003d34:	6803      	ldr	r3, [r0, #0]
 8003d36:	681a      	ldr	r2, [r3, #0]
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
 8003d38:	68d9      	ldr	r1, [r3, #12]
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8003d3a:	b570      	push	{r4, r5, r6, lr}
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8003d3c:	0716      	lsls	r6, r2, #28
  * @param  huart: pointer to a UART_HandleTypeDef structure that contains
  *                the configuration information for the specified UART module.
  * @retval None
  */
void HAL_UART_IRQHandler(UART_HandleTypeDef *huart)
{
 8003d3e:	4604      	mov	r4, r0
   uint32_t isrflags   = READ_REG(huart->Instance->SR);
   uint32_t cr1its     = READ_REG(huart->Instance->CR1);
   uint32_t cr3its     = READ_REG(huart->Instance->CR3);
 8003d40:	695d      	ldr	r5, [r3, #20]
   uint32_t errorflags = 0x00U;
   uint32_t dmarequest = 0x00U;

  /* If no error occurs */
  errorflags = (isrflags & (uint32_t)(USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
  if(errorflags == RESET)
 8003d42:	d107      	bne.n	8003d54 <HAL_UART_IRQHandler+0x20>
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8003d44:	0696      	lsls	r6, r2, #26
 8003d46:	d55a      	bpl.n	8003dfe <HAL_UART_IRQHandler+0xca>
 8003d48:	068d      	lsls	r5, r1, #26
 8003d4a:	d558      	bpl.n	8003dfe <HAL_UART_IRQHandler+0xca>
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8003d4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  if(errorflags == RESET)
  {
    /* UART in mode Receiver -------------------------------------------------*/
    if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
    {
      UART_Receive_IT(huart);
 8003d50:	f7ff bfb2 	b.w	8003cb8 <UART_Receive_IT>
      return;
    }
  }

  /* If some errors occur */
  if((errorflags != RESET) && (((cr3its & USART_CR3_EIE) != RESET) || ((cr1its & (USART_CR1_RXNEIE | USART_CR1_PEIE)) != RESET)))
 8003d54:	f015 0001 	ands.w	r0, r5, #1
 8003d58:	d102      	bne.n	8003d60 <HAL_UART_IRQHandler+0x2c>
 8003d5a:	f411 7f90 	tst.w	r1, #288	; 0x120
 8003d5e:	d04e      	beq.n	8003dfe <HAL_UART_IRQHandler+0xca>
  {
    /* UART parity error interrupt occurred ----------------------------------*/
    if(((isrflags & USART_SR_PE) != RESET) && ((cr1its & USART_CR1_PEIE) != RESET))
 8003d60:	07d3      	lsls	r3, r2, #31
 8003d62:	d505      	bpl.n	8003d70 <HAL_UART_IRQHandler+0x3c>
 8003d64:	05ce      	lsls	r6, r1, #23
    {
      huart->ErrorCode |= HAL_UART_ERROR_PE;
 8003d66:	bf42      	ittt	mi
 8003d68:	6be3      	ldrmi	r3, [r4, #60]	; 0x3c
 8003d6a:	f043 0301 	orrmi.w	r3, r3, #1
 8003d6e:	63e3      	strmi	r3, [r4, #60]	; 0x3c
    }
    
    /* UART noise error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_NE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8003d70:	0755      	lsls	r5, r2, #29
 8003d72:	d504      	bpl.n	8003d7e <HAL_UART_IRQHandler+0x4a>
 8003d74:	b118      	cbz	r0, 8003d7e <HAL_UART_IRQHandler+0x4a>
    {
      huart->ErrorCode |= HAL_UART_ERROR_NE;
 8003d76:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003d78:	f043 0302 	orr.w	r3, r3, #2
 8003d7c:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART frame error interrupt occurred -----------------------------------*/
    if(((isrflags & USART_SR_FE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8003d7e:	0793      	lsls	r3, r2, #30
 8003d80:	d504      	bpl.n	8003d8c <HAL_UART_IRQHandler+0x58>
 8003d82:	b118      	cbz	r0, 8003d8c <HAL_UART_IRQHandler+0x58>
    {
      huart->ErrorCode |= HAL_UART_ERROR_FE;
 8003d84:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003d86:	f043 0304 	orr.w	r3, r3, #4
 8003d8a:	63e3      	str	r3, [r4, #60]	; 0x3c
    }
    
    /* UART Over-Run interrupt occurred --------------------------------------*/
    if(((isrflags & USART_SR_ORE) != RESET) && ((cr3its & USART_CR3_EIE) != RESET))
 8003d8c:	0716      	lsls	r6, r2, #28
 8003d8e:	d504      	bpl.n	8003d9a <HAL_UART_IRQHandler+0x66>
 8003d90:	b118      	cbz	r0, 8003d9a <HAL_UART_IRQHandler+0x66>
    { 
      huart->ErrorCode |= HAL_UART_ERROR_ORE;
 8003d92:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003d94:	f043 0308 	orr.w	r3, r3, #8
 8003d98:	63e3      	str	r3, [r4, #60]	; 0x3c
    }

    /* Call UART Error Call back function if need be --------------------------*/    
    if(huart->ErrorCode != HAL_UART_ERROR_NONE)
 8003d9a:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003d9c:	2b00      	cmp	r3, #0
 8003d9e:	d066      	beq.n	8003e6e <HAL_UART_IRQHandler+0x13a>
    {
      /* UART in mode Receiver -----------------------------------------------*/
      if(((isrflags & USART_SR_RXNE) != RESET) && ((cr1its & USART_CR1_RXNEIE) != RESET))
 8003da0:	0695      	lsls	r5, r2, #26
 8003da2:	d504      	bpl.n	8003dae <HAL_UART_IRQHandler+0x7a>
 8003da4:	0688      	lsls	r0, r1, #26
 8003da6:	d502      	bpl.n	8003dae <HAL_UART_IRQHandler+0x7a>
      {
        UART_Receive_IT(huart);
 8003da8:	4620      	mov	r0, r4
 8003daa:	f7ff ff85 	bl	8003cb8 <UART_Receive_IT>
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
 8003dae:	6823      	ldr	r3, [r4, #0]
 8003db0:	695b      	ldr	r3, [r3, #20]
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8003db2:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8003db4:	0711      	lsls	r1, r2, #28
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8003db6:	4620      	mov	r0, r4
      }

      /* If Overrun error occurs, or if any error occurs in DMA mode reception,
         consider error as blocking */
      dmarequest = HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR);
      if(((huart->ErrorCode & HAL_UART_ERROR_ORE) != RESET) || dmarequest)
 8003db8:	d402      	bmi.n	8003dc0 <HAL_UART_IRQHandler+0x8c>
 8003dba:	f013 0540 	ands.w	r5, r3, #64	; 0x40
 8003dbe:	d01a      	beq.n	8003df6 <HAL_UART_IRQHandler+0xc2>
      {
        /* Blocking error : transfer is aborted
           Set the UART state ready to be able to start again the process,
           Disable Rx Interrupts, and disable Rx DMA request, if ongoing */
        UART_EndRxTransfer(huart);
 8003dc0:	f7ff fdde 	bl	8003980 <UART_EndRxTransfer>
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
 8003dc4:	6823      	ldr	r3, [r4, #0]
 8003dc6:	695a      	ldr	r2, [r3, #20]
 8003dc8:	0652      	lsls	r2, r2, #25
 8003dca:	d510      	bpl.n	8003dee <HAL_UART_IRQHandler+0xba>
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003dcc:	695a      	ldr	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8003dce:	6b60      	ldr	r0, [r4, #52]	; 0x34
        UART_EndRxTransfer(huart);
        
        /* Disable the UART DMA Rx request if enabled */
        if(HAL_IS_BIT_SET(huart->Instance->CR3, USART_CR3_DMAR))
        {
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_DMAR);
 8003dd0:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003dd4:	615a      	str	r2, [r3, #20]
          
          /* Abort the UART DMA Rx channel */
          if(huart->hdmarx != NULL)
 8003dd6:	b150      	cbz	r0, 8003dee <HAL_UART_IRQHandler+0xba>
          {
            /* Set the UART DMA Abort callback : 
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
 8003dd8:	4b25      	ldr	r3, [pc, #148]	; (8003e70 <HAL_UART_IRQHandler+0x13c>)
 8003dda:	6503      	str	r3, [r0, #80]	; 0x50
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
 8003ddc:	f7fd ffb3 	bl	8001d46 <HAL_DMA_Abort_IT>
 8003de0:	2800      	cmp	r0, #0
 8003de2:	d044      	beq.n	8003e6e <HAL_UART_IRQHandler+0x13a>
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003de4:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
  {
    UART_EndTransmit_IT(huart);
    return;
  }
}
 8003de6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
               will lead to call HAL_UART_ErrorCallback() at end of DMA abort procedure */
            huart->hdmarx->XferAbortCallback = UART_DMAAbortOnError;
            if(HAL_DMA_Abort_IT(huart->hdmarx) != HAL_OK)
            {
              /* Call Directly XferAbortCallback function in case of error */
              huart->hdmarx->XferAbortCallback(huart->hdmarx);
 8003dea:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8003dec:	4718      	bx	r3
            }
          }
          else
          {
            /* Call user error callback */
            HAL_UART_ErrorCallback(huart);
 8003dee:	4620      	mov	r0, r4
 8003df0:	f7ff ff9e 	bl	8003d30 <HAL_UART_ErrorCallback>
 8003df4:	bd70      	pop	{r4, r5, r6, pc}
      }
      else
      {
        /* Non Blocking error : transfer could go on. 
           Error is notified to user through user error callback */
        HAL_UART_ErrorCallback(huart);
 8003df6:	f7ff ff9b 	bl	8003d30 <HAL_UART_ErrorCallback>
        huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003dfa:	63e5      	str	r5, [r4, #60]	; 0x3c
 8003dfc:	bd70      	pop	{r4, r5, r6, pc}
    }
    return;
  } /* End if some error occurs */

  /* UART in mode Transmitter ------------------------------------------------*/
  if(((isrflags & USART_SR_TXE) != RESET) && ((cr1its & USART_CR1_TXEIE) != RESET))
 8003dfe:	0616      	lsls	r6, r2, #24
 8003e00:	d527      	bpl.n	8003e52 <HAL_UART_IRQHandler+0x11e>
 8003e02:	060d      	lsls	r5, r1, #24
 8003e04:	d525      	bpl.n	8003e52 <HAL_UART_IRQHandler+0x11e>
static HAL_StatusTypeDef UART_Transmit_IT(UART_HandleTypeDef *huart)
{
  uint16_t* tmp;
  
  /* Check that a Tx process is ongoing */
  if(huart->gState == HAL_UART_STATE_BUSY_TX)
 8003e06:	f894 2039 	ldrb.w	r2, [r4, #57]	; 0x39
 8003e0a:	2a21      	cmp	r2, #33	; 0x21
 8003e0c:	d12f      	bne.n	8003e6e <HAL_UART_IRQHandler+0x13a>
  {
    if(huart->Init.WordLength == UART_WORDLENGTH_9B)
 8003e0e:	68a2      	ldr	r2, [r4, #8]
 8003e10:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
 8003e14:	6a22      	ldr	r2, [r4, #32]
 8003e16:	d10a      	bne.n	8003e2e <HAL_UART_IRQHandler+0xfa>
    {
      tmp = (uint16_t*) huart->pTxBuffPtr;
      huart->Instance->DR = (uint16_t)(*tmp & (uint16_t)0x01FFU);
 8003e18:	8811      	ldrh	r1, [r2, #0]
 8003e1a:	f3c1 0108 	ubfx	r1, r1, #0, #9
 8003e1e:	6059      	str	r1, [r3, #4]
      if(huart->Init.Parity == UART_PARITY_NONE)
 8003e20:	6921      	ldr	r1, [r4, #16]
 8003e22:	b909      	cbnz	r1, 8003e28 <HAL_UART_IRQHandler+0xf4>
      {
        huart->pTxBuffPtr += 2U;
 8003e24:	3202      	adds	r2, #2
 8003e26:	e000      	b.n	8003e2a <HAL_UART_IRQHandler+0xf6>
      }
      else
      {
        huart->pTxBuffPtr += 1U;
 8003e28:	3201      	adds	r2, #1
 8003e2a:	6222      	str	r2, [r4, #32]
 8003e2c:	e003      	b.n	8003e36 <HAL_UART_IRQHandler+0x102>
      }
    } 
    else
    {
      huart->Instance->DR = (uint8_t)(*huart->pTxBuffPtr++ & (uint8_t)0x00FFU);
 8003e2e:	1c51      	adds	r1, r2, #1
 8003e30:	6221      	str	r1, [r4, #32]
 8003e32:	7812      	ldrb	r2, [r2, #0]
 8003e34:	605a      	str	r2, [r3, #4]
    }

    if(--huart->TxXferCount == 0U)
 8003e36:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 8003e38:	3a01      	subs	r2, #1
 8003e3a:	b292      	uxth	r2, r2
 8003e3c:	84e2      	strh	r2, [r4, #38]	; 0x26
 8003e3e:	b9b2      	cbnz	r2, 8003e6e <HAL_UART_IRQHandler+0x13a>
    {
      /* Disable the UART Transmit Complete Interrupt */
      CLEAR_BIT(huart->Instance->CR1, USART_CR1_TXEIE);
 8003e40:	68da      	ldr	r2, [r3, #12]
 8003e42:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003e46:	60da      	str	r2, [r3, #12]

      /* Enable the UART Transmit Complete Interrupt */    
      SET_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003e48:	68da      	ldr	r2, [r3, #12]
 8003e4a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8003e4e:	60da      	str	r2, [r3, #12]
 8003e50:	bd70      	pop	{r4, r5, r6, pc}
    UART_Transmit_IT(huart);
    return;
  }
  
  /* UART in mode Transmitter end --------------------------------------------*/
  if(((isrflags & USART_SR_TC) != RESET) && ((cr1its & USART_CR1_TCIE) != RESET))
 8003e52:	0650      	lsls	r0, r2, #25
 8003e54:	d50b      	bpl.n	8003e6e <HAL_UART_IRQHandler+0x13a>
 8003e56:	064a      	lsls	r2, r1, #25
 8003e58:	d509      	bpl.n	8003e6e <HAL_UART_IRQHandler+0x13a>
  * @retval HAL status
  */
static HAL_StatusTypeDef UART_EndTransmit_IT(UART_HandleTypeDef *huart)
{
  /* Disable the UART Transmit Complete Interrupt */    
  CLEAR_BIT(huart->Instance->CR1, USART_CR1_TCIE);
 8003e5a:	68da      	ldr	r2, [r3, #12]
 8003e5c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8003e60:	60da      	str	r2, [r3, #12]
  
  /* Tx process is ended, restore huart->gState to Ready */
  huart->gState = HAL_UART_STATE_READY;
 8003e62:	2320      	movs	r3, #32
 8003e64:	f884 3039 	strb.w	r3, [r4, #57]	; 0x39
    
  HAL_UART_TxCpltCallback(huart);
 8003e68:	4620      	mov	r0, r4
 8003e6a:	f7fc fba5 	bl	80005b8 <HAL_UART_TxCpltCallback>
 8003e6e:	bd70      	pop	{r4, r5, r6, pc}
 8003e70:	08003e75 	.word	0x08003e75

08003e74 <UART_DMAAbortOnError>:
  *         (To be called at end of DMA Abort procedure following error occurrence).
  * @param  hdma DMA handle.
  * @retval None
  */
static void UART_DMAAbortOnError(DMA_HandleTypeDef *hdma)
{
 8003e74:	b508      	push	{r3, lr}
  UART_HandleTypeDef* huart = ( UART_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
 8003e76:	6b80      	ldr	r0, [r0, #56]	; 0x38
  huart->RxXferCount = 0;
 8003e78:	2300      	movs	r3, #0
 8003e7a:	85c3      	strh	r3, [r0, #46]	; 0x2e
  huart->TxXferCount = 0;
 8003e7c:	84c3      	strh	r3, [r0, #38]	; 0x26

  HAL_UART_ErrorCallback(huart);
 8003e7e:	f7ff ff57 	bl	8003d30 <HAL_UART_ErrorCallback>
 8003e82:	bd08      	pop	{r3, pc}

08003e84 <FMC_SDRAM_Init>:
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8003e84:	680b      	ldr	r3, [r1, #0]
 8003e86:	6a0a      	ldr	r2, [r1, #32]
 8003e88:	2b01      	cmp	r3, #1
  * @param  Device: Pointer to SDRAM device instance
  * @param  Init: Pointer to SDRAM Initialization structure   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_InitTypeDef *Init)
{
 8003e8a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003e8e:	688b      	ldr	r3, [r1, #8]
 8003e90:	f8d1 e004 	ldr.w	lr, [r1, #4]
 8003e94:	68cf      	ldr	r7, [r1, #12]
 8003e96:	690e      	ldr	r6, [r1, #16]
 8003e98:	694d      	ldr	r5, [r1, #20]
 8003e9a:	698c      	ldr	r4, [r1, #24]
 8003e9c:	f8d1 a01c 	ldr.w	sl, [r1, #28]
 8003ea0:	f8d1 9024 	ldr.w	r9, [r1, #36]	; 0x24
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
  {    
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
 8003ea4:	6801      	ldr	r1, [r0, #0]
  assert_param(IS_FMC_SDCLOCK_PERIOD(Init->SDClockPeriod));
  assert_param(IS_FMC_READ_BURST(Init->ReadBurst));
  assert_param(IS_FMC_READPIPE_DELAY(Init->ReadPipeDelay));   

  /* Set SDRAM bank configuration parameters */
  if (Init->SDBank != FMC_SDRAM_BANK2) 
 8003ea6:	d013      	beq.n	8003ed0 <FMC_SDRAM_Init+0x4c>
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
  
  
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ea8:	ea4e 0e03 	orr.w	lr, lr, r3
 8003eac:	ea4e 0707 	orr.w	r7, lr, r7
 8003eb0:	433e      	orrs	r6, r7
 8003eb2:	4335      	orrs	r5, r6
 8003eb4:	432c      	orrs	r4, r5
  if (Init->SDBank != FMC_SDRAM_BANK2) 
  {    
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8003eb6:	f421 48ff 	bic.w	r8, r1, #32640	; 0x7f80
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
  
  
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003eba:	ea44 010a 	orr.w	r1, r4, sl
 8003ebe:	430a      	orrs	r2, r1
  if (Init->SDBank != FMC_SDRAM_BANK2) 
  {    
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8003ec0:	f028 087f 	bic.w	r8, r8, #127	; 0x7f
                         FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                         FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
  
  
    tmpr1 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ec4:	ea42 0309 	orr.w	r3, r2, r9
 8003ec8:	ea43 0308 	orr.w	r3, r3, r8
                                               Init->WriteProtection    |\
                                               Init->SDClockPeriod      |\
                                               Init->ReadBurst          |\
                                               Init->ReadPipeDelay
                                               );
    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8003ecc:	6003      	str	r3, [r0, #0]
 8003ece:	e017      	b.n	8003f00 <FMC_SDRAM_Init+0x7c>
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8003ed0:	ea4a 0202 	orr.w	r2, sl, r2
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ed4:	ea4e 0e03 	orr.w	lr, lr, r3
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8003ed8:	ea42 0909 	orr.w	r9, r2, r9
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003edc:	ea4e 0707 	orr.w	r7, lr, r7
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
                        Init->ReadBurst          |\
                        Init->ReadPipeDelay);  
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
 8003ee0:	6842      	ldr	r2, [r0, #4]
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ee2:	433e      	orrs	r6, r7
                        Init->ReadPipeDelay);  
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8003ee4:	f422 4cff 	bic.w	ip, r2, #32640	; 0x7f80
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ee8:	4335      	orrs	r5, r6
  else /* FMC_Bank2_SDRAM */                      
  {
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
 8003eea:	f421 41f8 	bic.w	r1, r1, #31744	; 0x7c00
                        Init->ReadPipeDelay);  
    
    tmpr2 = Device->SDCR[FMC_SDRAM_BANK2];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
 8003eee:	f02c 0c7f 	bic.w	ip, ip, #127	; 0x7f
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ef2:	432c      	orrs	r4, r5
    tmpr1 = Device->SDCR[FMC_SDRAM_BANK1];
    
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr1 &= ((uint32_t)~(FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));
    
    tmpr1 |= (uint32_t)(Init->SDClockPeriod      |\
 8003ef4:	ea49 0101 	orr.w	r1, r9, r1
    /* Clear NC, NR, MWID, NB, CAS, WP, SDCLK, RBURST, and RPIPE bits */
    tmpr2 &= ((uint32_t)~(FMC_SDCR1_NC  | FMC_SDCR1_NR | FMC_SDCR1_MWID | \
                          FMC_SDCR1_NB  | FMC_SDCR1_CAS | FMC_SDCR1_WP | \
                          FMC_SDCR1_SDCLK | FMC_SDCR1_RBURST | FMC_SDCR1_RPIPE));

    tmpr2 |= (uint32_t)(Init->ColumnBitsNumber   |\
 8003ef8:	ea44 040c 	orr.w	r4, r4, ip
                       Init->MemoryDataWidth    |\
                       Init->InternalBankNumber |\
                       Init->CASLatency         |\
                       Init->WriteProtection);

    Device->SDCR[FMC_SDRAM_BANK1] = tmpr1;
 8003efc:	6001      	str	r1, [r0, #0]
    Device->SDCR[FMC_SDRAM_BANK2] = tmpr2;
 8003efe:	6044      	str	r4, [r0, #4]
  }  
  
  return HAL_OK;
}
 8003f00:	2000      	movs	r0, #0
 8003f02:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08003f06 <FMC_SDRAM_Timing_Init>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Bank: SDRAM bank number   
  * @retval HAL status
  */
HAL_StatusTypeDef FMC_SDRAM_Timing_Init(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_TimingTypeDef *Timing, uint32_t Bank)
{
 8003f06:	b5f0      	push	{r4, r5, r6, r7, lr}
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 8003f08:	2a01      	cmp	r2, #1
 8003f0a:	f101 0404 	add.w	r4, r1, #4
 8003f0e:	680e      	ldr	r6, [r1, #0]
 8003f10:	690a      	ldr	r2, [r1, #16]
 8003f12:	f8d1 e014 	ldr.w	lr, [r1, #20]
 8003f16:	698b      	ldr	r3, [r1, #24]
  { 
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
 8003f18:	6887      	ldr	r7, [r0, #8]
 8003f1a:	e894 1030 	ldmia.w	r4, {r4, r5, ip}
  assert_param(IS_FMC_RP_DELAY(Timing->RPDelay));
  assert_param(IS_FMC_RCD_DELAY(Timing->RCDDelay));
  assert_param(IS_FMC_SDRAM_BANK(Bank));
  
  /* Set SDRAM device timing parameters */ 
  if (Bank != FMC_SDRAM_BANK2) 
 8003f1e:	d019      	beq.n	8003f54 <FMC_SDRAM_Timing_Init+0x4e>
 8003f20:	3e01      	subs	r6, #1
 8003f22:	f007 4770 	and.w	r7, r7, #4026531840	; 0xf0000000
 8003f26:	3c01      	subs	r4, #1
 8003f28:	4337      	orrs	r7, r6
 8003f2a:	ea47 1604 	orr.w	r6, r7, r4, lsl #4
 8003f2e:	3d01      	subs	r5, #1
 8003f30:	f10c 31ff 	add.w	r1, ip, #4294967295
 8003f34:	ea46 2505 	orr.w	r5, r6, r5, lsl #8
 8003f38:	3a01      	subs	r2, #1
 8003f3a:	ea45 3401 	orr.w	r4, r5, r1, lsl #12
 8003f3e:	ea44 4102 	orr.w	r1, r4, r2, lsl #16
 8003f42:	f10e 32ff 	add.w	r2, lr, #4294967295
 8003f46:	ea41 5202 	orr.w	r2, r1, r2, lsl #20
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr1 |= (uint32_t)(((Timing->LoadToActiveDelay)-1U)           |\
 8003f4a:	3b01      	subs	r3, #1
 8003f4c:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
                       (((Timing->SelfRefreshTime)-1U) << 8U)      |\
                       (((Timing->RowCycleDelay)-1U) << 12U)       |\
                       (((Timing->WriteRecoveryTime)-1U) <<16U)    |\
                       (((Timing->RPDelay)-1U) << 20U)             |\
                       (((Timing->RCDDelay)-1U) << 24U));
    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8003f50:	6083      	str	r3, [r0, #8]
 8003f52:	e022      	b.n	8003f9a <FMC_SDRAM_Timing_Init+0x94>
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8003f54:	f10e 3eff 	add.w	lr, lr, #4294967295
 8003f58:	f10c 31ff 	add.w	r1, ip, #4294967295
 8003f5c:	ea4f 5c0e 	mov.w	ip, lr, lsl #20
 8003f60:	ea4c 3e01 	orr.w	lr, ip, r1, lsl #12
   else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8003f64:	f427 0770 	bic.w	r7, r7, #15728640	; 0xf00000
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
                        (((Timing->RPDelay)-1) << 20)); 
    
    tmpr2 = Device->SDTR[FMC_SDRAM_BANK2];
 8003f68:	68c1      	ldr	r1, [r0, #12]
   else /* FMC_Bank2_SDRAM */
  {
    tmpr1 = Device->SDTR[FMC_SDRAM_BANK1];
    
    /* Clear TRC and TRP bits */
    tmpr1 &= ((uint32_t)~(FMC_SDTR1_TRC | FMC_SDTR1_TRP));
 8003f6a:	f427 4770 	bic.w	r7, r7, #61440	; 0xf000
    
    tmpr1 |= (uint32_t)((((Timing->RowCycleDelay)-1) << 12)       |\
 8003f6e:	ea4e 0c07 	orr.w	ip, lr, r7
 8003f72:	3e01      	subs	r6, #1
 8003f74:	f001 4e70 	and.w	lr, r1, #4026531840	; 0xf0000000
 8003f78:	3c01      	subs	r4, #1
 8003f7a:	ea46 070e 	orr.w	r7, r6, lr
 8003f7e:	ea47 1604 	orr.w	r6, r7, r4, lsl #4
 8003f82:	1e6c      	subs	r4, r5, #1
 8003f84:	ea46 2404 	orr.w	r4, r6, r4, lsl #8
 8003f88:	3a01      	subs	r2, #1
 8003f8a:	ea44 4202 	orr.w	r2, r4, r2, lsl #16
    /* Clear TMRD, TXSR, TRAS, TRC, TWR, TRP and TRCD bits */
    tmpr2 &= ((uint32_t)~(FMC_SDTR1_TMRD  | FMC_SDTR1_TXSR | FMC_SDTR1_TRAS | \
                          FMC_SDTR1_TRC  | FMC_SDTR1_TWR | FMC_SDTR1_TRP | \
                          FMC_SDTR1_TRCD));
    
    tmpr2 |= (uint32_t)((((Timing->LoadToActiveDelay)-1)           |\
 8003f8e:	3b01      	subs	r3, #1
 8003f90:	ea42 6303 	orr.w	r3, r2, r3, lsl #24
                       (((Timing->ExitSelfRefreshDelay)-1) << 4)  |\
                       (((Timing->SelfRefreshTime)-1) << 8)       |\
                       (((Timing->WriteRecoveryTime)-1) <<16)     |\
                       (((Timing->RCDDelay)-1) << 24)));   

    Device->SDTR[FMC_SDRAM_BANK1] = tmpr1;
 8003f94:	f8c0 c008 	str.w	ip, [r0, #8]
    Device->SDTR[FMC_SDRAM_BANK2] = tmpr2;
 8003f98:	60c3      	str	r3, [r0, #12]
  }
  return HAL_OK;
}
 8003f9a:	2000      	movs	r0, #0
 8003f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}

08003f9e <FMC_SDRAM_SendCommand>:
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8003f9e:	b573      	push	{r0, r1, r4, r5, r6, lr}
  __IO uint32_t tmpr = 0U;
 8003fa0:	2300      	movs	r3, #0
 8003fa2:	9301      	str	r3, [sp, #4]
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8003fa4:	4604      	mov	r4, r0
  assert_param(IS_FMC_COMMAND_TARGET(Command->CommandTarget));
  assert_param(IS_FMC_AUTOREFRESH_NUMBER(Command->AutoRefreshNumber));
  assert_param(IS_FMC_MODE_REGISTER(Command->ModeRegisterDefinition));  

  /* Set command register */
  tmpr = (uint32_t)((Command->CommandMode)                  |\
 8003fa6:	e891 0009 	ldmia.w	r1, {r0, r3}
 8003faa:	4303      	orrs	r3, r0
 8003fac:	68c8      	ldr	r0, [r1, #12]
 8003fae:	ea43 2040 	orr.w	r0, r3, r0, lsl #9
 8003fb2:	688b      	ldr	r3, [r1, #8]
 8003fb4:	3b01      	subs	r3, #1
 8003fb6:	ea40 1343 	orr.w	r3, r0, r3, lsl #5
 8003fba:	9301      	str	r3, [sp, #4]
                    (Command->CommandTarget)                |\
                    (((Command->AutoRefreshNumber)-1U) << 5U) |\
                    ((Command->ModeRegisterDefinition) << 9U)
                    );
    
  Device->SDCMR = tmpr;
 8003fbc:	9b01      	ldr	r3, [sp, #4]
 8003fbe:	6123      	str	r3, [r4, #16]
  * @param  Timing: Pointer to SDRAM Timing structure
  * @param  Timeout: Timeout wait value
  * @retval HAL state
  */  
HAL_StatusTypeDef FMC_SDRAM_SendCommand(FMC_SDRAM_TypeDef *Device, FMC_SDRAM_CommandTypeDef *Command, uint32_t Timeout)
{
 8003fc0:	4615      	mov	r5, r2
                    );
    
  Device->SDCMR = tmpr;

  /* Get tick */ 
  tickstart = HAL_GetTick();
 8003fc2:	f7fd fd81 	bl	8001ac8 <HAL_GetTick>
 8003fc6:	4606      	mov	r6, r0

  /* Wait until command is send */
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
 8003fc8:	69a0      	ldr	r0, [r4, #24]
 8003fca:	f010 0020 	ands.w	r0, r0, #32
 8003fce:	d00a      	beq.n	8003fe6 <FMC_SDRAM_SendCommand+0x48>
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
 8003fd0:	1c6b      	adds	r3, r5, #1
 8003fd2:	d0f9      	beq.n	8003fc8 <FMC_SDRAM_SendCommand+0x2a>
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8003fd4:	b90d      	cbnz	r5, 8003fda <FMC_SDRAM_SendCommand+0x3c>
      {
        return HAL_TIMEOUT;
 8003fd6:	2003      	movs	r0, #3
 8003fd8:	e005      	b.n	8003fe6 <FMC_SDRAM_SendCommand+0x48>
  while(HAL_IS_BIT_SET(Device->SDSR, FMC_SDSR_BUSY))
  {
    /* Check for the Timeout */
    if(Timeout != HAL_MAX_DELAY)
    {
      if((Timeout == 0U)||((HAL_GetTick() - tickstart ) > Timeout))
 8003fda:	f7fd fd75 	bl	8001ac8 <HAL_GetTick>
 8003fde:	1b80      	subs	r0, r0, r6
 8003fe0:	4285      	cmp	r5, r0
 8003fe2:	d2f1      	bcs.n	8003fc8 <FMC_SDRAM_SendCommand+0x2a>
 8003fe4:	e7f7      	b.n	8003fd6 <FMC_SDRAM_SendCommand+0x38>
      }
    }
  }

  return HAL_OK;
}
 8003fe6:	b002      	add	sp, #8
 8003fe8:	bd70      	pop	{r4, r5, r6, pc}

08003fea <FMC_SDRAM_ProgramRefreshRate>:
  /* Check the parameters */
  assert_param(IS_FMC_SDRAM_DEVICE(Device));
  assert_param(IS_FMC_REFRESH_RATE(RefreshRate));
  
  /* Set the refresh rate in command register */
  Device->SDRTR |= (RefreshRate<<1U);
 8003fea:	6943      	ldr	r3, [r0, #20]
 8003fec:	ea43 0141 	orr.w	r1, r3, r1, lsl #1
 8003ff0:	6141      	str	r1, [r0, #20]
  
  return HAL_OK;   
}
 8003ff2:	2000      	movs	r0, #0
 8003ff4:	4770      	bx	lr
	...

08003ff8 <GUI_X_Config>:
*
* Purpose:
*   Called during the initialization process in order to set up the
*   available memory for the GUI.
*/
void GUI_X_Config(void) {
 8003ff8:	b508      	push	{r3, lr}
  //
  // Assign memory to STemWin
  //
  GUI_ALLOC_AssignMemory(aMemory, GUI_NUMBYTES);
 8003ffa:	4805      	ldr	r0, [pc, #20]	; (8004010 <GUI_X_Config+0x18>)
 8003ffc:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8004000:	f004 f950 	bl	80082a4 <GUI_ALLOC_AssignMemory>
  //
  // Set default font
  //
  GUI_SetDefaultFont(GUI_FONT_6X8);
 8004004:	4803      	ldr	r0, [pc, #12]	; (8004014 <GUI_X_Config+0x1c>)
}
 8004006:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  //
  GUI_ALLOC_AssignMemory(aMemory, GUI_NUMBYTES);
  //
  // Set default font
  //
  GUI_SetDefaultFont(GUI_FONT_6X8);
 800400a:	f003 bccf 	b.w	80079ac <GUI_SetDefaultFont>
 800400e:	bf00      	nop
 8004010:	200021e0 	.word	0x200021e0
 8004014:	08009c64 	.word	0x08009c64

08004018 <DMA2D_CopyBuffer.isra.1>:
/**
  * @brief  Return Pixel format for a given layer
  * @param  LayerIndex : Layer Index
  * @retval Status ( 0 : 0k , 1: error)
  */
static void DMA2D_CopyBuffer(U32 LayerIndex, void * pSrc, void * pDst, U32 xSize, U32 ySize, U32 OffLineSrc, U32 OffLineDst)
 8004018:	b530      	push	{r4, r5, lr}
{
  U32 PixelFormat;

  PixelFormat = LCD_LL_GetPixelformat(LayerIndex);
  DMA2D->CR      = 0x00000000UL | (1 << 9);
 800401a:	4c0c      	ldr	r4, [pc, #48]	; (800404c <DMA2D_CopyBuffer.isra.1+0x34>)
 800401c:	f44f 7500 	mov.w	r5, #512	; 0x200
 8004020:	6025      	str	r5, [r4, #0]

  /* Set up pointers */
  DMA2D->FGMAR   = (U32)pSrc;
 8004022:	60e0      	str	r0, [r4, #12]
  DMA2D->OMAR    = (U32)pDst;
 8004024:	63e1      	str	r1, [r4, #60]	; 0x3c
  DMA2D->FGOR    = OffLineSrc;
 8004026:	9903      	ldr	r1, [sp, #12]
 8004028:	6121      	str	r1, [r4, #16]
  DMA2D->OOR     = OffLineDst;
 800402a:	9904      	ldr	r1, [sp, #16]
 800402c:	6421      	str	r1, [r4, #64]	; 0x40

  /* Set up pixel format */
  DMA2D->FGPFCCR = PixelFormat;

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 800402e:	b29b      	uxth	r3, r3
 8004030:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  DMA2D->OMAR    = (U32)pDst;
  DMA2D->FGOR    = OffLineSrc;
  DMA2D->OOR     = OffLineDst;

  /* Set up pixel format */
  DMA2D->FGPFCCR = PixelFormat;
 8004034:	2100      	movs	r1, #0
 8004036:	61e1      	str	r1, [r4, #28]

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 8004038:	6462      	str	r2, [r4, #68]	; 0x44

  DMA2D->CR     |= DMA2D_CR_START;
 800403a:	6823      	ldr	r3, [r4, #0]
 800403c:	f043 0301 	orr.w	r3, r3, #1
 8004040:	6023      	str	r3, [r4, #0]

  /* Wait until transfer is done */
  while (DMA2D->CR & DMA2D_CR_START)
 8004042:	6823      	ldr	r3, [r4, #0]
 8004044:	07db      	lsls	r3, r3, #31
 8004046:	d4fc      	bmi.n	8004042 <DMA2D_CopyBuffer.isra.1+0x2a>
    {
    }
}
 8004048:	bd30      	pop	{r4, r5, pc}
 800404a:	bf00      	nop
 800404c:	4002b000 	.word	0x4002b000

08004050 <CUSTOM_CopyRect>:
  * @param  xSize:       X size.
  * @param  ySize:       Y size.
  * @retval None
  */
static void CUSTOM_CopyRect(int LayerIndex, int x0, int y0, int x1, int y1, int xSize, int ySize)
{
 8004050:	b5f0      	push	{r4, r5, r6, r7, lr}
  U32 AddrSrc, AddrDst;

  AddrSrc = layer_prop[LayerIndex].address + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
 8004052:	4e0e      	ldr	r6, [pc, #56]	; (800408c <CUSTOM_CopyRect+0x3c>)
  * @param  xSize:       X size.
  * @param  ySize:       Y size.
  * @retval None
  */
static void CUSTOM_CopyRect(int LayerIndex, int x0, int y0, int x1, int y1, int xSize, int ySize)
{
 8004054:	9f06      	ldr	r7, [sp, #24]
  U32 AddrSrc, AddrDst;

  AddrSrc = layer_prop[LayerIndex].address + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
 8004056:	241c      	movs	r4, #28
 8004058:	4360      	muls	r0, r4
 800405a:	1835      	adds	r5, r6, r0
 800405c:	5830      	ldr	r0, [r6, r0]
 800405e:	68ec      	ldr	r4, [r5, #12]
 8004060:	696e      	ldr	r6, [r5, #20]
  AddrDst = layer_prop[LayerIndex].address + (y1 * layer_prop[LayerIndex].xSize + x1) * layer_prop[LayerIndex].BytesPerPixel;
  DMA2D_CopyBuffer(LayerIndex, (void *)AddrSrc, (void *)AddrDst, xSize, ySize, layer_prop[LayerIndex].xSize - xSize, layer_prop[LayerIndex].xSize - xSize);
 8004062:	9d05      	ldr	r5, [sp, #20]
 8004064:	ebc7 0e04 	rsb	lr, r7, r4
 8004068:	fb05 3504 	mla	r5, r5, r4, r3
 800406c:	fb02 1404 	mla	r4, r2, r4, r1
 8004070:	f8cd e018 	str.w	lr, [sp, #24]
 8004074:	fb06 0105 	mla	r1, r6, r5, r0
 8004078:	f8cd e014 	str.w	lr, [sp, #20]
 800407c:	9b07      	ldr	r3, [sp, #28]
 800407e:	463a      	mov	r2, r7
 8004080:	fb06 0004 	mla	r0, r6, r4, r0
}
 8004084:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
{
  U32 AddrSrc, AddrDst;

  AddrSrc = layer_prop[LayerIndex].address + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
  AddrDst = layer_prop[LayerIndex].address + (y1 * layer_prop[LayerIndex].xSize + x1) * layer_prop[LayerIndex].BytesPerPixel;
  DMA2D_CopyBuffer(LayerIndex, (void *)AddrSrc, (void *)AddrDst, xSize, ySize, layer_prop[LayerIndex].xSize - xSize, layer_prop[LayerIndex].xSize - xSize);
 8004088:	f7ff bfc6 	b.w	8004018 <DMA2D_CopyBuffer.isra.1>
 800408c:	20001f48 	.word	0x20001f48

08004090 <CUSTOM_FillRect>:
  * @param  y1:          Y1 position
  * @param  PixelIndex:  Pixel index.
  * @retval None
  */
static void CUSTOM_FillRect(int LayerIndex, int x0, int y0, int x1, int y1, U32 PixelIndex)
{
 8004090:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8004094:	9d08      	ldr	r5, [sp, #32]
 8004096:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8004098:	4681      	mov	r9, r0
 800409a:	460c      	mov	r4, r1
 800409c:	4616      	mov	r6, r2
 800409e:	4698      	mov	r8, r3
  U32 BufferSize, AddrDst;
  int xSize, ySize;

  if (GUI_GetDrawMode() == GUI_DM_XOR)
 80040a0:	f003 fab6 	bl	8007610 <GUI_GetDrawMode>
 80040a4:	2801      	cmp	r0, #1
 80040a6:	d111      	bne.n	80040cc <CUSTOM_FillRect+0x3c>
    {
      LCD_SetDevFunc(LayerIndex, LCD_DEVFUNC_FILLRECT, NULL);
 80040a8:	2200      	movs	r2, #0
 80040aa:	2119      	movs	r1, #25
 80040ac:	4648      	mov	r0, r9
 80040ae:	f002 fc4b 	bl	8006948 <LCD_SetDevFunc>
      LCD_FillRect(x0, y0, x1, y1);
 80040b2:	4642      	mov	r2, r8
 80040b4:	4631      	mov	r1, r6
 80040b6:	4620      	mov	r0, r4
 80040b8:	462b      	mov	r3, r5
 80040ba:	f002 fd45 	bl	8006b48 <LCD_FillRect>
      LCD_SetDevFunc(LayerIndex, LCD_DEVFUNC_FILLRECT, (void(*)(void))CUSTOM_FillRect);
 80040be:	4648      	mov	r0, r9
 80040c0:	4a1d      	ldr	r2, [pc, #116]	; (8004138 <CUSTOM_FillRect+0xa8>)
 80040c2:	2119      	movs	r1, #25
      ySize = y1 - y0 + 1;
      BufferSize = GetBufferSize(LayerIndex);
      AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
      DMA2D_FillBuffer(LayerIndex, (void *)AddrDst, xSize, ySize, layer_prop[LayerIndex].xSize - xSize, PixelIndex);
    }
}
 80040c4:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  if (GUI_GetDrawMode() == GUI_DM_XOR)
    {
      LCD_SetDevFunc(LayerIndex, LCD_DEVFUNC_FILLRECT, NULL);
      LCD_FillRect(x0, y0, x1, y1);
      LCD_SetDevFunc(LayerIndex, LCD_DEVFUNC_FILLRECT, (void(*)(void))CUSTOM_FillRect);
 80040c8:	f002 bc3e 	b.w	8006948 <LCD_SetDevFunc>
    }
  else
    {
      xSize = x1 - x0 + 1;
 80040cc:	ebc4 0308 	rsb	r3, r4, r8
      ySize = y1 - y0 + 1;
      BufferSize = GetBufferSize(LayerIndex);
      AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
 80040d0:	f04f 0e1c 	mov.w	lr, #28
 80040d4:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8004144 <CUSTOM_FillRect+0xb4>
 80040d8:	fb0e fe09 	mul.w	lr, lr, r9
 80040dc:	eb08 0c0e 	add.w	ip, r8, lr

  /* Set up pixel format */
  DMA2D->OPFCCR  = PixelFormat;

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 80040e0:	1bad      	subs	r5, r5, r6
  else
    {
      xSize = x1 - x0 + 1;
      ySize = y1 - y0 + 1;
      BufferSize = GetBufferSize(LayerIndex);
      AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
 80040e2:	f8dc 000c 	ldr.w	r0, [ip, #12]
 80040e6:	f8dc 2010 	ldr.w	r2, [ip, #16]
 80040ea:	f8dc 9014 	ldr.w	r9, [ip, #20]
 80040ee:	f8dc c008 	ldr.w	ip, [ip, #8]
 80040f2:	4342      	muls	r2, r0
 80040f4:	fb09 f102 	mul.w	r1, r9, r2
 80040f8:	f858 200e 	ldr.w	r2, [r8, lr]
 80040fc:	fb00 4406 	mla	r4, r0, r6, r4
 8004100:	fb0c 2201 	mla	r2, ip, r1, r2
 8004104:	fb09 2204 	mla	r2, r9, r4, r2

  /* Set up pixel format */
  DMA2D->OPFCCR  = PixelFormat;

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 8004108:	3501      	adds	r5, #1
  U32 PixelFormat;

  PixelFormat = LCD_LL_GetPixelformat(LayerIndex);

  /* Set up mode */
  DMA2D->CR      = 0x00030000UL | (1 << 9);
 800410a:	4c0c      	ldr	r4, [pc, #48]	; (800413c <CUSTOM_FillRect+0xac>)
 800410c:	490c      	ldr	r1, [pc, #48]	; (8004140 <CUSTOM_FillRect+0xb0>)
 800410e:	6021      	str	r1, [r4, #0]
      LCD_FillRect(x0, y0, x1, y1);
      LCD_SetDevFunc(LayerIndex, LCD_DEVFUNC_FILLRECT, (void(*)(void))CUSTOM_FillRect);
    }
  else
    {
      xSize = x1 - x0 + 1;
 8004110:	3301      	adds	r3, #1

  /* Set up pixel format */
  DMA2D->OPFCCR  = PixelFormat;

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 8004112:	b2ad      	uxth	r5, r5

  PixelFormat = LCD_LL_GetPixelformat(LayerIndex);

  /* Set up mode */
  DMA2D->CR      = 0x00030000UL | (1 << 9);
  DMA2D->OCOLR   = ColorIndex;
 8004114:	63a7      	str	r7, [r4, #56]	; 0x38
    {
      xSize = x1 - x0 + 1;
      ySize = y1 - y0 + 1;
      BufferSize = GetBufferSize(LayerIndex);
      AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
      DMA2D_FillBuffer(LayerIndex, (void *)AddrDst, xSize, ySize, layer_prop[LayerIndex].xSize - xSize, PixelIndex);
 8004116:	1ac0      	subs	r0, r0, r3
  /* Set up mode */
  DMA2D->CR      = 0x00030000UL | (1 << 9);
  DMA2D->OCOLR   = ColorIndex;

  /* Set up pointers */
  DMA2D->OMAR    = (U32)pDst;
 8004118:	63e2      	str	r2, [r4, #60]	; 0x3c

  /* Set up pixel format */
  DMA2D->OPFCCR  = PixelFormat;

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 800411a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16

  /* Set up offsets */
  DMA2D->OOR     = OffLine;

  /* Set up pixel format */
  DMA2D->OPFCCR  = PixelFormat;
 800411e:	2200      	movs	r2, #0

  /* Set up pointers */
  DMA2D->OMAR    = (U32)pDst;

  /* Set up offsets */
  DMA2D->OOR     = OffLine;
 8004120:	6420      	str	r0, [r4, #64]	; 0x40

  /* Set up pixel format */
  DMA2D->OPFCCR  = PixelFormat;
 8004122:	6362      	str	r2, [r4, #52]	; 0x34

  /*  Set up size */
  DMA2D->NLR     = (U32)(xSize << 16) | (U16)ySize;
 8004124:	6465      	str	r5, [r4, #68]	; 0x44

  DMA2D->CR     |= DMA2D_CR_START;
 8004126:	6823      	ldr	r3, [r4, #0]
 8004128:	f043 0301 	orr.w	r3, r3, #1
 800412c:	6023      	str	r3, [r4, #0]

  /* Wait until transfer is done */
  while (DMA2D->CR & DMA2D_CR_START)
 800412e:	6823      	ldr	r3, [r4, #0]
 8004130:	07db      	lsls	r3, r3, #31
 8004132:	d4fc      	bmi.n	800412e <CUSTOM_FillRect+0x9e>
      ySize = y1 - y0 + 1;
      BufferSize = GetBufferSize(LayerIndex);
      AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y0 * layer_prop[LayerIndex].xSize + x0) * layer_prop[LayerIndex].BytesPerPixel;
      DMA2D_FillBuffer(LayerIndex, (void *)AddrDst, xSize, ySize, layer_prop[LayerIndex].xSize - xSize, PixelIndex);
    }
}
 8004134:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004138:	08004091 	.word	0x08004091
 800413c:	4002b000 	.word	0x4002b000
 8004140:	00030200 	.word	0x00030200
 8004144:	20001f48 	.word	0x20001f48

08004148 <CUSTOM_CopyBuffer>:
  * @param  IndexSrc:    index source
  * @param  IndexDst:    index destination
  * @retval None
  */
static void CUSTOM_CopyBuffer(int LayerIndex, int IndexSrc, int IndexDst)
{
 8004148:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  */
static U32 GetBufferSize(U32 LayerIndex)
{
  U32 BufferSize;

  BufferSize = layer_prop[LayerIndex].xSize * layer_prop[LayerIndex].ySize * layer_prop[LayerIndex].BytesPerPixel;
 800414a:	231c      	movs	r3, #28
 800414c:	4f0b      	ldr	r7, [pc, #44]	; (800417c <CUSTOM_CopyBuffer+0x34>)
 800414e:	4358      	muls	r0, r3
 8004150:	183c      	adds	r4, r7, r0
  * @param  IndexSrc:    index source
  * @param  IndexDst:    index destination
  * @retval None
  */
static void CUSTOM_CopyBuffer(int LayerIndex, int IndexSrc, int IndexDst)
{
 8004152:	4616      	mov	r6, r2
  */
static U32 GetBufferSize(U32 LayerIndex)
{
  U32 BufferSize;

  BufferSize = layer_prop[LayerIndex].xSize * layer_prop[LayerIndex].ySize * layer_prop[LayerIndex].BytesPerPixel;
 8004154:	6923      	ldr	r3, [r4, #16]
 8004156:	68e2      	ldr	r2, [r4, #12]
 8004158:	6965      	ldr	r5, [r4, #20]
static void CUSTOM_CopyBuffer(int LayerIndex, int IndexSrc, int IndexDst)
{
  U32 BufferSize, AddrSrc, AddrDst;

  BufferSize = GetBufferSize(LayerIndex);
  AddrSrc    = layer_prop[LayerIndex].address + BufferSize * IndexSrc;
 800415a:	583f      	ldr	r7, [r7, r0]
  */
static U32 GetBufferSize(U32 LayerIndex)
{
  U32 BufferSize;

  BufferSize = layer_prop[LayerIndex].xSize * layer_prop[LayerIndex].ySize * layer_prop[LayerIndex].BytesPerPixel;
 800415c:	fb03 fe02 	mul.w	lr, r3, r2
 8004160:	fb05 f50e 	mul.w	r5, r5, lr
  U32 BufferSize, AddrSrc, AddrDst;

  BufferSize = GetBufferSize(LayerIndex);
  AddrSrc    = layer_prop[LayerIndex].address + BufferSize * IndexSrc;
  AddrDst    = layer_prop[LayerIndex].address + BufferSize * IndexDst;
  DMA2D_CopyBuffer(LayerIndex, (void *)AddrSrc, (void *)AddrDst, layer_prop[LayerIndex].xSize, layer_prop[LayerIndex].ySize, 0, 0);
 8004164:	fb05 7001 	mla	r0, r5, r1, r7
 8004168:	2100      	movs	r1, #0
 800416a:	9101      	str	r1, [sp, #4]
 800416c:	9100      	str	r1, [sp, #0]
 800416e:	fb05 7106 	mla	r1, r5, r6, r7
 8004172:	f7ff ff51 	bl	8004018 <DMA2D_CopyBuffer.isra.1>
  layer_prop[LayerIndex].buffer_index = IndexDst;
 8004176:	60a6      	str	r6, [r4, #8]
}
 8004178:	b003      	add	sp, #12
 800417a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800417c:	20001f48 	.word	0x20001f48

08004180 <CUSTOM_DrawBitmap32bpp>:
  * @param  xSize: X size
  * @param  ySize: Y size
  * @retval None
  */
static void CUSTOM_DrawBitmap32bpp(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine)
{
 8004180:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  U32 BufferSize, AddrDst;
  int OffLineSrc, OffLineDst;

  BufferSize = GetBufferSize(LayerIndex);
  AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y * layer_prop[LayerIndex].xSize + x) * layer_prop[LayerIndex].BytesPerPixel;
 8004184:	f04f 0c1c 	mov.w	ip, #28
 8004188:	f8df 8054 	ldr.w	r8, [pc, #84]	; 80041e0 <CUSTOM_DrawBitmap32bpp+0x60>
  * @param  xSize: X size
  * @param  ySize: Y size
  * @retval None
  */
static void CUSTOM_DrawBitmap32bpp(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine)
{
 800418c:	9e07      	ldr	r6, [sp, #28]
  U32 BufferSize, AddrDst;
  int OffLineSrc, OffLineDst;

  BufferSize = GetBufferSize(LayerIndex);
  AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y * layer_prop[LayerIndex].xSize + x) * layer_prop[LayerIndex].BytesPerPixel;
 800418e:	fb0c fc00 	mul.w	ip, ip, r0
 8004192:	eb08 090c 	add.w	r9, r8, ip
  * @param  xSize: X size
  * @param  ySize: Y size
  * @retval None
  */
static void CUSTOM_DrawBitmap32bpp(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine)
{
 8004196:	461f      	mov	r7, r3
  U32 BufferSize, AddrDst;
  int OffLineSrc, OffLineDst;

  BufferSize = GetBufferSize(LayerIndex);
  AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y * layer_prop[LayerIndex].xSize + x) * layer_prop[LayerIndex].BytesPerPixel;
 8004198:	f8d9 e00c 	ldr.w	lr, [r9, #12]
  OffLineSrc = (BytesPerLine / 4) - xSize;
  OffLineDst = layer_prop[LayerIndex].xSize - xSize;
  DMA2D_CopyBuffer(LayerIndex, (void *)p, (void *)AddrDst, xSize, ySize, OffLineSrc, OffLineDst);
 800419c:	f8d9 4010 	ldr.w	r4, [r9, #16]
 80041a0:	f8d9 0014 	ldr.w	r0, [r9, #20]
 80041a4:	f8d9 9008 	ldr.w	r9, [r9, #8]
  * @param  xSize: X size
  * @param  ySize: Y size
  * @retval None
  */
static void CUSTOM_DrawBitmap32bpp(int LayerIndex, int x, int y, U8 const * p, int xSize, int ySize, int BytesPerLine)
{
 80041a8:	9b08      	ldr	r3, [sp, #32]

  BufferSize = GetBufferSize(LayerIndex);
  AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y * layer_prop[LayerIndex].xSize + x) * layer_prop[LayerIndex].BytesPerPixel;
  OffLineSrc = (BytesPerLine / 4) - xSize;
  OffLineDst = layer_prop[LayerIndex].xSize - xSize;
  DMA2D_CopyBuffer(LayerIndex, (void *)p, (void *)AddrDst, xSize, ySize, OffLineSrc, OffLineDst);
 80041aa:	fb04 f40e 	mul.w	r4, r4, lr
 80041ae:	fb00 f504 	mul.w	r5, r0, r4
 80041b2:	f858 400c 	ldr.w	r4, [r8, ip]
 80041b6:	fb02 110e 	mla	r1, r2, lr, r1
 80041ba:	ebc6 020e 	rsb	r2, r6, lr
 80041be:	fb09 4405 	mla	r4, r9, r5, r4
 80041c2:	9208      	str	r2, [sp, #32]
 80041c4:	2504      	movs	r5, #4
 80041c6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80041c8:	fb92 f2f5 	sdiv	r2, r2, r5
 80041cc:	1b92      	subs	r2, r2, r6
 80041ce:	9207      	str	r2, [sp, #28]
 80041d0:	fb00 4101 	mla	r1, r0, r1, r4
 80041d4:	4632      	mov	r2, r6
 80041d6:	4638      	mov	r0, r7
}
 80041d8:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}

  BufferSize = GetBufferSize(LayerIndex);
  AddrDst = layer_prop[LayerIndex].address + BufferSize * layer_prop[LayerIndex].buffer_index + (y * layer_prop[LayerIndex].xSize + x) * layer_prop[LayerIndex].BytesPerPixel;
  OffLineSrc = (BytesPerLine / 4) - xSize;
  OffLineDst = layer_prop[LayerIndex].xSize - xSize;
  DMA2D_CopyBuffer(LayerIndex, (void *)p, (void *)AddrDst, xSize, ySize, OffLineSrc, OffLineDst);
 80041dc:	f7ff bf1c 	b.w	8004018 <DMA2D_CopyBuffer.isra.1>
 80041e0:	20001f48 	.word	0x20001f48

080041e4 <HAL_DMA2D_MspInit>:
  *           - Peripheral's GPIO Configuration
  * @param hdma2d: DMA2D handle pointer
  * @retval None
  */
void HAL_DMA2D_MspInit(DMA2D_HandleTypeDef *hdma2d)
{
 80041e4:	b082      	sub	sp, #8
  /* Enable peripheral */
  __HAL_RCC_DMA2D_CLK_ENABLE();
 80041e6:	2300      	movs	r3, #0
 80041e8:	9301      	str	r3, [sp, #4]
 80041ea:	4b06      	ldr	r3, [pc, #24]	; (8004204 <HAL_DMA2D_MspInit+0x20>)
 80041ec:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80041ee:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80041f2:	631a      	str	r2, [r3, #48]	; 0x30
 80041f4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80041f6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 80041fa:	9301      	str	r3, [sp, #4]
 80041fc:	9b01      	ldr	r3, [sp, #4]
}
 80041fe:	b002      	add	sp, #8
 8004200:	4770      	bx	lr
 8004202:	bf00      	nop
 8004204:	40023800 	.word	0x40023800

08004208 <HAL_LTDC_MspInit>:
  *           - Peripheral's GPIO Configuration
  * @param hltdc: LTDC handle pointer
  * @retval None
  */
void HAL_LTDC_MspInit(LTDC_HandleTypeDef* hltdc)
{
 8004208:	b5f0      	push	{r4, r5, r6, r7, lr}
 800420a:	b08d      	sub	sp, #52	; 0x34
  GPIO_InitTypeDef GPIO_Init_Structure;
  
  /* Enable peripherals and GPIO Clocks */  
  /* Enable the LTDC Clock */
  __HAL_RCC_LTDC_CLK_ENABLE();
 800420c:	4b48      	ldr	r3, [pc, #288]	; (8004330 <HAL_LTDC_MspInit+0x128>)
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);

 /* GPIOB configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 800420e:	4f49      	ldr	r7, [pc, #292]	; (8004334 <HAL_LTDC_MspInit+0x12c>)
                           GPIO_PIN_11 | GPIO_PIN_12;
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);
 8004210:	4849      	ldr	r0, [pc, #292]	; (8004338 <HAL_LTDC_MspInit+0x130>)
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     

 /* GPIOG configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
                           GPIO_PIN_11;
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 8004212:	4e4a      	ldr	r6, [pc, #296]	; (800433c <HAL_LTDC_MspInit+0x134>)
{
  GPIO_InitTypeDef GPIO_Init_Structure;
  
  /* Enable peripherals and GPIO Clocks */  
  /* Enable the LTDC Clock */
  __HAL_RCC_LTDC_CLK_ENABLE();
 8004214:	2400      	movs	r4, #0
 8004216:	9400      	str	r4, [sp, #0]
 8004218:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 800421a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 800421e:	645a      	str	r2, [r3, #68]	; 0x44
 8004220:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8004222:	f002 6280 	and.w	r2, r2, #67108864	; 0x4000000
 8004226:	9200      	str	r2, [sp, #0]
 8004228:	9a00      	ldr	r2, [sp, #0]
  
  /* Enable GPIO Clock */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800422a:	9401      	str	r4, [sp, #4]
 800422c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800422e:	f042 0201 	orr.w	r2, r2, #1
 8004232:	631a      	str	r2, [r3, #48]	; 0x30
 8004234:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004236:	f002 0201 	and.w	r2, r2, #1
 800423a:	9201      	str	r2, [sp, #4]
 800423c:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 800423e:	9402      	str	r4, [sp, #8]
 8004240:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004242:	f042 0202 	orr.w	r2, r2, #2
 8004246:	631a      	str	r2, [r3, #48]	; 0x30
 8004248:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800424a:	f002 0202 	and.w	r2, r2, #2
 800424e:	9202      	str	r2, [sp, #8]
 8004250:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8004252:	9403      	str	r4, [sp, #12]
 8004254:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004256:	f042 0204 	orr.w	r2, r2, #4
 800425a:	631a      	str	r2, [r3, #48]	; 0x30
 800425c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800425e:	f002 0204 	and.w	r2, r2, #4
 8004262:	9203      	str	r2, [sp, #12]
 8004264:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8004266:	9404      	str	r4, [sp, #16]
 8004268:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800426a:	f042 0208 	orr.w	r2, r2, #8
 800426e:	631a      	str	r2, [r3, #48]	; 0x30
 8004270:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004272:	f002 0208 	and.w	r2, r2, #8
 8004276:	9204      	str	r2, [sp, #16]
 8004278:	9a04      	ldr	r2, [sp, #16]
  __HAL_RCC_GPIOF_CLK_ENABLE();
 800427a:	9405      	str	r4, [sp, #20]
 800427c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800427e:	f042 0220 	orr.w	r2, r2, #32
 8004282:	631a      	str	r2, [r3, #48]	; 0x30
 8004284:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004286:	f002 0220 	and.w	r2, r2, #32
 800428a:	9205      	str	r2, [sp, #20]
 800428c:	9a05      	ldr	r2, [sp, #20]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800428e:	9406      	str	r4, [sp, #24]
 8004290:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004292:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8004296:	631a      	str	r2, [r3, #48]	; 0x30
 8004298:	6b1b      	ldr	r3, [r3, #48]	; 0x30

  /* GPIOA configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
                           GPIO_PIN_11 | GPIO_PIN_12;
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
 800429a:	9409      	str	r4, [sp, #36]	; 0x24
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOF_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();
 800429c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80042a0:	9306      	str	r3, [sp, #24]
 80042a2:	9b06      	ldr	r3, [sp, #24]
            |  LCD_TFT CLK   <-> PG.07  | LCD_TFT DE   <->  PF.10 |
             -----------------------------------------------------
  */

  /* GPIOA configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
 80042a4:	f641 0358 	movw	r3, #6232	; 0x1858
 80042a8:	9307      	str	r3, [sp, #28]
                           GPIO_PIN_11 | GPIO_PIN_12;
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
 80042aa:	250e      	movs	r5, #14
  */

  /* GPIOA configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
                           GPIO_PIN_11 | GPIO_PIN_12;
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
 80042ac:	2302      	movs	r3, #2
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);
 80042ae:	a907      	add	r1, sp, #28
  */

  /* GPIOA configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_6 |
                           GPIO_PIN_11 | GPIO_PIN_12;
  GPIO_Init_Structure.Mode = GPIO_MODE_AF_PP;
 80042b0:	9308      	str	r3, [sp, #32]
  GPIO_Init_Structure.Pull = GPIO_NOPULL;
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
 80042b2:	930a      	str	r3, [sp, #40]	; 0x28
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
 80042b4:	950b      	str	r5, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);
 80042b6:	f7fd fd85 	bl	8001dc4 <HAL_GPIO_Init>

 /* GPIOB configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
 80042ba:	f44f 6370 	mov.w	r3, #3840	; 0xf00
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 80042be:	a907      	add	r1, sp, #28
 80042c0:	4638      	mov	r0, r7
  GPIO_Init_Structure.Speed = GPIO_SPEED_FAST;
  GPIO_Init_Structure.Alternate= GPIO_AF14_LTDC;
  HAL_GPIO_Init(GPIOA, &GPIO_Init_Structure);

 /* GPIOB configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
 80042c2:	9307      	str	r3, [sp, #28]
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 80042c4:	f7fd fd7e 	bl	8001dc4 <HAL_GPIO_Init>

 /* GPIOC configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
 80042c8:	f44f 6398 	mov.w	r3, #1216	; 0x4c0
  HAL_GPIO_Init(GPIOC, &GPIO_Init_Structure);
 80042cc:	a907      	add	r1, sp, #28
 80042ce:	481c      	ldr	r0, [pc, #112]	; (8004340 <HAL_LTDC_MspInit+0x138>)
  GPIO_Init_Structure.Pin = GPIO_PIN_8 | \
                           GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);

 /* GPIOC configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
 80042d0:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_Init_Structure);
 80042d2:	f7fd fd77 	bl	8001dc4 <HAL_GPIO_Init>

 /* GPIOD configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
 80042d6:	2348      	movs	r3, #72	; 0x48
  HAL_GPIO_Init(GPIOD, &GPIO_Init_Structure);
 80042d8:	a907      	add	r1, sp, #28
 80042da:	481a      	ldr	r0, [pc, #104]	; (8004344 <HAL_LTDC_MspInit+0x13c>)
 /* GPIOC configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10;
  HAL_GPIO_Init(GPIOC, &GPIO_Init_Structure);

 /* GPIOD configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
 80042dc:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOD, &GPIO_Init_Structure);
 80042de:	f7fd fd71 	bl	8001dc4 <HAL_GPIO_Init>
  
 /* GPIOF configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_10;
 80042e2:	f44f 6380 	mov.w	r3, #1024	; 0x400
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     
 80042e6:	a907      	add	r1, sp, #28
 80042e8:	4817      	ldr	r0, [pc, #92]	; (8004348 <HAL_LTDC_MspInit+0x140>)
 /* GPIOD configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_3 | GPIO_PIN_6;
  HAL_GPIO_Init(GPIOD, &GPIO_Init_Structure);
  
 /* GPIOF configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_10;
 80042ea:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     
 80042ec:	f7fd fd6a 	bl	8001dc4 <HAL_GPIO_Init>

 /* GPIOG configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
 80042f0:	f44f 630c 	mov.w	r3, #2240	; 0x8c0
                           GPIO_PIN_11;
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 80042f4:	a907      	add	r1, sp, #28
 80042f6:	4630      	mov	r0, r6
 /* GPIOF configuration */
  GPIO_Init_Structure.Pin = GPIO_PIN_10;
  HAL_GPIO_Init(GPIOF, &GPIO_Init_Structure);     

 /* GPIOG configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_6 | GPIO_PIN_7 | \
 80042f8:	9307      	str	r3, [sp, #28]
                           GPIO_PIN_11;
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 80042fa:	f7fd fd63 	bl	8001dc4 <HAL_GPIO_Init>
 
  /* GPIOB configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
 80042fe:	2303      	movs	r3, #3
 8004300:	9307      	str	r3, [sp, #28]
  GPIO_Init_Structure.Alternate= GPIO_AF9_LTDC;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 8004302:	a907      	add	r1, sp, #28
                           GPIO_PIN_11;
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 
  /* GPIOB configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
  GPIO_Init_Structure.Alternate= GPIO_AF9_LTDC;
 8004304:	2309      	movs	r3, #9
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 8004306:	4638      	mov	r0, r7
                           GPIO_PIN_11;
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 
  /* GPIOB configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
  GPIO_Init_Structure.Alternate= GPIO_AF9_LTDC;
 8004308:	930b      	str	r3, [sp, #44]	; 0x2c
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);
 800430a:	f7fd fd5b 	bl	8001dc4 <HAL_GPIO_Init>

  /* GPIOG configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_10 | GPIO_PIN_12;
 800430e:	f44f 53a0 	mov.w	r3, #5120	; 0x1400
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 8004312:	a907      	add	r1, sp, #28
 8004314:	4630      	mov	r0, r6
  GPIO_Init_Structure.Pin = GPIO_PIN_0 | GPIO_PIN_1;
  GPIO_Init_Structure.Alternate= GPIO_AF9_LTDC;
  HAL_GPIO_Init(GPIOB, &GPIO_Init_Structure);

  /* GPIOG configuration */  
  GPIO_Init_Structure.Pin = GPIO_PIN_10 | GPIO_PIN_12;
 8004316:	9307      	str	r3, [sp, #28]
  HAL_GPIO_Init(GPIOG, &GPIO_Init_Structure);
 8004318:	f7fd fd54 	bl	8001dc4 <HAL_GPIO_Init>

  /* Set LTDC Interrupt to the lowest priority */
  HAL_NVIC_SetPriority(LTDC_IRQn, 0xE, 0);
 800431c:	4622      	mov	r2, r4
 800431e:	4629      	mov	r1, r5
 8004320:	2058      	movs	r0, #88	; 0x58
 8004322:	f7fd fbf7 	bl	8001b14 <HAL_NVIC_SetPriority>
  
  /* Enable LTDC Interrupt */
  HAL_NVIC_EnableIRQ(LTDC_IRQn);
 8004326:	2058      	movs	r0, #88	; 0x58
 8004328:	f7fd fc28 	bl	8001b7c <HAL_NVIC_EnableIRQ>
}
 800432c:	b00d      	add	sp, #52	; 0x34
 800432e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004330:	40023800 	.word	0x40023800
 8004334:	40020400 	.word	0x40020400
 8004338:	40020000 	.word	0x40020000
 800433c:	40021800 	.word	0x40021800
 8004340:	40020800 	.word	0x40020800
 8004344:	40020c00 	.word	0x40020c00
 8004348:	40021400 	.word	0x40021400

0800434c <HAL_LTDC_MspDeInit>:
  */
void HAL_LTDC_MspDeInit(LTDC_HandleTypeDef* hltdc)
{
  /* Reset peripherals */
  /* Enable LTDC reset state */
  __HAL_RCC_LTDC_FORCE_RESET();
 800434c:	4b04      	ldr	r3, [pc, #16]	; (8004360 <HAL_LTDC_MspDeInit+0x14>)
 800434e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004350:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8004354:	625a      	str	r2, [r3, #36]	; 0x24
  
  /* Release LTDC from reset state */ 
  __HAL_RCC_LTDC_RELEASE_RESET();
 8004356:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004358:	f022 6280 	bic.w	r2, r2, #67108864	; 0x4000000
 800435c:	625a      	str	r2, [r3, #36]	; 0x24
 800435e:	4770      	bx	lr
 8004360:	40023800 	.word	0x40023800

08004364 <HAL_LTDC_LineEventCallback>:
  * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the specified LTDC.
  * @retval None
  */
void HAL_LTDC_LineEvenCallback(LTDC_HandleTypeDef *hltdc)
{
 8004364:	b538      	push	{r3, r4, r5, lr}
  U32 Addr;
  U32 layer;

  for (layer = 0; layer < GUI_NUM_LAYERS; layer++)
    {
      if (layer_prop[layer].pending_buffer >= 0)
 8004366:	4c11      	ldr	r4, [pc, #68]	; (80043ac <HAL_LTDC_LineEventCallback+0x48>)
 8004368:	6863      	ldr	r3, [r4, #4]
 800436a:	2b00      	cmp	r3, #0
  * @param  hltdc: pointer to a LTDC_HandleTypeDef structure that contains
  *                the configuration information for the specified LTDC.
  * @retval None
  */
void HAL_LTDC_LineEvenCallback(LTDC_HandleTypeDef *hltdc)
{
 800436c:	4605      	mov	r5, r0
  U32 Addr;
  U32 layer;

  for (layer = 0; layer < GUI_NUM_LAYERS; layer++)
    {
      if (layer_prop[layer].pending_buffer >= 0)
 800436e:	db17      	blt.n	80043a0 <HAL_LTDC_LineEventCallback+0x3c>
        {
          /* Calculate address of buffer to be used  as visible frame buffer */
          Addr = layer_prop[layer].address + \
 8004370:	68e2      	ldr	r2, [r4, #12]
 8004372:	6923      	ldr	r3, [r4, #16]
                 layer_prop[layer].xSize * layer_prop[layer].ySize * layer_prop[layer].pending_buffer * layer_prop[layer].BytesPerPixel;
 8004374:	6861      	ldr	r1, [r4, #4]
  for (layer = 0; layer < GUI_NUM_LAYERS; layer++)
    {
      if (layer_prop[layer].pending_buffer >= 0)
        {
          /* Calculate address of buffer to be used  as visible frame buffer */
          Addr = layer_prop[layer].address + \
 8004376:	4353      	muls	r3, r2
 8004378:	fb01 f203 	mul.w	r2, r1, r3
 800437c:	6961      	ldr	r1, [r4, #20]
 800437e:	6823      	ldr	r3, [r4, #0]
 8004380:	fb01 3302 	mla	r3, r1, r2, r3
                 layer_prop[layer].xSize * layer_prop[layer].ySize * layer_prop[layer].pending_buffer * layer_prop[layer].BytesPerPixel;

          __HAL_LTDC_LAYER(hltdc, layer)->CFBAR = Addr;
 8004384:	6802      	ldr	r2, [r0, #0]
 8004386:	f8c2 30ac 	str.w	r3, [r2, #172]	; 0xac

          __HAL_LTDC_RELOAD_CONFIG(hltdc);
 800438a:	6a53      	ldr	r3, [r2, #36]	; 0x24
 800438c:	f043 0301 	orr.w	r3, r3, #1
 8004390:	6253      	str	r3, [r2, #36]	; 0x24

          /* Notify STemWin that buffer is used */
          GUI_MULTIBUF_ConfirmEx(layer, layer_prop[layer].pending_buffer);
 8004392:	6861      	ldr	r1, [r4, #4]
 8004394:	2000      	movs	r0, #0
 8004396:	f003 f90b 	bl	80075b0 <GUI_MULTIBUF_ConfirmEx>

          /* Clear pending buffer flag of layer */
          layer_prop[layer].pending_buffer = -1;
 800439a:	f04f 33ff 	mov.w	r3, #4294967295
 800439e:	6063      	str	r3, [r4, #4]
        }
    }

  HAL_LTDC_ProgramLineEvent(hltdc, 0);
 80043a0:	4628      	mov	r0, r5
 80043a2:	2100      	movs	r1, #0
}
 80043a4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
          /* Clear pending buffer flag of layer */
          layer_prop[layer].pending_buffer = -1;
        }
    }

  HAL_LTDC_ProgramLineEvent(hltdc, 0);
 80043a8:	f7fe bd1c 	b.w	8002de4 <HAL_LTDC_ProgramLineEvent>
 80043ac:	20001f48 	.word	0x20001f48

080043b0 <LCD_X_Config>:
  *          display driver configuration
  * @param  None
  * @retval None
  */
void LCD_X_Config(void)
{
 80043b0:	b570      	push	{r4, r5, r6, lr}
  */
static void LCD_LL_Init(void)
{
  static RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;
  /* DeInit */
  HAL_LTDC_DeInit(&hltdc);
 80043b2:	4c48      	ldr	r4, [pc, #288]	; (80044d4 <LCD_X_Config+0x124>)
 80043b4:	4620      	mov	r0, r4
 80043b6:	f7fe fb6b 	bl	8002a90 <HAL_LTDC_DeInit>

  /* Initializaton of ILI9341 component*/
  ili9341_Init();
 80043ba:	f7fc fd03 	bl	8000dc4 <ili9341_Init>

  /* Set LCD Timings */
  hltdc.Init.HorizontalSync = 9; //9
 80043be:	2309      	movs	r3, #9
 80043c0:	6163      	str	r3, [r4, #20]
  hltdc.Init.VerticalSync = 1;
 80043c2:	2301      	movs	r3, #1
 80043c4:	61a3      	str	r3, [r4, #24]
  hltdc.Init.AccumulatedHBP = 29;
 80043c6:	231d      	movs	r3, #29
 80043c8:	61e3      	str	r3, [r4, #28]
  hltdc.Init.AccumulatedVBP = 3;
  hltdc.Init.AccumulatedActiveH = 323;
 80043ca:	f240 1343 	movw	r3, #323	; 0x143
 80043ce:	62a3      	str	r3, [r4, #40]	; 0x28
  hltdc.Init.AccumulatedActiveW = 269;
 80043d0:	f240 130d 	movw	r3, #269	; 0x10d
 80043d4:	6263      	str	r3, [r4, #36]	; 0x24
  hltdc.Init.TotalHeigh = 327;
 80043d6:	f240 1347 	movw	r3, #327	; 0x147
  /* LCD clock configuration */
  /* PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 MHz */
  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN = 192 MHz */
  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/4 = 48 MHz */
  /* LTDC clock frequency = PLLLCDCLK / LTDC_PLLSAI_DIVR_8 = 48/8 = 6 MHz */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 80043da:	483f      	ldr	r0, [pc, #252]	; (80044d8 <LCD_X_Config+0x128>)
  hltdc.Init.VerticalSync = 1;
  hltdc.Init.AccumulatedHBP = 29;
  hltdc.Init.AccumulatedVBP = 3;
  hltdc.Init.AccumulatedActiveH = 323;
  hltdc.Init.AccumulatedActiveW = 269;
  hltdc.Init.TotalHeigh = 327;
 80043dc:	6323      	str	r3, [r4, #48]	; 0x30
  hltdc.Init.TotalWidth = 279;
 80043de:	f240 1317 	movw	r3, #279	; 0x117
 80043e2:	62e3      	str	r3, [r4, #44]	; 0x2c
  /* LCD clock configuration */
  /* PLLSAI_VCO Input = HSE_VALUE/PLL_M = 1 MHz */
  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN = 192 MHz */
  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/4 = 48 MHz */
  /* LTDC clock frequency = PLLLCDCLK / LTDC_PLLSAI_DIVR_8 = 48/8 = 6 MHz */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
 80043e4:	2308      	movs	r3, #8
 80043e6:	6003      	str	r3, [r0, #0]
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
 80043e8:	23c0      	movs	r3, #192	; 0xc0
 80043ea:	6103      	str	r3, [r0, #16]
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
 80043ec:	2304      	movs	r3, #4
  hltdc.Init.AccumulatedActiveW = 269;
  hltdc.Init.TotalHeigh = 327;
  hltdc.Init.TotalWidth = 279;

  /* background value */
  hltdc.Init.Backcolor.Blue = 0;
 80043ee:	2500      	movs	r5, #0
  /* PLLSAI_VCO Output = PLLSAI_VCO Input * PLLSAIN = 192 MHz */
  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/4 = 48 MHz */
  /* LTDC clock frequency = PLLLCDCLK / LTDC_PLLSAI_DIVR_8 = 48/8 = 6 MHz */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
 80043f0:	6183      	str	r3, [r0, #24]

  /* Set LCD Timings */
  hltdc.Init.HorizontalSync = 9; //9
  hltdc.Init.VerticalSync = 1;
  hltdc.Init.AccumulatedHBP = 29;
  hltdc.Init.AccumulatedVBP = 3;
 80043f2:	2603      	movs	r6, #3
  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/4 = 48 MHz */
  /* LTDC clock frequency = PLLLCDCLK / LTDC_PLLSAI_DIVR_8 = 48/8 = 6 MHz */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
 80043f4:	f44f 3300 	mov.w	r3, #131072	; 0x20000

  /* Set LCD Timings */
  hltdc.Init.HorizontalSync = 9; //9
  hltdc.Init.VerticalSync = 1;
  hltdc.Init.AccumulatedHBP = 29;
  hltdc.Init.AccumulatedVBP = 3;
 80043f8:	6226      	str	r6, [r4, #32]
  hltdc.Init.AccumulatedActiveW = 269;
  hltdc.Init.TotalHeigh = 327;
  hltdc.Init.TotalWidth = 279;

  /* background value */
  hltdc.Init.Backcolor.Blue = 0;
 80043fa:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
  hltdc.Init.Backcolor.Green = 0;
 80043fe:	f884 5035 	strb.w	r5, [r4, #53]	; 0x35
  hltdc.Init.Backcolor.Red = 0;
 8004402:	f884 5036 	strb.w	r5, [r4, #54]	; 0x36
  /* PLLLCDCLK = PLLSAI_VCO Output/PLLSAIR = 192/4 = 48 MHz */
  /* LTDC clock frequency = PLLLCDCLK / LTDC_PLLSAI_DIVR_8 = 48/8 = 6 MHz */
  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
  PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
 8004406:	6243      	str	r3, [r0, #36]	; 0x24
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
 8004408:	f7fe ff90 	bl	800332c <HAL_RCCEx_PeriphCLKConfig>
  /* Polarity */
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
  hltdc.Instance = LTDC;
 800440c:	4b33      	ldr	r3, [pc, #204]	; (80044dc <LCD_X_Config+0x12c>)
 800440e:	6023      	str	r3, [r4, #0]

  HAL_LTDC_Init(&hltdc);
 8004410:	4620      	mov	r0, r4
  PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
  PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
  HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);

  /* Polarity */
  hltdc.Init.HSPolarity = LTDC_HSPOLARITY_AL;
 8004412:	6065      	str	r5, [r4, #4]
  hltdc.Init.VSPolarity = LTDC_VSPOLARITY_AL;
 8004414:	60a5      	str	r5, [r4, #8]
  hltdc.Init.DEPolarity = LTDC_DEPOLARITY_AL;
 8004416:	60e5      	str	r5, [r4, #12]
  hltdc.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
 8004418:	6125      	str	r5, [r4, #16]
  hltdc.Instance = LTDC;

  HAL_LTDC_Init(&hltdc);
 800441a:	f7fe fac5 	bl	80029a8 <HAL_LTDC_Init>
  HAL_LTDC_ProgramLineEvent(&hltdc, 0);
 800441e:	4629      	mov	r1, r5
 8004420:	4620      	mov	r0, r4
 8004422:	f7fe fcdf 	bl	8002de4 <HAL_LTDC_ProgramLineEvent>

  /* Configure the DMA2D  default mode */
  hdma2d.Init.Mode         = DMA2D_R2M;
 8004426:	482e      	ldr	r0, [pc, #184]	; (80044e0 <LCD_X_Config+0x130>)
 8004428:	f44f 3340 	mov.w	r3, #196608	; 0x30000
 800442c:	6043      	str	r3, [r0, #4]
  hdma2d.Init.ColorMode    = DMA2D_ARGB8888;
  hdma2d.Init.OutputOffset = 0x0;

  hdma2d.Instance          = DMA2D;
 800442e:	4b2d      	ldr	r3, [pc, #180]	; (80044e4 <LCD_X_Config+0x134>)
  HAL_LTDC_Init(&hltdc);
  HAL_LTDC_ProgramLineEvent(&hltdc, 0);

  /* Configure the DMA2D  default mode */
  hdma2d.Init.Mode         = DMA2D_R2M;
  hdma2d.Init.ColorMode    = DMA2D_ARGB8888;
 8004430:	6085      	str	r5, [r0, #8]
  hdma2d.Init.OutputOffset = 0x0;
 8004432:	60c5      	str	r5, [r0, #12]

  hdma2d.Instance          = DMA2D;
 8004434:	6003      	str	r3, [r0, #0]

  if (HAL_DMA2D_Init(&hdma2d) != HAL_OK)
 8004436:	f7fd fc98 	bl	8001d6a <HAL_DMA2D_Init>
 800443a:	4604      	mov	r4, r0
 800443c:	b100      	cbz	r0, 8004440 <LCD_X_Config+0x90>
 800443e:	e7fe      	b.n	800443e <LCD_X_Config+0x8e>

  /* At first initialize use of multiple buffers on demand */
#if (NUM_BUFFERS > 1)
  for (i = 0; i < GUI_NUM_LAYERS; i++)
    {
      GUI_MULTIBUF_ConfigEx(i, NUM_BUFFERS);
 8004440:	4631      	mov	r1, r6
 8004442:	f003 f8cd 	bl	80075e0 <GUI_MULTIBUF_ConfigEx>
    }
#endif

  /* Set display driver and color conversion for 1st layer */
  GUI_DEVICE_CreateAndLink(DISPLAY_DRIVER_0, COLOR_CONVERSION_0, 0, 0);
 8004446:	4623      	mov	r3, r4
 8004448:	4622      	mov	r2, r4
 800444a:	4927      	ldr	r1, [pc, #156]	; (80044e8 <LCD_X_Config+0x138>)
 800444c:	4827      	ldr	r0, [pc, #156]	; (80044ec <LCD_X_Config+0x13c>)
 800444e:	f003 fa43 	bl	80078d8 <GUI_DEVICE_CreateAndLink>

  /* Set size of 1st layer */
  if (LCD_GetSwapXYEx(0))
 8004452:	4620      	mov	r0, r4
 8004454:	f002 fac2 	bl	80069dc <LCD_GetSwapXYEx>
 8004458:	4605      	mov	r5, r0
 800445a:	b150      	cbz	r0, 8004472 <LCD_X_Config+0xc2>
    {
      LCD_SetSizeEx (0, YSIZE_PHYS, XSIZE_PHYS);
 800445c:	22f0      	movs	r2, #240	; 0xf0
 800445e:	f44f 71a0 	mov.w	r1, #320	; 0x140
 8004462:	4620      	mov	r0, r4
 8004464:	f002 fa28 	bl	80068b8 <LCD_SetSizeEx>
      LCD_SetVSizeEx(0, YSIZE_PHYS * NUM_VSCREENS, XSIZE_PHYS);
 8004468:	22f0      	movs	r2, #240	; 0xf0
 800446a:	f44f 71a0 	mov.w	r1, #320	; 0x140
 800446e:	4620      	mov	r0, r4
 8004470:	e008      	b.n	8004484 <LCD_X_Config+0xd4>
    }
  else
    {
      LCD_SetSizeEx (0, XSIZE_PHYS, YSIZE_PHYS);
 8004472:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8004476:	21f0      	movs	r1, #240	; 0xf0
 8004478:	f002 fa1e 	bl	80068b8 <LCD_SetSizeEx>
      LCD_SetVSizeEx(0, XSIZE_PHYS, YSIZE_PHYS * NUM_VSCREENS);
 800447c:	f44f 72a0 	mov.w	r2, #320	; 0x140
 8004480:	21f0      	movs	r1, #240	; 0xf0
 8004482:	4628      	mov	r0, r5
    }
#endif


  /*Initialize GUI Layer structure */
  layer_prop[0].address = LCD_LAYER0_FRAME_BUFFER;
 8004484:	4c1a      	ldr	r4, [pc, #104]	; (80044f0 <LCD_X_Config+0x140>)
      LCD_SetVSizeEx(0, YSIZE_PHYS * NUM_VSCREENS, XSIZE_PHYS);
    }
  else
    {
      LCD_SetSizeEx (0, XSIZE_PHYS, YSIZE_PHYS);
      LCD_SetVSizeEx(0, XSIZE_PHYS, YSIZE_PHYS * NUM_VSCREENS);
 8004486:	f002 f9ff 	bl	8006888 <LCD_SetVSizeEx>

  /* Setting up VRam address and custom functions for CopyBuffer-, CopyRect- and FillRect operations */
  for (i = 0; i < GUI_NUM_LAYERS; i++)
    {

      layer_prop[i].pColorConvAPI = (LCD_API_COLOR_CONV *)apColorConvAPI[i];
 800448a:	4b17      	ldr	r3, [pc, #92]	; (80044e8 <LCD_X_Config+0x138>)
    }
#endif


  /*Initialize GUI Layer structure */
  layer_prop[0].address = LCD_LAYER0_FRAME_BUFFER;
 800448c:	4919      	ldr	r1, [pc, #100]	; (80044f4 <LCD_X_Config+0x144>)

  /* Setting up VRam address and custom functions for CopyBuffer-, CopyRect- and FillRect operations */
  for (i = 0; i < GUI_NUM_LAYERS; i++)
    {

      layer_prop[i].pColorConvAPI = (LCD_API_COLOR_CONV *)apColorConvAPI[i];
 800448e:	61a3      	str	r3, [r4, #24]

      layer_prop[i].pending_buffer = -1;
 8004490:	f04f 33ff 	mov.w	r3, #4294967295
 8004494:	6063      	str	r3, [r4, #4]
    }
#endif


  /*Initialize GUI Layer structure */
  layer_prop[0].address = LCD_LAYER0_FRAME_BUFFER;
 8004496:	6021      	str	r1, [r4, #0]
      layer_prop[i].pColorConvAPI = (LCD_API_COLOR_CONV *)apColorConvAPI[i];

      layer_prop[i].pending_buffer = -1;

      /* Set VRAM address */
      LCD_SetVRAMAddrEx(i, (void *)(layer_prop[i].address));
 8004498:	2000      	movs	r0, #0
 800449a:	f002 f9df 	bl	800685c <LCD_SetVRAMAddrEx>

      /* Remember color depth for further operations */
      layer_prop[i].BytesPerPixel = LCD_GetBitsPerPixelEx(i) >> 3;
 800449e:	2000      	movs	r0, #0
 80044a0:	f002 fa90 	bl	80069c4 <LCD_GetBitsPerPixelEx>
 80044a4:	10c0      	asrs	r0, r0, #3
 80044a6:	6160      	str	r0, [r4, #20]

      /* Set custom functions for several operations */
      LCD_SetDevFunc(i, LCD_DEVFUNC_COPYBUFFER, (void(*)(void))CUSTOM_CopyBuffer);
 80044a8:	4a13      	ldr	r2, [pc, #76]	; (80044f8 <LCD_X_Config+0x148>)
 80044aa:	2121      	movs	r1, #33	; 0x21
 80044ac:	2000      	movs	r0, #0
 80044ae:	f002 fa4b 	bl	8006948 <LCD_SetDevFunc>
      LCD_SetDevFunc(i, LCD_DEVFUNC_COPYRECT,   (void(*)(void))CUSTOM_CopyRect);
 80044b2:	4a12      	ldr	r2, [pc, #72]	; (80044fc <LCD_X_Config+0x14c>)
 80044b4:	2123      	movs	r1, #35	; 0x23
 80044b6:	2000      	movs	r0, #0
 80044b8:	f002 fa46 	bl	8006948 <LCD_SetDevFunc>
      LCD_SetDevFunc(i, LCD_DEVFUNC_FILLRECT, (void(*)(void))CUSTOM_FillRect);
 80044bc:	4a10      	ldr	r2, [pc, #64]	; (8004500 <LCD_X_Config+0x150>)
 80044be:	2119      	movs	r1, #25
 80044c0:	2000      	movs	r0, #0
 80044c2:	f002 fa41 	bl	8006948 <LCD_SetDevFunc>

      /* Set up drawing routine for 32bpp bitmap using DMA2D */
      if (LCD_LL_GetPixelformat(i) == LTDC_PIXEL_FORMAT_ARGB8888)
        {
          LCD_SetDevFunc(i, LCD_DEVFUNC_DRAWBMP_32BPP, (void(*)(void))CUSTOM_DrawBitmap32bpp);     /* Set up drawing routine for 32bpp bitmap using DMA2D. Makes only sense with ARGB8888 */
 80044c6:	4a0f      	ldr	r2, [pc, #60]	; (8004504 <LCD_X_Config+0x154>)
 80044c8:	2128      	movs	r1, #40	; 0x28
 80044ca:	2000      	movs	r0, #0
        }
    }
}
 80044cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      LCD_SetDevFunc(i, LCD_DEVFUNC_FILLRECT, (void(*)(void))CUSTOM_FillRect);

      /* Set up drawing routine for 32bpp bitmap using DMA2D */
      if (LCD_LL_GetPixelformat(i) == LTDC_PIXEL_FORMAT_ARGB8888)
        {
          LCD_SetDevFunc(i, LCD_DEVFUNC_DRAWBMP_32BPP, (void(*)(void))CUSTOM_DrawBitmap32bpp);     /* Set up drawing routine for 32bpp bitmap using DMA2D. Makes only sense with ARGB8888 */
 80044d0:	f002 ba3a 	b.w	8006948 <LCD_SetDevFunc>
 80044d4:	200221e0 	.word	0x200221e0
 80044d8:	20001f64 	.word	0x20001f64
 80044dc:	40016800 	.word	0x40016800
 80044e0:	20001f08 	.word	0x20001f08
 80044e4:	4002b000 	.word	0x4002b000
 80044e8:	0800b480 	.word	0x0800b480
 80044ec:	0800b338 	.word	0x0800b338
 80044f0:	20001f48 	.word	0x20001f48
 80044f4:	d0200000 	.word	0xd0200000
 80044f8:	08004149 	.word	0x08004149
 80044fc:	08004051 	.word	0x08004051
 8004500:	08004091 	.word	0x08004091
 8004504:	08004181 	.word	0x08004181

08004508 <LCD_X_DisplayDriver>:
  * @param  Cmd       :Please refer to the details in the switch statement below
  * @param  pData     :Pointer to a LCD_X_DATA structure
  * @retval Status (-1 : Error,  0 : Ok)
  */
int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData)
{
 8004508:	b5f0      	push	{r4, r5, r6, r7, lr}
  int r = 0;
  U32 addr;
  int xPos, yPos;
  U32 Color;

  switch (Cmd)
 800450a:	3901      	subs	r1, #1
  * @param  Cmd       :Please refer to the details in the switch statement below
  * @param  pData     :Pointer to a LCD_X_DATA structure
  * @retval Status (-1 : Error,  0 : Ok)
  */
int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData)
{
 800450c:	b08f      	sub	sp, #60	; 0x3c
 800450e:	4604      	mov	r4, r0
 8004510:	4615      	mov	r5, r2
  int r = 0;
  U32 addr;
  int xPos, yPos;
  U32 Color;

  switch (Cmd)
 8004512:	290d      	cmp	r1, #13
 8004514:	f200 80ac 	bhi.w	8004670 <LCD_X_DisplayDriver+0x168>
 8004518:	e8df f001 	tbb	[pc, r1]
 800451c:	4b34aa07 	.word	0x4b34aa07
 8004520:	74775852 	.word	0x74775852
 8004524:	90aa8a5f 	.word	0x90aa8a5f
 8004528:	449a      	.short	0x449a
  */
static void LCD_LL_LayerInit(U32 LayerIndex)
{
  LTDC_LayerCfgTypeDef             layer_cfg;

  if (LayerIndex < GUI_NUM_LAYERS)
 800452a:	2800      	cmp	r0, #0
 800452c:	f040 809e 	bne.w	800466c <LCD_X_DisplayDriver+0x164>
      layer_cfg.WindowX0 = 0;
      layer_cfg.WindowX1 = XSIZE_PHYS;
      layer_cfg.WindowY0 = 0;
      layer_cfg.WindowY1 = YSIZE_PHYS;
      layer_cfg.PixelFormat = LCD_LL_GetPixelformat(LayerIndex);
      layer_cfg.FBStartAdress = layer_prop[LayerIndex].address;
 8004530:	4951      	ldr	r1, [pc, #324]	; (8004678 <LCD_X_DisplayDriver+0x170>)
  LTDC_LayerCfgTypeDef             layer_cfg;

  if (LayerIndex < GUI_NUM_LAYERS)
    {
      /* Layer configuration */
      layer_cfg.WindowX0 = 0;
 8004532:	9001      	str	r0, [sp, #4]
      layer_cfg.WindowX1 = XSIZE_PHYS;
      layer_cfg.WindowY0 = 0;
      layer_cfg.WindowY1 = YSIZE_PHYS;
      layer_cfg.PixelFormat = LCD_LL_GetPixelformat(LayerIndex);
      layer_cfg.FBStartAdress = layer_prop[LayerIndex].address;
 8004534:	6809      	ldr	r1, [r1, #0]
 8004536:	910a      	str	r1, [sp, #40]	; 0x28
      layer_cfg.Alpha = 255;
 8004538:	21ff      	movs	r1, #255	; 0xff
 800453a:	9106      	str	r1, [sp, #24]
      layer_cfg.Alpha0 = 0;
      layer_cfg.Backcolor.Blue = 0;
      layer_cfg.Backcolor.Green = 0;
      layer_cfg.Backcolor.Red = 0;
      layer_cfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
 800453c:	f44f 61c0 	mov.w	r1, #1536	; 0x600

  if (LayerIndex < GUI_NUM_LAYERS)
    {
      /* Layer configuration */
      layer_cfg.WindowX0 = 0;
      layer_cfg.WindowX1 = XSIZE_PHYS;
 8004540:	22f0      	movs	r2, #240	; 0xf0
      layer_cfg.Alpha = 255;
      layer_cfg.Alpha0 = 0;
      layer_cfg.Backcolor.Blue = 0;
      layer_cfg.Backcolor.Green = 0;
      layer_cfg.Backcolor.Red = 0;
      layer_cfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
 8004542:	9108      	str	r1, [sp, #32]
      layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 8004544:	2107      	movs	r1, #7
    {
      /* Layer configuration */
      layer_cfg.WindowX0 = 0;
      layer_cfg.WindowX1 = XSIZE_PHYS;
      layer_cfg.WindowY0 = 0;
      layer_cfg.WindowY1 = YSIZE_PHYS;
 8004546:	f44f 73a0 	mov.w	r3, #320	; 0x140

  if (LayerIndex < GUI_NUM_LAYERS)
    {
      /* Layer configuration */
      layer_cfg.WindowX0 = 0;
      layer_cfg.WindowX1 = XSIZE_PHYS;
 800454a:	9202      	str	r2, [sp, #8]
      layer_cfg.WindowY0 = 0;
 800454c:	9003      	str	r0, [sp, #12]
      layer_cfg.WindowY1 = YSIZE_PHYS;
      layer_cfg.PixelFormat = LCD_LL_GetPixelformat(LayerIndex);
 800454e:	9005      	str	r0, [sp, #20]
      layer_cfg.FBStartAdress = layer_prop[LayerIndex].address;
      layer_cfg.Alpha = 255;
      layer_cfg.Alpha0 = 0;
 8004550:	9007      	str	r0, [sp, #28]
      layer_cfg.Backcolor.Blue = 0;
 8004552:	f88d 0034 	strb.w	r0, [sp, #52]	; 0x34
      layer_cfg.Backcolor.Green = 0;
 8004556:	f88d 0035 	strb.w	r0, [sp, #53]	; 0x35
      layer_cfg.Backcolor.Red = 0;
 800455a:	f88d 0036 	strb.w	r0, [sp, #54]	; 0x36
      layer_cfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
      layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
 800455e:	9109      	str	r1, [sp, #36]	; 0x24
      layer_cfg.ImageWidth = XSIZE_PHYS;
 8004560:	920b      	str	r2, [sp, #44]	; 0x2c
      layer_cfg.ImageHeight = YSIZE_PHYS;
      HAL_LTDC_ConfigLayer(&hltdc, &layer_cfg, LayerIndex);
 8004562:	a901      	add	r1, sp, #4
 8004564:	4602      	mov	r2, r0
 8004566:	4845      	ldr	r0, [pc, #276]	; (800467c <LCD_X_DisplayDriver+0x174>)
    {
      /* Layer configuration */
      layer_cfg.WindowX0 = 0;
      layer_cfg.WindowX1 = XSIZE_PHYS;
      layer_cfg.WindowY0 = 0;
      layer_cfg.WindowY1 = YSIZE_PHYS;
 8004568:	9304      	str	r3, [sp, #16]
      layer_cfg.Backcolor.Green = 0;
      layer_cfg.Backcolor.Red = 0;
      layer_cfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
      layer_cfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
      layer_cfg.ImageWidth = XSIZE_PHYS;
      layer_cfg.ImageHeight = YSIZE_PHYS;
 800456a:	930c      	str	r3, [sp, #48]	; 0x30
      HAL_LTDC_ConfigLayer(&hltdc, &layer_cfg, LayerIndex);
 800456c:	f7fe fb01 	bl	8002b72 <HAL_LTDC_ConfigLayer>

      /* Enable LUT on demand */
      if (LCD_GetBitsPerPixelEx(LayerIndex) <= 8)
 8004570:	4620      	mov	r0, r4
 8004572:	f002 fa27 	bl	80069c4 <LCD_GetBitsPerPixelEx>
 8004576:	2808      	cmp	r0, #8
 8004578:	dc78      	bgt.n	800466c <LCD_X_DisplayDriver+0x164>
        {
          /* Enable usage of LUT for all modes with <= 8bpp*/
          HAL_LTDC_EnableCLUT(&hltdc, LayerIndex);
 800457a:	4621      	mov	r1, r4
 800457c:	483f      	ldr	r0, [pc, #252]	; (800467c <LCD_X_DisplayDriver+0x174>)
 800457e:	f7fe fba9 	bl	8002cd4 <HAL_LTDC_EnableCLUT>
 8004582:	e073      	b.n	800466c <LCD_X_DisplayDriver+0x164>
    case LCD_X_INITCONTROLLER:
      LCD_LL_LayerInit(LayerIndex);
      break;

    case LCD_X_SETORG:
      addr = layer_prop[LayerIndex].address + ((LCD_X_SETORG_INFO *)pData)->yPos * layer_prop[LayerIndex].xSize * layer_prop[LayerIndex].BytesPerPixel;
 8004584:	4e3c      	ldr	r6, [pc, #240]	; (8004678 <LCD_X_DisplayDriver+0x170>)
 8004586:	231c      	movs	r3, #28
 8004588:	4343      	muls	r3, r0
 800458a:	18f7      	adds	r7, r6, r3
      HAL_LTDC_SetAddress(&hltdc, addr, LayerIndex);
 800458c:	6850      	ldr	r0, [r2, #4]
 800458e:	68fa      	ldr	r2, [r7, #12]
 8004590:	6979      	ldr	r1, [r7, #20]
 8004592:	58f3      	ldr	r3, [r6, r3]
 8004594:	4350      	muls	r0, r2
 8004596:	fb01 3100 	mla	r1, r1, r0, r3
 800459a:	4622      	mov	r2, r4
 800459c:	4837      	ldr	r0, [pc, #220]	; (800467c <LCD_X_DisplayDriver+0x174>)
 800459e:	f7fe fc01 	bl	8002da4 <HAL_LTDC_SetAddress>
 80045a2:	e063      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_SHOWBUFFER:
      layer_prop[LayerIndex].pending_buffer = ((LCD_X_SHOWBUFFER_INFO *)pData)->Index;
 80045a4:	4934      	ldr	r1, [pc, #208]	; (8004678 <LCD_X_DisplayDriver+0x170>)
 80045a6:	6812      	ldr	r2, [r2, #0]
 80045a8:	231c      	movs	r3, #28
 80045aa:	fb03 1400 	mla	r4, r3, r0, r1
 80045ae:	6062      	str	r2, [r4, #4]
 80045b0:	e05c      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_SETLUTENTRY:
      HAL_LTDC_ConfigCLUT(&hltdc, (uint32_t *) & (((LCD_X_SETLUTENTRY_INFO *)pData)->Color), 1, LayerIndex);
 80045b2:	4603      	mov	r3, r0
 80045b4:	2201      	movs	r2, #1
 80045b6:	4629      	mov	r1, r5
 80045b8:	4830      	ldr	r0, [pc, #192]	; (800467c <LCD_X_DisplayDriver+0x174>)
 80045ba:	f7fe fb1f 	bl	8002bfc <HAL_LTDC_ConfigCLUT>
 80045be:	e055      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_ON:
      __HAL_LTDC_ENABLE(&hltdc);
 80045c0:	4b2e      	ldr	r3, [pc, #184]	; (800467c <LCD_X_DisplayDriver+0x174>)
 80045c2:	681a      	ldr	r2, [r3, #0]
 80045c4:	6993      	ldr	r3, [r2, #24]
 80045c6:	f043 0301 	orr.w	r3, r3, #1
 80045ca:	e004      	b.n	80045d6 <LCD_X_DisplayDriver+0xce>
      break;

    case LCD_X_OFF:
      __HAL_LTDC_DISABLE(&hltdc);
 80045cc:	4b2b      	ldr	r3, [pc, #172]	; (800467c <LCD_X_DisplayDriver+0x174>)
 80045ce:	681a      	ldr	r2, [r3, #0]
 80045d0:	6993      	ldr	r3, [r2, #24]
 80045d2:	f023 0301 	bic.w	r3, r3, #1
 80045d6:	6193      	str	r3, [r2, #24]
 80045d8:	e048      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_SETVIS:
      if (((LCD_X_SETVIS_INFO *)pData)->OnOff  == ENABLE )
 80045da:	6813      	ldr	r3, [r2, #0]
 80045dc:	4a27      	ldr	r2, [pc, #156]	; (800467c <LCD_X_DisplayDriver+0x174>)
 80045de:	2b01      	cmp	r3, #1
        {
          __HAL_LTDC_LAYER_ENABLE(&hltdc, LayerIndex);
 80045e0:	6813      	ldr	r3, [r2, #0]
        }
      else
        {
          __HAL_LTDC_LAYER_DISABLE(&hltdc, LayerIndex);
        }
      __HAL_LTDC_RELOAD_CONFIG(&hltdc);
 80045e2:	6812      	ldr	r2, [r2, #0]
      break;

    case LCD_X_SETVIS:
      if (((LCD_X_SETVIS_INFO *)pData)->OnOff  == ENABLE )
        {
          __HAL_LTDC_LAYER_ENABLE(&hltdc, LayerIndex);
 80045e4:	f103 0384 	add.w	r3, r3, #132	; 0x84
 80045e8:	ea4f 14c0 	mov.w	r4, r0, lsl #7
 80045ec:	5919      	ldr	r1, [r3, r4]
 80045ee:	bf0c      	ite	eq
 80045f0:	f041 0101 	orreq.w	r1, r1, #1
        }
      else
        {
          __HAL_LTDC_LAYER_DISABLE(&hltdc, LayerIndex);
 80045f4:	f021 0101 	bicne.w	r1, r1, #1
 80045f8:	5119      	str	r1, [r3, r4]
        }
      __HAL_LTDC_RELOAD_CONFIG(&hltdc);
 80045fa:	6a53      	ldr	r3, [r2, #36]	; 0x24
 80045fc:	f043 0301 	orr.w	r3, r3, #1
 8004600:	6253      	str	r3, [r2, #36]	; 0x24
 8004602:	e033      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_SETPOS:
      HAL_LTDC_SetWindowPosition(&hltdc,
 8004604:	4603      	mov	r3, r0
 8004606:	ca06      	ldmia	r2, {r1, r2}
 8004608:	e00e      	b.n	8004628 <LCD_X_DisplayDriver+0x120>
                                 ((LCD_X_SETPOS_INFO *)pData)->yPos,
                                 LayerIndex);
      break;

    case LCD_X_SETSIZE:
      GUI_GetLayerPosEx(LayerIndex, &xPos, &yPos);
 800460a:	aa01      	add	r2, sp, #4
 800460c:	4669      	mov	r1, sp
 800460e:	f002 ff49 	bl	80074a4 <GUI_GetLayerPosEx>
      layer_prop[LayerIndex].xSize = ((LCD_X_SETSIZE_INFO *)pData)->xSize;
 8004612:	4a19      	ldr	r2, [pc, #100]	; (8004678 <LCD_X_DisplayDriver+0x170>)
 8004614:	231c      	movs	r3, #28
 8004616:	fb03 2304 	mla	r3, r3, r4, r2
 800461a:	682a      	ldr	r2, [r5, #0]
 800461c:	60da      	str	r2, [r3, #12]
      layer_prop[LayerIndex].ySize = ((LCD_X_SETSIZE_INFO *)pData)->ySize;
 800461e:	686a      	ldr	r2, [r5, #4]
 8004620:	611a      	str	r2, [r3, #16]
      HAL_LTDC_SetWindowPosition(&hltdc, xPos, yPos, LayerIndex);
 8004622:	e89d 0006 	ldmia.w	sp, {r1, r2}
 8004626:	4623      	mov	r3, r4
 8004628:	4814      	ldr	r0, [pc, #80]	; (800467c <LCD_X_DisplayDriver+0x174>)
 800462a:	f7fe fb6d 	bl	8002d08 <HAL_LTDC_SetWindowPosition>
 800462e:	e01d      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_SETALPHA:
      HAL_LTDC_SetAlpha(&hltdc, ((LCD_X_SETALPHA_INFO *)pData)->Alpha, LayerIndex);
 8004630:	4602      	mov	r2, r0
 8004632:	6829      	ldr	r1, [r5, #0]
 8004634:	4811      	ldr	r0, [pc, #68]	; (800467c <LCD_X_DisplayDriver+0x174>)
 8004636:	f7fe fb95 	bl	8002d64 <HAL_LTDC_SetAlpha>
 800463a:	e017      	b.n	800466c <LCD_X_DisplayDriver+0x164>
      break;

    case LCD_X_SETCHROMAMODE:
      if (((LCD_X_SETCHROMAMODE_INFO *)pData)->ChromaMode != 0)
 800463c:	6815      	ldr	r5, [r2, #0]
        {
          HAL_LTDC_EnableColorKeying(&hltdc, LayerIndex);
 800463e:	4601      	mov	r1, r0
 8004640:	480e      	ldr	r0, [pc, #56]	; (800467c <LCD_X_DisplayDriver+0x174>)
    case LCD_X_SETALPHA:
      HAL_LTDC_SetAlpha(&hltdc, ((LCD_X_SETALPHA_INFO *)pData)->Alpha, LayerIndex);
      break;

    case LCD_X_SETCHROMAMODE:
      if (((LCD_X_SETCHROMAMODE_INFO *)pData)->ChromaMode != 0)
 8004642:	b115      	cbz	r5, 800464a <LCD_X_DisplayDriver+0x142>
        {
          HAL_LTDC_EnableColorKeying(&hltdc, LayerIndex);
 8004644:	f7fe fb12 	bl	8002c6c <HAL_LTDC_EnableColorKeying>
 8004648:	e010      	b.n	800466c <LCD_X_DisplayDriver+0x164>
        }
      else
        {
          HAL_LTDC_DisableColorKeying(&hltdc, LayerIndex);
 800464a:	f7fe fb29 	bl	8002ca0 <HAL_LTDC_DisableColorKeying>
 800464e:	e00d      	b.n	800466c <LCD_X_DisplayDriver+0x164>
        }
      break;

    case LCD_X_SETCHROMA:

      Color = ((((LCD_X_SETCHROMA_INFO *)pData)->ChromaMin & 0xFF0000) >> 16) | \
 8004650:	6813      	ldr	r3, [r2, #0]
              (((LCD_X_SETCHROMA_INFO *)pData)->ChromaMin & 0x00FF00) | \
              ((((LCD_X_SETCHROMA_INFO *)pData)->ChromaMin & 0x0000FF) << 16);

      HAL_LTDC_ConfigColorKeying(&hltdc, Color, LayerIndex);
 8004652:	0419      	lsls	r1, r3, #16
 8004654:	f3c3 4207 	ubfx	r2, r3, #16, #8
 8004658:	f401 017f 	and.w	r1, r1, #16711680	; 0xff0000
 800465c:	4311      	orrs	r1, r2
 800465e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8004662:	4602      	mov	r2, r0
 8004664:	4319      	orrs	r1, r3
 8004666:	4805      	ldr	r0, [pc, #20]	; (800467c <LCD_X_DisplayDriver+0x174>)
 8004668:	f7fe faac 	bl	8002bc4 <HAL_LTDC_ConfigColorKeying>
  * @param  pData     :Pointer to a LCD_X_DATA structure
  * @retval Status (-1 : Error,  0 : Ok)
  */
int LCD_X_DisplayDriver(unsigned LayerIndex, unsigned Cmd, void * pData)
{
  int r = 0;
 800466c:	2000      	movs	r0, #0
      Color = ((((LCD_X_SETCHROMA_INFO *)pData)->ChromaMin & 0xFF0000) >> 16) | \
              (((LCD_X_SETCHROMA_INFO *)pData)->ChromaMin & 0x00FF00) | \
              ((((LCD_X_SETCHROMA_INFO *)pData)->ChromaMin & 0x0000FF) << 16);

      HAL_LTDC_ConfigColorKeying(&hltdc, Color, LayerIndex);
      break;
 800466e:	e001      	b.n	8004674 <LCD_X_DisplayDriver+0x16c>

    default:
      r = -1;
 8004670:	f04f 30ff 	mov.w	r0, #4294967295
    }
  return r;
}
 8004674:	b00f      	add	sp, #60	; 0x3c
 8004676:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004678:	20001f48 	.word	0x20001f48
 800467c:	200221e0 	.word	0x200221e0

08004680 <GUI_X_Init>:
 8004680:	4770      	bx	lr
	...

08004684 <WM_SetCreateFlags>:
 8004684:	4b02      	ldr	r3, [pc, #8]	; (8004690 <WM_SetCreateFlags+0xc>)
 8004686:	681a      	ldr	r2, [r3, #0]
 8004688:	6018      	str	r0, [r3, #0]
 800468a:	4610      	mov	r0, r2
 800468c:	4770      	bx	lr
 800468e:	bf00      	nop
 8004690:	200222b8 	.word	0x200222b8

08004694 <_OnExit>:
 8004694:	4a0a      	ldr	r2, [pc, #40]	; (80046c0 <_OnExit+0x2c>)
 8004696:	490b      	ldr	r1, [pc, #44]	; (80046c4 <_OnExit+0x30>)
 8004698:	2300      	movs	r3, #0
 800469a:	7013      	strb	r3, [r2, #0]
 800469c:	4a0a      	ldr	r2, [pc, #40]	; (80046c8 <_OnExit+0x34>)
 800469e:	600b      	str	r3, [r1, #0]
 80046a0:	6013      	str	r3, [r2, #0]
 80046a2:	4a0a      	ldr	r2, [pc, #40]	; (80046cc <_OnExit+0x38>)
 80046a4:	604b      	str	r3, [r1, #4]
 80046a6:	6013      	str	r3, [r2, #0]
 80046a8:	4a09      	ldr	r2, [pc, #36]	; (80046d0 <_OnExit+0x3c>)
 80046aa:	6013      	str	r3, [r2, #0]
 80046ac:	6053      	str	r3, [r2, #4]
 80046ae:	4a09      	ldr	r2, [pc, #36]	; (80046d4 <_OnExit+0x40>)
 80046b0:	6013      	str	r3, [r2, #0]
 80046b2:	4a09      	ldr	r2, [pc, #36]	; (80046d8 <_OnExit+0x44>)
 80046b4:	6013      	str	r3, [r2, #0]
 80046b6:	4a09      	ldr	r2, [pc, #36]	; (80046dc <_OnExit+0x48>)
 80046b8:	6013      	str	r3, [r2, #0]
 80046ba:	4a09      	ldr	r2, [pc, #36]	; (80046e0 <_OnExit+0x4c>)
 80046bc:	6013      	str	r3, [r2, #0]
 80046be:	4770      	bx	lr
 80046c0:	20001fbc 	.word	0x20001fbc
 80046c4:	200222a0 	.word	0x200222a0
 80046c8:	20001f94 	.word	0x20001f94
 80046cc:	200222c4 	.word	0x200222c4
 80046d0:	200222cc 	.word	0x200222cc
 80046d4:	200222d8 	.word	0x200222d8
 80046d8:	2002228c 	.word	0x2002228c
 80046dc:	200222b8 	.word	0x200222b8
 80046e0:	200222c8 	.word	0x200222c8

080046e4 <_Findy1>:
 80046e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80046e6:	4605      	mov	r5, r0
 80046e8:	b085      	sub	sp, #20
 80046ea:	460c      	mov	r4, r1
 80046ec:	4616      	mov	r6, r2
 80046ee:	2d00      	cmp	r5, #0
 80046f0:	d04c      	beq.n	800478c <_Findy1+0xa8>
 80046f2:	4628      	mov	r0, r5
 80046f4:	f003 fdb0 	bl	8008258 <GUI_ALLOC_LockH>
 80046f8:	6a87      	ldr	r7, [r0, #40]	; 0x28
 80046fa:	9001      	str	r0, [sp, #4]
 80046fc:	07bb      	lsls	r3, r7, #30
 80046fe:	4601      	mov	r1, r0
 8004700:	d53d      	bpl.n	800477e <_Findy1+0x9a>
 8004702:	ad02      	add	r5, sp, #8
 8004704:	b126      	cbz	r6, 8004710 <_Findy1+0x2c>
 8004706:	4628      	mov	r0, r5
 8004708:	4632      	mov	r2, r6
 800470a:	f002 fcb3 	bl	8007074 <GUI__IntersectRects>
 800470e:	e002      	b.n	8004716 <_Findy1+0x32>
 8004710:	c803      	ldmia	r0, {r0, r1}
 8004712:	e885 0003 	stmia.w	r5, {r0, r1}
 8004716:	4620      	mov	r0, r4
 8004718:	4629      	mov	r1, r5
 800471a:	f002 fee8 	bl	80074ee <GUI_RectsIntersect>
 800471e:	b370      	cbz	r0, 800477e <_Findy1+0x9a>
 8004720:	f017 0f01 	tst.w	r7, #1
 8004724:	9b01      	ldr	r3, [sp, #4]
 8004726:	d11e      	bne.n	8004766 <_Findy1+0x82>
 8004728:	b13e      	cbz	r6, 800473a <_Findy1+0x56>
 800472a:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 800472e:	f9b6 3002 	ldrsh.w	r3, [r6, #2]
 8004732:	429a      	cmp	r2, r3
 8004734:	bfa8      	it	ge
 8004736:	4613      	movge	r3, r2
 8004738:	e001      	b.n	800473e <_Findy1+0x5a>
 800473a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
 800473e:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 8004742:	4293      	cmp	r3, r2
 8004744:	f9b4 2006 	ldrsh.w	r2, [r4, #6]
 8004748:	dd06      	ble.n	8004758 <_Findy1+0x74>
 800474a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 800474e:	b219      	sxth	r1, r3
 8004750:	428a      	cmp	r2, r1
 8004752:	db14      	blt.n	800477e <_Findy1+0x9a>
 8004754:	3b01      	subs	r3, #1
 8004756:	e004      	b.n	8004762 <_Findy1+0x7e>
 8004758:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800475c:	b219      	sxth	r1, r3
 800475e:	428a      	cmp	r2, r1
 8004760:	dd0d      	ble.n	800477e <_Findy1+0x9a>
 8004762:	80e3      	strh	r3, [r4, #6]
 8004764:	e00b      	b.n	800477e <_Findy1+0x9a>
 8004766:	69df      	ldr	r7, [r3, #28]
 8004768:	b14f      	cbz	r7, 800477e <_Findy1+0x9a>
 800476a:	4638      	mov	r0, r7
 800476c:	4621      	mov	r1, r4
 800476e:	462a      	mov	r2, r5
 8004770:	f7ff ffb8 	bl	80046e4 <_Findy1>
 8004774:	4638      	mov	r0, r7
 8004776:	f003 fd65 	bl	8008244 <GUI_ALLOC_h2p>
 800477a:	6a07      	ldr	r7, [r0, #32]
 800477c:	e7f4      	b.n	8004768 <_Findy1+0x84>
 800477e:	a804      	add	r0, sp, #16
 8004780:	f850 3d0c 	ldr.w	r3, [r0, #-12]!
 8004784:	6a1d      	ldr	r5, [r3, #32]
 8004786:	f003 fd75 	bl	8008274 <GUI_ALLOC_UnlockH>
 800478a:	e7b0      	b.n	80046ee <_Findy1+0xa>
 800478c:	b005      	add	sp, #20
 800478e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004790 <_Findx0>:
 8004790:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8004794:	4604      	mov	r4, r0
 8004796:	460f      	mov	r7, r1
 8004798:	4690      	mov	r8, r2
 800479a:	2500      	movs	r5, #0
 800479c:	2c00      	cmp	r4, #0
 800479e:	d037      	beq.n	8004810 <_Findx0+0x80>
 80047a0:	4620      	mov	r0, r4
 80047a2:	f003 fd59 	bl	8008258 <GUI_ALLOC_LockH>
 80047a6:	6a86      	ldr	r6, [r0, #40]	; 0x28
 80047a8:	9001      	str	r0, [sp, #4]
 80047aa:	07b2      	lsls	r2, r6, #30
 80047ac:	4601      	mov	r1, r0
 80047ae:	d528      	bpl.n	8004802 <_Findx0+0x72>
 80047b0:	ac02      	add	r4, sp, #8
 80047b2:	f1b8 0f00 	cmp.w	r8, #0
 80047b6:	d004      	beq.n	80047c2 <_Findx0+0x32>
 80047b8:	4620      	mov	r0, r4
 80047ba:	4642      	mov	r2, r8
 80047bc:	f002 fc5a 	bl	8007074 <GUI__IntersectRects>
 80047c0:	e002      	b.n	80047c8 <_Findx0+0x38>
 80047c2:	c803      	ldmia	r0, {r0, r1}
 80047c4:	e884 0003 	stmia.w	r4, {r0, r1}
 80047c8:	4638      	mov	r0, r7
 80047ca:	4621      	mov	r1, r4
 80047cc:	f002 fe8f 	bl	80074ee <GUI_RectsIntersect>
 80047d0:	b1b8      	cbz	r0, 8004802 <_Findx0+0x72>
 80047d2:	07f3      	lsls	r3, r6, #31
 80047d4:	d405      	bmi.n	80047e2 <_Findx0+0x52>
 80047d6:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80047da:	3301      	adds	r3, #1
 80047dc:	803b      	strh	r3, [r7, #0]
 80047de:	2501      	movs	r5, #1
 80047e0:	e00f      	b.n	8004802 <_Findx0+0x72>
 80047e2:	9b01      	ldr	r3, [sp, #4]
 80047e4:	69de      	ldr	r6, [r3, #28]
 80047e6:	b166      	cbz	r6, 8004802 <_Findx0+0x72>
 80047e8:	4630      	mov	r0, r6
 80047ea:	4639      	mov	r1, r7
 80047ec:	4622      	mov	r2, r4
 80047ee:	f7ff ffcf 	bl	8004790 <_Findx0>
 80047f2:	2800      	cmp	r0, #0
 80047f4:	4630      	mov	r0, r6
 80047f6:	bf18      	it	ne
 80047f8:	2501      	movne	r5, #1
 80047fa:	f003 fd23 	bl	8008244 <GUI_ALLOC_h2p>
 80047fe:	6a06      	ldr	r6, [r0, #32]
 8004800:	e7f1      	b.n	80047e6 <_Findx0+0x56>
 8004802:	a804      	add	r0, sp, #16
 8004804:	f850 3d0c 	ldr.w	r3, [r0, #-12]!
 8004808:	6a1c      	ldr	r4, [r3, #32]
 800480a:	f003 fd33 	bl	8008274 <GUI_ALLOC_UnlockH>
 800480e:	e7c5      	b.n	800479c <_Findx0+0xc>
 8004810:	4628      	mov	r0, r5
 8004812:	b004      	add	sp, #16
 8004814:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004818 <_Findx1>:
 8004818:	b5f0      	push	{r4, r5, r6, r7, lr}
 800481a:	4604      	mov	r4, r0
 800481c:	b085      	sub	sp, #20
 800481e:	460e      	mov	r6, r1
 8004820:	4617      	mov	r7, r2
 8004822:	2c00      	cmp	r4, #0
 8004824:	d031      	beq.n	800488a <_Findx1+0x72>
 8004826:	4620      	mov	r0, r4
 8004828:	f003 fd16 	bl	8008258 <GUI_ALLOC_LockH>
 800482c:	6a85      	ldr	r5, [r0, #40]	; 0x28
 800482e:	9001      	str	r0, [sp, #4]
 8004830:	07aa      	lsls	r2, r5, #30
 8004832:	4601      	mov	r1, r0
 8004834:	d522      	bpl.n	800487c <_Findx1+0x64>
 8004836:	ac02      	add	r4, sp, #8
 8004838:	b127      	cbz	r7, 8004844 <_Findx1+0x2c>
 800483a:	4620      	mov	r0, r4
 800483c:	463a      	mov	r2, r7
 800483e:	f002 fc19 	bl	8007074 <GUI__IntersectRects>
 8004842:	e002      	b.n	800484a <_Findx1+0x32>
 8004844:	c803      	ldmia	r0, {r0, r1}
 8004846:	e884 0003 	stmia.w	r4, {r0, r1}
 800484a:	4630      	mov	r0, r6
 800484c:	4621      	mov	r1, r4
 800484e:	f002 fe4e 	bl	80074ee <GUI_RectsIntersect>
 8004852:	b198      	cbz	r0, 800487c <_Findx1+0x64>
 8004854:	07eb      	lsls	r3, r5, #31
 8004856:	d404      	bmi.n	8004862 <_Findx1+0x4a>
 8004858:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 800485c:	3b01      	subs	r3, #1
 800485e:	80b3      	strh	r3, [r6, #4]
 8004860:	e00c      	b.n	800487c <_Findx1+0x64>
 8004862:	9b01      	ldr	r3, [sp, #4]
 8004864:	69dd      	ldr	r5, [r3, #28]
 8004866:	b14d      	cbz	r5, 800487c <_Findx1+0x64>
 8004868:	4628      	mov	r0, r5
 800486a:	4631      	mov	r1, r6
 800486c:	4622      	mov	r2, r4
 800486e:	f7ff ffd3 	bl	8004818 <_Findx1>
 8004872:	4628      	mov	r0, r5
 8004874:	f003 fce6 	bl	8008244 <GUI_ALLOC_h2p>
 8004878:	6a05      	ldr	r5, [r0, #32]
 800487a:	e7f4      	b.n	8004866 <_Findx1+0x4e>
 800487c:	a804      	add	r0, sp, #16
 800487e:	f850 3d0c 	ldr.w	r3, [r0, #-12]!
 8004882:	6a1c      	ldr	r4, [r3, #32]
 8004884:	f003 fcf6 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004888:	e7cb      	b.n	8004822 <_Findx1+0xa>
 800488a:	b005      	add	sp, #20
 800488c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08004890 <WM__ClipAtParentBorders>:
 8004890:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8004892:	4607      	mov	r7, r0
 8004894:	460d      	mov	r5, r1
 8004896:	4628      	mov	r0, r5
 8004898:	f003 fcde 	bl	8008258 <GUI_ALLOC_LockH>
 800489c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800489e:	ac02      	add	r4, sp, #8
 80048a0:	f013 0602 	ands.w	r6, r3, #2
 80048a4:	4601      	mov	r1, r0
 80048a6:	f844 0d04 	str.w	r0, [r4, #-4]!
 80048aa:	d104      	bne.n	80048b6 <WM__ClipAtParentBorders+0x26>
 80048ac:	4620      	mov	r0, r4
 80048ae:	f003 fce1 	bl	8008274 <GUI_ALLOC_UnlockH>
 80048b2:	4630      	mov	r0, r6
 80048b4:	e016      	b.n	80048e4 <WM__ClipAtParentBorders+0x54>
 80048b6:	4638      	mov	r0, r7
 80048b8:	f002 fc0e 	bl	80070d8 <GUI__IntersectRect>
 80048bc:	9b01      	ldr	r3, [sp, #4]
 80048be:	699e      	ldr	r6, [r3, #24]
 80048c0:	4620      	mov	r0, r4
 80048c2:	b956      	cbnz	r6, 80048da <WM__ClipAtParentBorders+0x4a>
 80048c4:	f003 fcd6 	bl	8008274 <GUI_ALLOC_UnlockH>
 80048c8:	4b07      	ldr	r3, [pc, #28]	; (80048e8 <WM__ClipAtParentBorders+0x58>)
 80048ca:	681a      	ldr	r2, [r3, #0]
 80048cc:	4295      	cmp	r5, r2
 80048ce:	d008      	beq.n	80048e2 <WM__ClipAtParentBorders+0x52>
 80048d0:	6858      	ldr	r0, [r3, #4]
 80048d2:	1a2b      	subs	r3, r5, r0
 80048d4:	4258      	negs	r0, r3
 80048d6:	4158      	adcs	r0, r3
 80048d8:	e004      	b.n	80048e4 <WM__ClipAtParentBorders+0x54>
 80048da:	f003 fccb 	bl	8008274 <GUI_ALLOC_UnlockH>
 80048de:	4635      	mov	r5, r6
 80048e0:	e7d9      	b.n	8004896 <WM__ClipAtParentBorders+0x6>
 80048e2:	2001      	movs	r0, #1
 80048e4:	b003      	add	sp, #12
 80048e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80048e8:	20022290 	.word	0x20022290

080048ec <WM__InsertWindowIntoList>:
 80048ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80048ee:	4604      	mov	r4, r0
 80048f0:	b085      	sub	sp, #20
 80048f2:	460d      	mov	r5, r1
 80048f4:	2900      	cmp	r1, #0
 80048f6:	d049      	beq.n	800498c <WM__InsertWindowIntoList+0xa0>
 80048f8:	f003 fcae 	bl	8008258 <GUI_ALLOC_LockH>
 80048fc:	2300      	movs	r3, #0
 80048fe:	6203      	str	r3, [r0, #32]
 8004900:	6185      	str	r5, [r0, #24]
 8004902:	9001      	str	r0, [sp, #4]
 8004904:	4628      	mov	r0, r5
 8004906:	f003 fca7 	bl	8008258 <GUI_ALLOC_LockH>
 800490a:	9b01      	ldr	r3, [sp, #4]
 800490c:	69c5      	ldr	r5, [r0, #28]
 800490e:	9002      	str	r0, [sp, #8]
 8004910:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 8004912:	b92d      	cbnz	r5, 8004920 <WM__InsertWindowIntoList+0x34>
 8004914:	61c4      	str	r4, [r0, #28]
 8004916:	a801      	add	r0, sp, #4
 8004918:	f003 fcac 	bl	8008274 <GUI_ALLOC_UnlockH>
 800491c:	a802      	add	r0, sp, #8
 800491e:	e033      	b.n	8004988 <WM__InsertWindowIntoList+0x9c>
 8004920:	4628      	mov	r0, r5
 8004922:	f003 fc99 	bl	8008258 <GUI_ALLOC_LockH>
 8004926:	ae04      	add	r6, sp, #16
 8004928:	f007 0708 	and.w	r7, r7, #8
 800492c:	f846 0d04 	str.w	r0, [r6, #-4]!
 8004930:	b977      	cbnz	r7, 8004950 <WM__InsertWindowIntoList+0x64>
 8004932:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004934:	071a      	lsls	r2, r3, #28
 8004936:	d50b      	bpl.n	8004950 <WM__InsertWindowIntoList+0x64>
 8004938:	9b01      	ldr	r3, [sp, #4]
 800493a:	621d      	str	r5, [r3, #32]
 800493c:	9b02      	ldr	r3, [sp, #8]
 800493e:	a801      	add	r0, sp, #4
 8004940:	61dc      	str	r4, [r3, #28]
 8004942:	f003 fc97 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004946:	a802      	add	r0, sp, #8
 8004948:	f003 fc94 	bl	8008274 <GUI_ALLOC_UnlockH>
 800494c:	4630      	mov	r0, r6
 800494e:	e01b      	b.n	8004988 <WM__InsertWindowIntoList+0x9c>
 8004950:	a802      	add	r0, sp, #8
 8004952:	f003 fc8f 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004956:	4630      	mov	r0, r6
 8004958:	f003 fc8c 	bl	8008274 <GUI_ALLOC_UnlockH>
 800495c:	4628      	mov	r0, r5
 800495e:	f003 fc71 	bl	8008244 <GUI_ALLOC_h2p>
 8004962:	9003      	str	r0, [sp, #12]
 8004964:	9b03      	ldr	r3, [sp, #12]
 8004966:	6a1d      	ldr	r5, [r3, #32]
 8004968:	b90d      	cbnz	r5, 800496e <WM__InsertWindowIntoList+0x82>
 800496a:	621c      	str	r4, [r3, #32]
 800496c:	e00b      	b.n	8004986 <WM__InsertWindowIntoList+0x9a>
 800496e:	4628      	mov	r0, r5
 8004970:	f003 fc68 	bl	8008244 <GUI_ALLOC_h2p>
 8004974:	2f00      	cmp	r7, #0
 8004976:	d1f4      	bne.n	8004962 <WM__InsertWindowIntoList+0x76>
 8004978:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800497a:	071b      	lsls	r3, r3, #28
 800497c:	d5f1      	bpl.n	8004962 <WM__InsertWindowIntoList+0x76>
 800497e:	9b03      	ldr	r3, [sp, #12]
 8004980:	621c      	str	r4, [r3, #32]
 8004982:	9b01      	ldr	r3, [sp, #4]
 8004984:	621d      	str	r5, [r3, #32]
 8004986:	a801      	add	r0, sp, #4
 8004988:	f003 fc74 	bl	8008274 <GUI_ALLOC_UnlockH>
 800498c:	b005      	add	sp, #20
 800498e:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004990 <WM__Client2Screen>:
 8004990:	4603      	mov	r3, r0
 8004992:	4608      	mov	r0, r1
 8004994:	f9b3 2002 	ldrsh.w	r2, [r3, #2]
 8004998:	f9b3 1000 	ldrsh.w	r1, [r3]
 800499c:	f002 bdcc 	b.w	8007538 <GUI_MoveRect>

080049a0 <_SetClipRectUserIntersect>:
 80049a0:	4b11      	ldr	r3, [pc, #68]	; (80049e8 <_SetClipRectUserIntersect+0x48>)
 80049a2:	b530      	push	{r4, r5, lr}
 80049a4:	681c      	ldr	r4, [r3, #0]
 80049a6:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80049a8:	b085      	sub	sp, #20
 80049aa:	4605      	mov	r5, r0
 80049ac:	b1ba      	cbz	r2, 80049de <_SetClipRectUserIntersect+0x3e>
 80049ae:	6810      	ldr	r0, [r2, #0]
 80049b0:	6851      	ldr	r1, [r2, #4]
 80049b2:	ab02      	add	r3, sp, #8
 80049b4:	c303      	stmia	r3!, {r0, r1}
 80049b6:	4b0d      	ldr	r3, [pc, #52]	; (80049ec <_SetClipRectUserIntersect+0x4c>)
 80049b8:	6818      	ldr	r0, [r3, #0]
 80049ba:	b900      	cbnz	r0, 80049be <_SetClipRectUserIntersect+0x1e>
 80049bc:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 80049be:	f003 fc4b 	bl	8008258 <GUI_ALLOC_LockH>
 80049c2:	ac04      	add	r4, sp, #16
 80049c4:	a902      	add	r1, sp, #8
 80049c6:	f844 0d0c 	str.w	r0, [r4, #-12]!
 80049ca:	f7ff ffe1 	bl	8004990 <WM__Client2Screen>
 80049ce:	4620      	mov	r0, r4
 80049d0:	f003 fc50 	bl	8008274 <GUI_ALLOC_UnlockH>
 80049d4:	a802      	add	r0, sp, #8
 80049d6:	4629      	mov	r1, r5
 80049d8:	f002 fb7e 	bl	80070d8 <GUI__IntersectRect>
 80049dc:	a802      	add	r0, sp, #8
 80049de:	f001 ff25 	bl	800682c <LCD_SetClipRectEx>
 80049e2:	b005      	add	sp, #20
 80049e4:	bd30      	pop	{r4, r5, pc}
 80049e6:	bf00      	nop
 80049e8:	20000060 	.word	0x20000060
 80049ec:	2002228c 	.word	0x2002228c

080049f0 <WM__ActivateClipRect>:
 80049f0:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 80049f2:	4b0e      	ldr	r3, [pc, #56]	; (8004a2c <WM__ActivateClipRect+0x3c>)
 80049f4:	681b      	ldr	r3, [r3, #0]
 80049f6:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 80049fa:	b10a      	cbz	r2, 8004a00 <WM__ActivateClipRect+0x10>
 80049fc:	480c      	ldr	r0, [pc, #48]	; (8004a30 <WM__ActivateClipRect+0x40>)
 80049fe:	e011      	b.n	8004a24 <WM__ActivateClipRect+0x34>
 8004a00:	6c98      	ldr	r0, [r3, #72]	; 0x48
 8004a02:	f003 fc29 	bl	8008258 <GUI_ALLOC_LockH>
 8004a06:	9001      	str	r0, [sp, #4]
 8004a08:	c803      	ldmia	r0, {r0, r1}
 8004a0a:	ac02      	add	r4, sp, #8
 8004a0c:	e884 0003 	stmia.w	r4, {r0, r1}
 8004a10:	a801      	add	r0, sp, #4
 8004a12:	f003 fc2f 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004a16:	4b07      	ldr	r3, [pc, #28]	; (8004a34 <WM__ActivateClipRect+0x44>)
 8004a18:	6819      	ldr	r1, [r3, #0]
 8004a1a:	b111      	cbz	r1, 8004a22 <WM__ActivateClipRect+0x32>
 8004a1c:	4620      	mov	r0, r4
 8004a1e:	f7ff ff37 	bl	8004890 <WM__ClipAtParentBorders>
 8004a22:	4620      	mov	r0, r4
 8004a24:	f7ff ffbc 	bl	80049a0 <_SetClipRectUserIntersect>
 8004a28:	b004      	add	sp, #16
 8004a2a:	bd10      	pop	{r4, pc}
 8004a2c:	20000060 	.word	0x20000060
 8004a30:	20001fa0 	.word	0x20001fa0
 8004a34:	2002228c 	.word	0x2002228c

08004a38 <WM__InvalidateDrawAndDescs>:
 8004a38:	b513      	push	{r0, r1, r4, lr}
 8004a3a:	4604      	mov	r4, r0
 8004a3c:	b300      	cbz	r0, 8004a80 <WM__InvalidateDrawAndDescs+0x48>
 8004a3e:	f003 fc0b 	bl	8008258 <GUI_ALLOC_LockH>
 8004a42:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8004a44:	9001      	str	r0, [sp, #4]
 8004a46:	0793      	lsls	r3, r2, #30
 8004a48:	d517      	bpl.n	8004a7a <WM__InvalidateDrawAndDescs+0x42>
 8004a4a:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8004a4c:	b140      	cbz	r0, 8004a60 <WM__InvalidateDrawAndDescs+0x28>
 8004a4e:	4b0d      	ldr	r3, [pc, #52]	; (8004a84 <WM__InvalidateDrawAndDescs+0x4c>)
 8004a50:	681b      	ldr	r3, [r3, #0]
 8004a52:	42a3      	cmp	r3, r4
 8004a54:	d004      	beq.n	8004a60 <WM__InvalidateDrawAndDescs+0x28>
 8004a56:	f001 f94f 	bl	8005cf8 <GUI_MEMDEV_Delete>
 8004a5a:	9b01      	ldr	r3, [sp, #4]
 8004a5c:	2200      	movs	r2, #0
 8004a5e:	625a      	str	r2, [r3, #36]	; 0x24
 8004a60:	4620      	mov	r0, r4
 8004a62:	f003 febd 	bl	80087e0 <WM_GetFirstChild>
 8004a66:	4604      	mov	r4, r0
 8004a68:	b13c      	cbz	r4, 8004a7a <WM__InvalidateDrawAndDescs+0x42>
 8004a6a:	4620      	mov	r0, r4
 8004a6c:	f7ff ffe4 	bl	8004a38 <WM__InvalidateDrawAndDescs>
 8004a70:	4620      	mov	r0, r4
 8004a72:	f003 fbe7 	bl	8008244 <GUI_ALLOC_h2p>
 8004a76:	6a04      	ldr	r4, [r0, #32]
 8004a78:	e7f6      	b.n	8004a68 <WM__InvalidateDrawAndDescs+0x30>
 8004a7a:	a801      	add	r0, sp, #4
 8004a7c:	f003 fbfa 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004a80:	b002      	add	sp, #8
 8004a82:	bd10      	pop	{r4, pc}
 8004a84:	200222d4 	.word	0x200222d4

08004a88 <WM__RectIsNZ>:
 8004a88:	f9b0 2000 	ldrsh.w	r2, [r0]
 8004a8c:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
 8004a90:	429a      	cmp	r2, r3
 8004a92:	dc08      	bgt.n	8004aa6 <WM__RectIsNZ+0x1e>
 8004a94:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
 8004a98:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
 8004a9c:	429a      	cmp	r2, r3
 8004a9e:	bfcc      	ite	gt
 8004aa0:	2000      	movgt	r0, #0
 8004aa2:	2001      	movle	r0, #1
 8004aa4:	4770      	bx	lr
 8004aa6:	2000      	movs	r0, #0
 8004aa8:	4770      	bx	lr
	...

08004aac <_Invalidate1Abs>:
 8004aac:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004aae:	b085      	sub	sp, #20
 8004ab0:	4606      	mov	r6, r0
 8004ab2:	460d      	mov	r5, r1
 8004ab4:	4617      	mov	r7, r2
 8004ab6:	f003 fbc5 	bl	8008244 <GUI_ALLOC_h2p>
 8004aba:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8004abc:	9001      	str	r0, [sp, #4]
 8004abe:	07a3      	lsls	r3, r4, #30
 8004ac0:	d534      	bpl.n	8004b2c <_Invalidate1Abs+0x80>
 8004ac2:	4628      	mov	r0, r5
 8004ac4:	f7ff ffe0 	bl	8004a88 <WM__RectIsNZ>
 8004ac8:	2800      	cmp	r0, #0
 8004aca:	d02f      	beq.n	8004b2c <_Invalidate1Abs+0x80>
 8004acc:	f640 0301 	movw	r3, #2049	; 0x801
 8004ad0:	4023      	ands	r3, r4
 8004ad2:	2b01      	cmp	r3, #1
 8004ad4:	d02a      	beq.n	8004b2c <_Invalidate1Abs+0x80>
 8004ad6:	4630      	mov	r0, r6
 8004ad8:	f003 fbbe 	bl	8008258 <GUI_ALLOC_LockH>
 8004adc:	ac02      	add	r4, sp, #8
 8004ade:	4602      	mov	r2, r0
 8004ae0:	9001      	str	r0, [sp, #4]
 8004ae2:	4629      	mov	r1, r5
 8004ae4:	4620      	mov	r0, r4
 8004ae6:	f002 fac5 	bl	8007074 <GUI__IntersectRects>
 8004aea:	4620      	mov	r0, r4
 8004aec:	f7ff ffcc 	bl	8004a88 <WM__RectIsNZ>
 8004af0:	b1c8      	cbz	r0, 8004b26 <_Invalidate1Abs+0x7a>
 8004af2:	9b01      	ldr	r3, [sp, #4]
 8004af4:	6a9e      	ldr	r6, [r3, #40]	; 0x28
 8004af6:	f244 0120 	movw	r1, #16416	; 0x4020
 8004afa:	4031      	ands	r1, r6
 8004afc:	f103 0508 	add.w	r5, r3, #8
 8004b00:	b129      	cbz	r1, 8004b0e <_Invalidate1Abs+0x62>
 8004b02:	4628      	mov	r0, r5
 8004b04:	4629      	mov	r1, r5
 8004b06:	4622      	mov	r2, r4
 8004b08:	f002 fd26 	bl	8007558 <GUI_MergeRect>
 8004b0c:	e00b      	b.n	8004b26 <_Invalidate1Abs+0x7a>
 8004b0e:	e894 0003 	ldmia.w	r4, {r0, r1}
 8004b12:	433e      	orrs	r6, r7
 8004b14:	e885 0003 	stmia.w	r5, {r0, r1}
 8004b18:	629e      	str	r6, [r3, #40]	; 0x28
 8004b1a:	4b05      	ldr	r3, [pc, #20]	; (8004b30 <_Invalidate1Abs+0x84>)
 8004b1c:	881a      	ldrh	r2, [r3, #0]
 8004b1e:	3201      	adds	r2, #1
 8004b20:	801a      	strh	r2, [r3, #0]
 8004b22:	f002 fc9f 	bl	8007464 <GUI_SignalEvent>
 8004b26:	a801      	add	r0, sp, #4
 8004b28:	f003 fba4 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004b2c:	b005      	add	sp, #20
 8004b2e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004b30:	200222a8 	.word	0x200222a8

08004b34 <WM__Invalidate1Abs>:
 8004b34:	2220      	movs	r2, #32
 8004b36:	f7ff bfb9 	b.w	8004aac <_Invalidate1Abs>

08004b3a <WM_InvalidateWindowAndDescsEx>:
 8004b3a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004b3c:	460f      	mov	r7, r1
 8004b3e:	b085      	sub	sp, #20
 8004b40:	4615      	mov	r5, r2
 8004b42:	4606      	mov	r6, r0
 8004b44:	b348      	cbz	r0, 8004b9a <WM_InvalidateWindowAndDescsEx+0x60>
 8004b46:	f003 fb87 	bl	8008258 <GUI_ALLOC_LockH>
 8004b4a:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004b4c:	ac04      	add	r4, sp, #16
 8004b4e:	079b      	lsls	r3, r3, #30
 8004b50:	4602      	mov	r2, r0
 8004b52:	f844 0d0c 	str.w	r0, [r4, #-12]!
 8004b56:	d403      	bmi.n	8004b60 <WM_InvalidateWindowAndDescsEx+0x26>
 8004b58:	4620      	mov	r0, r4
 8004b5a:	f003 fb8b 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004b5e:	e01c      	b.n	8004b9a <WM_InvalidateWindowAndDescsEx+0x60>
 8004b60:	a802      	add	r0, sp, #8
 8004b62:	4639      	mov	r1, r7
 8004b64:	f002 fa86 	bl	8007074 <GUI__IntersectRects>
 8004b68:	2800      	cmp	r0, #0
 8004b6a:	d0f5      	beq.n	8004b58 <WM_InvalidateWindowAndDescsEx+0x1e>
 8004b6c:	4620      	mov	r0, r4
 8004b6e:	f003 fb81 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004b72:	4630      	mov	r0, r6
 8004b74:	a902      	add	r1, sp, #8
 8004b76:	462a      	mov	r2, r5
 8004b78:	f7ff ff98 	bl	8004aac <_Invalidate1Abs>
 8004b7c:	4630      	mov	r0, r6
 8004b7e:	f003 fe2f 	bl	80087e0 <WM_GetFirstChild>
 8004b82:	4604      	mov	r4, r0
 8004b84:	b14c      	cbz	r4, 8004b9a <WM_InvalidateWindowAndDescsEx+0x60>
 8004b86:	4620      	mov	r0, r4
 8004b88:	a902      	add	r1, sp, #8
 8004b8a:	462a      	mov	r2, r5
 8004b8c:	f7ff ffd5 	bl	8004b3a <WM_InvalidateWindowAndDescsEx>
 8004b90:	4620      	mov	r0, r4
 8004b92:	f003 fb57 	bl	8008244 <GUI_ALLOC_h2p>
 8004b96:	6a04      	ldr	r4, [r0, #32]
 8004b98:	e7f4      	b.n	8004b84 <WM_InvalidateWindowAndDescsEx+0x4a>
 8004b9a:	b005      	add	sp, #20
 8004b9c:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004b9e <WM__InvalidateRect>:
 8004b9e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8004ba2:	4680      	mov	r8, r0
 8004ba4:	4617      	mov	r7, r2
 8004ba6:	461d      	mov	r5, r3
 8004ba8:	460c      	mov	r4, r1
 8004baa:	2900      	cmp	r1, #0
 8004bac:	d030      	beq.n	8004c10 <WM__InvalidateRect+0x72>
 8004bae:	4608      	mov	r0, r1
 8004bb0:	f003 fb52 	bl	8008258 <GUI_ALLOC_LockH>
 8004bb4:	6a86      	ldr	r6, [r0, #40]	; 0x28
 8004bb6:	9001      	str	r0, [sp, #4]
 8004bb8:	07b3      	lsls	r3, r6, #30
 8004bba:	4602      	mov	r2, r0
 8004bbc:	d525      	bpl.n	8004c0a <WM__InvalidateRect+0x6c>
 8004bbe:	a802      	add	r0, sp, #8
 8004bc0:	4641      	mov	r1, r8
 8004bc2:	f002 fa57 	bl	8007074 <GUI__IntersectRects>
 8004bc6:	b300      	cbz	r0, 8004c0a <WM__InvalidateRect+0x6c>
 8004bc8:	f640 0301 	movw	r3, #2049	; 0x801
 8004bcc:	4033      	ands	r3, r6
 8004bce:	2b01      	cmp	r3, #1
 8004bd0:	d107      	bne.n	8004be2 <WM__InvalidateRect+0x44>
 8004bd2:	9b01      	ldr	r3, [sp, #4]
 8004bd4:	a802      	add	r0, sp, #8
 8004bd6:	6999      	ldr	r1, [r3, #24]
 8004bd8:	6a1a      	ldr	r2, [r3, #32]
 8004bda:	462b      	mov	r3, r5
 8004bdc:	f7ff ffdf 	bl	8004b9e <WM__InvalidateRect>
 8004be0:	e004      	b.n	8004bec <WM__InvalidateRect+0x4e>
 8004be2:	4620      	mov	r0, r4
 8004be4:	a902      	add	r1, sp, #8
 8004be6:	462a      	mov	r2, r5
 8004be8:	f7ff ff60 	bl	8004aac <_Invalidate1Abs>
 8004bec:	9b01      	ldr	r3, [sp, #4]
 8004bee:	69dc      	ldr	r4, [r3, #28]
 8004bf0:	b15c      	cbz	r4, 8004c0a <WM__InvalidateRect+0x6c>
 8004bf2:	42bc      	cmp	r4, r7
 8004bf4:	d009      	beq.n	8004c0a <WM__InvalidateRect+0x6c>
 8004bf6:	4620      	mov	r0, r4
 8004bf8:	a902      	add	r1, sp, #8
 8004bfa:	462a      	mov	r2, r5
 8004bfc:	f7ff ff9d 	bl	8004b3a <WM_InvalidateWindowAndDescsEx>
 8004c00:	4620      	mov	r0, r4
 8004c02:	f003 fb1f 	bl	8008244 <GUI_ALLOC_h2p>
 8004c06:	6a04      	ldr	r4, [r0, #32]
 8004c08:	e7f2      	b.n	8004bf0 <WM__InvalidateRect+0x52>
 8004c0a:	a801      	add	r0, sp, #4
 8004c0c:	f003 fb32 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004c10:	b004      	add	sp, #16
 8004c12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004c16 <WM__InvalidateRectEx>:
 8004c16:	2320      	movs	r3, #32
 8004c18:	f7ff bfc1 	b.w	8004b9e <WM__InvalidateRect>

08004c1c <WM__SendMsgNoData>:
 8004c1c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8004c1e:	ab04      	add	r3, sp, #16
 8004c20:	9001      	str	r0, [sp, #4]
 8004c22:	f843 1d10 	str.w	r1, [r3, #-16]!
 8004c26:	4669      	mov	r1, sp
 8004c28:	f003 fda6 	bl	8008778 <WM__SendMessage>
 8004c2c:	b005      	add	sp, #20
 8004c2e:	f85d fb04 	ldr.w	pc, [sp], #4

08004c32 <WM__GetClientRectWin>:
 8004c32:	2300      	movs	r3, #0
 8004c34:	800b      	strh	r3, [r1, #0]
 8004c36:	8882      	ldrh	r2, [r0, #4]
 8004c38:	804b      	strh	r3, [r1, #2]
 8004c3a:	8803      	ldrh	r3, [r0, #0]
 8004c3c:	1ad3      	subs	r3, r2, r3
 8004c3e:	808b      	strh	r3, [r1, #4]
 8004c40:	88c2      	ldrh	r2, [r0, #6]
 8004c42:	8843      	ldrh	r3, [r0, #2]
 8004c44:	1ad3      	subs	r3, r2, r3
 8004c46:	80cb      	strh	r3, [r1, #6]
 8004c48:	4770      	bx	lr

08004c4a <WM_InvalidateRect>:
 8004c4a:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004c4c:	460f      	mov	r7, r1
 8004c4e:	b087      	sub	sp, #28
 8004c50:	4605      	mov	r5, r0
 8004c52:	2800      	cmp	r0, #0
 8004c54:	d033      	beq.n	8004cbe <WM_InvalidateRect+0x74>
 8004c56:	f003 faff 	bl	8008258 <GUI_ALLOC_LockH>
 8004c5a:	6a86      	ldr	r6, [r0, #40]	; 0x28
 8004c5c:	9001      	str	r0, [sp, #4]
 8004c5e:	07b2      	lsls	r2, r6, #30
 8004c60:	d52a      	bpl.n	8004cb8 <WM_InvalidateRect+0x6e>
 8004c62:	c803      	ldmia	r0, {r0, r1}
 8004c64:	ac04      	add	r4, sp, #16
 8004c66:	03f3      	lsls	r3, r6, #15
 8004c68:	e884 0003 	stmia.w	r4, {r0, r1}
 8004c6c:	d502      	bpl.n	8004c74 <WM_InvalidateRect+0x2a>
 8004c6e:	4628      	mov	r0, r5
 8004c70:	f7ff fee2 	bl	8004a38 <WM__InvalidateDrawAndDescs>
 8004c74:	b15f      	cbz	r7, 8004c8e <WM_InvalidateRect+0x44>
 8004c76:	6838      	ldr	r0, [r7, #0]
 8004c78:	6879      	ldr	r1, [r7, #4]
 8004c7a:	ab02      	add	r3, sp, #8
 8004c7c:	c303      	stmia	r3!, {r0, r1}
 8004c7e:	9801      	ldr	r0, [sp, #4]
 8004c80:	a902      	add	r1, sp, #8
 8004c82:	f7ff fe85 	bl	8004990 <WM__Client2Screen>
 8004c86:	4620      	mov	r0, r4
 8004c88:	a902      	add	r1, sp, #8
 8004c8a:	f002 fa25 	bl	80070d8 <GUI__IntersectRect>
 8004c8e:	4620      	mov	r0, r4
 8004c90:	4629      	mov	r1, r5
 8004c92:	f7ff fdfd 	bl	8004890 <WM__ClipAtParentBorders>
 8004c96:	b178      	cbz	r0, 8004cb8 <WM_InvalidateRect+0x6e>
 8004c98:	f640 0301 	movw	r3, #2049	; 0x801
 8004c9c:	4033      	ands	r3, r6
 8004c9e:	2b01      	cmp	r3, #1
 8004ca0:	d106      	bne.n	8004cb0 <WM_InvalidateRect+0x66>
 8004ca2:	9b01      	ldr	r3, [sp, #4]
 8004ca4:	4620      	mov	r0, r4
 8004ca6:	6999      	ldr	r1, [r3, #24]
 8004ca8:	6a1a      	ldr	r2, [r3, #32]
 8004caa:	f7ff ffb4 	bl	8004c16 <WM__InvalidateRectEx>
 8004cae:	e003      	b.n	8004cb8 <WM_InvalidateRect+0x6e>
 8004cb0:	4628      	mov	r0, r5
 8004cb2:	4621      	mov	r1, r4
 8004cb4:	f7ff ff3e 	bl	8004b34 <WM__Invalidate1Abs>
 8004cb8:	a801      	add	r0, sp, #4
 8004cba:	f003 fadb 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004cbe:	b007      	add	sp, #28
 8004cc0:	bdf0      	pop	{r4, r5, r6, r7, pc}

08004cc2 <WM_InvalidateWindow>:
 8004cc2:	2100      	movs	r1, #0
 8004cc4:	f7ff bfc1 	b.w	8004c4a <WM_InvalidateRect>

08004cc8 <WM__GetTopLevelLayer>:
 8004cc8:	b510      	push	{r4, lr}
 8004cca:	4604      	mov	r4, r0
 8004ccc:	f003 faba 	bl	8008244 <GUI_ALLOC_h2p>
 8004cd0:	6980      	ldr	r0, [r0, #24]
 8004cd2:	2800      	cmp	r0, #0
 8004cd4:	d1f9      	bne.n	8004cca <WM__GetTopLevelLayer+0x2>
 8004cd6:	4b05      	ldr	r3, [pc, #20]	; (8004cec <WM__GetTopLevelLayer+0x24>)
 8004cd8:	681a      	ldr	r2, [r3, #0]
 8004cda:	4294      	cmp	r4, r2
 8004cdc:	d005      	beq.n	8004cea <WM__GetTopLevelLayer+0x22>
 8004cde:	6858      	ldr	r0, [r3, #4]
 8004ce0:	4284      	cmp	r4, r0
 8004ce2:	bf14      	ite	ne
 8004ce4:	f04f 30ff 	movne.w	r0, #4294967295
 8004ce8:	2001      	moveq	r0, #1
 8004cea:	bd10      	pop	{r4, pc}
 8004cec:	20022290 	.word	0x20022290

08004cf0 <WM__SelectTopLevelLayer>:
 8004cf0:	b508      	push	{r3, lr}
 8004cf2:	f7ff ffe9 	bl	8004cc8 <WM__GetTopLevelLayer>
 8004cf6:	2800      	cmp	r0, #0
 8004cf8:	db03      	blt.n	8004d02 <WM__SelectTopLevelLayer+0x12>
 8004cfa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8004cfe:	f002 bbdb 	b.w	80074b8 <GUI_SelectLayer>
 8004d02:	bd08      	pop	{r3, pc}

08004d04 <WM_SelectWindow>:
 8004d04:	4a0d      	ldr	r2, [pc, #52]	; (8004d3c <WM_SelectWindow+0x38>)
 8004d06:	6813      	ldr	r3, [r2, #0]
 8004d08:	b570      	push	{r4, r5, r6, lr}
 8004d0a:	6c9d      	ldr	r5, [r3, #72]	; 0x48
 8004d0c:	4604      	mov	r4, r0
 8004d0e:	4616      	mov	r6, r2
 8004d10:	b908      	cbnz	r0, 8004d16 <WM_SelectWindow+0x12>
 8004d12:	4a0b      	ldr	r2, [pc, #44]	; (8004d40 <WM_SelectWindow+0x3c>)
 8004d14:	6814      	ldr	r4, [r2, #0]
 8004d16:	649c      	str	r4, [r3, #72]	; 0x48
 8004d18:	4620      	mov	r0, r4
 8004d1a:	f7ff ffe9 	bl	8004cf0 <WM__SelectTopLevelLayer>
 8004d1e:	f002 f849 	bl	8006db4 <LCD_SetClipRectMax>
 8004d22:	4620      	mov	r0, r4
 8004d24:	f003 fa8e 	bl	8008244 <GUI_ALLOC_h2p>
 8004d28:	6833      	ldr	r3, [r6, #0]
 8004d2a:	f9b0 1000 	ldrsh.w	r1, [r0]
 8004d2e:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
 8004d32:	64d9      	str	r1, [r3, #76]	; 0x4c
 8004d34:	651a      	str	r2, [r3, #80]	; 0x50
 8004d36:	4628      	mov	r0, r5
 8004d38:	bd70      	pop	{r4, r5, r6, pc}
 8004d3a:	bf00      	nop
 8004d3c:	20000060 	.word	0x20000060
 8004d40:	200222ac 	.word	0x200222ac

08004d44 <WM_CreateWindowAsChild>:
 8004d44:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004d48:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 8004d4a:	469b      	mov	fp, r3
 8004d4c:	4b4b      	ldr	r3, [pc, #300]	; (8004e7c <WM_CreateWindowAsChild+0x138>)
 8004d4e:	4607      	mov	r7, r0
 8004d50:	4688      	mov	r8, r1
 8004d52:	4692      	mov	sl, r2
 8004d54:	681e      	ldr	r6, [r3, #0]
 8004d56:	bb65      	cbnz	r5, 8004db2 <WM_CreateWindowAsChild+0x6e>
 8004d58:	4b49      	ldr	r3, [pc, #292]	; (8004e80 <WM_CreateWindowAsChild+0x13c>)
 8004d5a:	881b      	ldrh	r3, [r3, #0]
 8004d5c:	b363      	cbz	r3, 8004db8 <WM_CreateWindowAsChild+0x74>
 8004d5e:	4b49      	ldr	r3, [pc, #292]	; (8004e84 <WM_CreateWindowAsChild+0x140>)
 8004d60:	681b      	ldr	r3, [r3, #0]
 8004d62:	7c5a      	ldrb	r2, [r3, #17]
 8004d64:	4b48      	ldr	r3, [pc, #288]	; (8004e88 <WM_CreateWindowAsChild+0x144>)
 8004d66:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8004d6a:	1c5a      	adds	r2, r3, #1
 8004d6c:	d024      	beq.n	8004db8 <WM_CreateWindowAsChild+0x74>
 8004d6e:	b31b      	cbz	r3, 8004db8 <WM_CreateWindowAsChild+0x74>
 8004d70:	461d      	mov	r5, r3
 8004d72:	4628      	mov	r0, r5
 8004d74:	f003 fa70 	bl	8008258 <GUI_ALLOC_LockH>
 8004d78:	f9b0 2000 	ldrsh.w	r2, [r0]
 8004d7c:	f9b0 3002 	ldrsh.w	r3, [r0, #2]
 8004d80:	9001      	str	r0, [sp, #4]
 8004d82:	4417      	add	r7, r2
 8004d84:	4498      	add	r8, r3
 8004d86:	f1ba 0f00 	cmp.w	sl, #0
 8004d8a:	d105      	bne.n	8004d98 <WM_CreateWindowAsChild+0x54>
 8004d8c:	f9b0 a004 	ldrsh.w	sl, [r0, #4]
 8004d90:	ebc2 0a0a 	rsb	sl, r2, sl
 8004d94:	f10a 0a01 	add.w	sl, sl, #1
 8004d98:	f1bb 0f00 	cmp.w	fp, #0
 8004d9c:	d105      	bne.n	8004daa <WM_CreateWindowAsChild+0x66>
 8004d9e:	f9b0 b006 	ldrsh.w	fp, [r0, #6]
 8004da2:	ebc3 0b0b 	rsb	fp, r3, fp
 8004da6:	f10b 0b01 	add.w	fp, fp, #1
 8004daa:	a801      	add	r0, sp, #4
 8004dac:	f003 fa62 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004db0:	e002      	b.n	8004db8 <WM_CreateWindowAsChild+0x74>
 8004db2:	1c6b      	adds	r3, r5, #1
 8004db4:	d1dd      	bne.n	8004d72 <WM_CreateWindowAsChild+0x2e>
 8004db6:	2500      	movs	r5, #0
 8004db8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8004dba:	302c      	adds	r0, #44	; 0x2c
 8004dbc:	f003 fc68 	bl	8008690 <GUI_ALLOC_AllocZero>
 8004dc0:	4604      	mov	r4, r0
 8004dc2:	2800      	cmp	r0, #0
 8004dc4:	d056      	beq.n	8004e74 <WM_CreateWindowAsChild+0x130>
 8004dc6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8004dc8:	431e      	orrs	r6, r3
 8004dca:	4b2d      	ldr	r3, [pc, #180]	; (8004e80 <WM_CreateWindowAsChild+0x13c>)
 8004dcc:	881a      	ldrh	r2, [r3, #0]
 8004dce:	3201      	adds	r2, #1
 8004dd0:	801a      	strh	r2, [r3, #0]
 8004dd2:	f003 fa41 	bl	8008258 <GUI_ALLOC_LockH>
 8004dd6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8004dd8:	6103      	str	r3, [r0, #16]
 8004dda:	f10d 0908 	add.w	r9, sp, #8
 8004dde:	4b2b      	ldr	r3, [pc, #172]	; (8004e8c <WM_CreateWindowAsChild+0x148>)
 8004de0:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8004de2:	f849 0d08 	str.w	r0, [r9, #-8]!
 8004de6:	4033      	ands	r3, r6
 8004de8:	8007      	strh	r7, [r0, #0]
 8004dea:	f8a0 8002 	strh.w	r8, [r0, #2]
 8004dee:	4457      	add	r7, sl
 8004df0:	44d8      	add	r8, fp
 8004df2:	4313      	orrs	r3, r2
 8004df4:	3f01      	subs	r7, #1
 8004df6:	f108 38ff 	add.w	r8, r8, #4294967295
 8004dfa:	6283      	str	r3, [r0, #40]	; 0x28
 8004dfc:	8087      	strh	r7, [r0, #4]
 8004dfe:	f8a0 8006 	strh.w	r8, [r0, #6]
 8004e02:	4668      	mov	r0, sp
 8004e04:	f003 fa36 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004e08:	4b21      	ldr	r3, [pc, #132]	; (8004e90 <WM_CreateWindowAsChild+0x14c>)
 8004e0a:	6818      	ldr	r0, [r3, #0]
 8004e0c:	b148      	cbz	r0, 8004e22 <WM_CreateWindowAsChild+0xde>
 8004e0e:	f003 fa19 	bl	8008244 <GUI_ALLOC_h2p>
 8004e12:	4607      	mov	r7, r0
 8004e14:	4620      	mov	r0, r4
 8004e16:	f003 fa15 	bl	8008244 <GUI_ALLOC_h2p>
 8004e1a:	697b      	ldr	r3, [r7, #20]
 8004e1c:	6143      	str	r3, [r0, #20]
 8004e1e:	617c      	str	r4, [r7, #20]
 8004e20:	e000      	b.n	8004e24 <WM_CreateWindowAsChild+0xe0>
 8004e22:	601c      	str	r4, [r3, #0]
 8004e24:	4629      	mov	r1, r5
 8004e26:	4620      	mov	r0, r4
 8004e28:	f7ff fd60 	bl	80048ec <WM__InsertWindowIntoList>
 8004e2c:	06b5      	lsls	r5, r6, #26
 8004e2e:	d502      	bpl.n	8004e36 <WM_CreateWindowAsChild+0xf2>
 8004e30:	4620      	mov	r0, r4
 8004e32:	f7ff ff67 	bl	8004d04 <WM_SelectWindow>
 8004e36:	07f0      	lsls	r0, r6, #31
 8004e38:	d503      	bpl.n	8004e42 <WM_CreateWindowAsChild+0xfe>
 8004e3a:	4b16      	ldr	r3, [pc, #88]	; (8004e94 <WM_CreateWindowAsChild+0x150>)
 8004e3c:	681a      	ldr	r2, [r3, #0]
 8004e3e:	3201      	adds	r2, #1
 8004e40:	601a      	str	r2, [r3, #0]
 8004e42:	0671      	lsls	r1, r6, #25
 8004e44:	d502      	bpl.n	8004e4c <WM_CreateWindowAsChild+0x108>
 8004e46:	4620      	mov	r0, r4
 8004e48:	f003 fcf8 	bl	800883c <WM_BringToBottom>
 8004e4c:	07b2      	lsls	r2, r6, #30
 8004e4e:	d50d      	bpl.n	8004e6c <WM_CreateWindowAsChild+0x128>
 8004e50:	4620      	mov	r0, r4
 8004e52:	f003 fa01 	bl	8008258 <GUI_ALLOC_LockH>
 8004e56:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8004e58:	9000      	str	r0, [sp, #0]
 8004e5a:	f043 0302 	orr.w	r3, r3, #2
 8004e5e:	6283      	str	r3, [r0, #40]	; 0x28
 8004e60:	4668      	mov	r0, sp
 8004e62:	f003 fa07 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004e66:	4620      	mov	r0, r4
 8004e68:	f7ff ff2b 	bl	8004cc2 <WM_InvalidateWindow>
 8004e6c:	4620      	mov	r0, r4
 8004e6e:	2101      	movs	r1, #1
 8004e70:	f7ff fed4 	bl	8004c1c <WM__SendMsgNoData>
 8004e74:	4620      	mov	r0, r4
 8004e76:	b003      	add	sp, #12
 8004e78:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004e7c:	200222b8 	.word	0x200222b8
 8004e80:	20022288 	.word	0x20022288
 8004e84:	20000060 	.word	0x20000060
 8004e88:	20022290 	.word	0x20022290
 8004e8c:	003f3f9f 	.word	0x003f3f9f
 8004e90:	200222ac 	.word	0x200222ac
 8004e94:	200222d8 	.word	0x200222d8

08004e98 <WM__GetNextIVR>:
 8004e98:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8004e9c:	4f5d      	ldr	r7, [pc, #372]	; (8005014 <WM__GetNextIVR+0x17c>)
 8004e9e:	683b      	ldr	r3, [r7, #0]
 8004ea0:	f893 0054 	ldrb.w	r0, [r3, #84]	; 0x54
 8004ea4:	2800      	cmp	r0, #0
 8004ea6:	f000 80b2 	beq.w	800500e <WM__GetNextIVR+0x176>
 8004eaa:	4b5b      	ldr	r3, [pc, #364]	; (8005018 <WM__GetNextIVR+0x180>)
 8004eac:	695a      	ldr	r2, [r3, #20]
 8004eae:	2a01      	cmp	r2, #1
 8004eb0:	461c      	mov	r4, r3
 8004eb2:	dd03      	ble.n	8004ebc <WM__GetNextIVR+0x24>
 8004eb4:	3a01      	subs	r2, #1
 8004eb6:	615a      	str	r2, [r3, #20]
 8004eb8:	2000      	movs	r0, #0
 8004eba:	e0a8      	b.n	800500e <WM__GetNextIVR+0x176>
 8004ebc:	f104 0608 	add.w	r6, r4, #8
 8004ec0:	691b      	ldr	r3, [r3, #16]
 8004ec2:	e896 0003 	ldmia.w	r6, {r0, r1}
 8004ec6:	3301      	adds	r3, #1
 8004ec8:	ad02      	add	r5, sp, #8
 8004eca:	6123      	str	r3, [r4, #16]
 8004ecc:	e885 0003 	stmia.w	r5, {r0, r1}
 8004ed0:	b923      	cbnz	r3, 8004edc <WM__GetNextIVR+0x44>
 8004ed2:	8823      	ldrh	r3, [r4, #0]
 8004ed4:	f8ad 3008 	strh.w	r3, [sp, #8]
 8004ed8:	8863      	ldrh	r3, [r4, #2]
 8004eda:	e011      	b.n	8004f00 <WM__GetNextIVR+0x68>
 8004edc:	89a3      	ldrh	r3, [r4, #12]
 8004ede:	8962      	ldrh	r2, [r4, #10]
 8004ee0:	f8ad 200a 	strh.w	r2, [sp, #10]
 8004ee4:	3301      	adds	r3, #1
 8004ee6:	b29b      	uxth	r3, r3
 8004ee8:	f9b4 2004 	ldrsh.w	r2, [r4, #4]
 8004eec:	f8ad 3008 	strh.w	r3, [sp, #8]
 8004ef0:	b21b      	sxth	r3, r3
 8004ef2:	429a      	cmp	r2, r3
 8004ef4:	da06      	bge.n	8004f04 <WM__GetNextIVR+0x6c>
 8004ef6:	8823      	ldrh	r3, [r4, #0]
 8004ef8:	f8ad 3008 	strh.w	r3, [sp, #8]
 8004efc:	89e3      	ldrh	r3, [r4, #14]
 8004efe:	3301      	adds	r3, #1
 8004f00:	f8ad 300a 	strh.w	r3, [sp, #10]
 8004f04:	f9bd 200a 	ldrsh.w	r2, [sp, #10]
 8004f08:	f9b4 3006 	ldrsh.w	r3, [r4, #6]
 8004f0c:	f8df 8108 	ldr.w	r8, [pc, #264]	; 8005018 <WM__GetNextIVR+0x180>
 8004f10:	429a      	cmp	r2, r3
 8004f12:	dd04      	ble.n	8004f1e <WM__GetNextIVR+0x86>
 8004f14:	6963      	ldr	r3, [r4, #20]
 8004f16:	3b01      	subs	r3, #1
 8004f18:	2000      	movs	r0, #0
 8004f1a:	6163      	str	r3, [r4, #20]
 8004f1c:	e077      	b.n	800500e <WM__GetNextIVR+0x176>
 8004f1e:	683b      	ldr	r3, [r7, #0]
 8004f20:	6c98      	ldr	r0, [r3, #72]	; 0x48
 8004f22:	f003 f999 	bl	8008258 <GUI_ALLOC_LockH>
 8004f26:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
 8004f2a:	f9b8 3000 	ldrsh.w	r3, [r8]
 8004f2e:	9001      	str	r0, [sp, #4]
 8004f30:	429a      	cmp	r2, r3
 8004f32:	d11c      	bne.n	8004f6e <WM__GetNextIVR+0xd6>
 8004f34:	f8b8 3006 	ldrh.w	r3, [r8, #6]
 8004f38:	f8ad 300e 	strh.w	r3, [sp, #14]
 8004f3c:	f8b8 3004 	ldrh.w	r3, [r8, #4]
 8004f40:	f8ad 300c 	strh.w	r3, [sp, #12]
 8004f44:	4b33      	ldr	r3, [pc, #204]	; (8005014 <WM__GetNextIVR+0x17c>)
 8004f46:	681b      	ldr	r3, [r3, #0]
 8004f48:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8004f4a:	b15a      	cbz	r2, 8004f64 <WM__GetNextIVR+0xcc>
 8004f4c:	4610      	mov	r0, r2
 8004f4e:	f003 f979 	bl	8008244 <GUI_ALLOC_h2p>
 8004f52:	4680      	mov	r8, r0
 8004f54:	2200      	movs	r2, #0
 8004f56:	6a00      	ldr	r0, [r0, #32]
 8004f58:	4629      	mov	r1, r5
 8004f5a:	f7ff fbc3 	bl	80046e4 <_Findy1>
 8004f5e:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8004f62:	e7f2      	b.n	8004f4a <WM__GetNextIVR+0xb2>
 8004f64:	9b01      	ldr	r3, [sp, #4]
 8004f66:	4629      	mov	r1, r5
 8004f68:	69d8      	ldr	r0, [r3, #28]
 8004f6a:	f7ff fbbb 	bl	80046e4 <_Findy1>
 8004f6e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
 8004f72:	f8ad 300c 	strh.w	r3, [sp, #12]
 8004f76:	683b      	ldr	r3, [r7, #0]
 8004f78:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8004f7a:	b16a      	cbz	r2, 8004f98 <WM__GetNextIVR+0x100>
 8004f7c:	4610      	mov	r0, r2
 8004f7e:	f003 f961 	bl	8008244 <GUI_ALLOC_h2p>
 8004f82:	4629      	mov	r1, r5
 8004f84:	4680      	mov	r8, r0
 8004f86:	2200      	movs	r2, #0
 8004f88:	6a00      	ldr	r0, [r0, #32]
 8004f8a:	f7ff fc01 	bl	8004790 <_Findx0>
 8004f8e:	2800      	cmp	r0, #0
 8004f90:	d1ed      	bne.n	8004f6e <WM__GetNextIVR+0xd6>
 8004f92:	f8d8 2018 	ldr.w	r2, [r8, #24]
 8004f96:	e7f0      	b.n	8004f7a <WM__GetNextIVR+0xe2>
 8004f98:	9b01      	ldr	r3, [sp, #4]
 8004f9a:	4629      	mov	r1, r5
 8004f9c:	69d8      	ldr	r0, [r3, #28]
 8004f9e:	f7ff fbf7 	bl	8004790 <_Findx0>
 8004fa2:	2800      	cmp	r0, #0
 8004fa4:	d1e3      	bne.n	8004f6e <WM__GetNextIVR+0xd6>
 8004fa6:	88a3      	ldrh	r3, [r4, #4]
 8004fa8:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
 8004fac:	f8ad 300c 	strh.w	r3, [sp, #12]
 8004fb0:	b21b      	sxth	r3, r3
 8004fb2:	429a      	cmp	r2, r3
 8004fb4:	dd07      	ble.n	8004fc6 <WM__GetNextIVR+0x12e>
 8004fb6:	e895 0003 	ldmia.w	r5, {r0, r1}
 8004fba:	e886 0003 	stmia.w	r6, {r0, r1}
 8004fbe:	a801      	add	r0, sp, #4
 8004fc0:	f003 f958 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004fc4:	e797      	b.n	8004ef6 <WM__GetNextIVR+0x5e>
 8004fc6:	683b      	ldr	r3, [r7, #0]
 8004fc8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 8004fca:	b152      	cbz	r2, 8004fe2 <WM__GetNextIVR+0x14a>
 8004fcc:	4610      	mov	r0, r2
 8004fce:	f003 f939 	bl	8008244 <GUI_ALLOC_h2p>
 8004fd2:	4607      	mov	r7, r0
 8004fd4:	2200      	movs	r2, #0
 8004fd6:	6a00      	ldr	r0, [r0, #32]
 8004fd8:	4629      	mov	r1, r5
 8004fda:	f7ff fc1d 	bl	8004818 <_Findx1>
 8004fde:	69ba      	ldr	r2, [r7, #24]
 8004fe0:	e7f3      	b.n	8004fca <WM__GetNextIVR+0x132>
 8004fe2:	af04      	add	r7, sp, #16
 8004fe4:	4629      	mov	r1, r5
 8004fe6:	f857 3d0c 	ldr.w	r3, [r7, #-12]!
 8004fea:	69d8      	ldr	r0, [r3, #28]
 8004fec:	f7ff fc14 	bl	8004818 <_Findx1>
 8004ff0:	4638      	mov	r0, r7
 8004ff2:	f003 f93f 	bl	8008274 <GUI_ALLOC_UnlockH>
 8004ff6:	6923      	ldr	r3, [r4, #16]
 8004ff8:	f644 6220 	movw	r2, #20000	; 0x4e20
 8004ffc:	4293      	cmp	r3, r2
 8004ffe:	dc89      	bgt.n	8004f14 <WM__GetNextIVR+0x7c>
 8005000:	e895 0003 	ldmia.w	r5, {r0, r1}
 8005004:	e886 0003 	stmia.w	r6, {r0, r1}
 8005008:	f7ff fcf2 	bl	80049f0 <WM__ActivateClipRect>
 800500c:	2001      	movs	r0, #1
 800500e:	b004      	add	sp, #16
 8005010:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005014:	20000060 	.word	0x20000060
 8005018:	20001f98 	.word	0x20001f98

0800501c <WM__InitIVRSearch>:
 800501c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005020:	4f39      	ldr	r7, [pc, #228]	; (8005108 <WM__InitIVRSearch+0xec>)
 8005022:	683b      	ldr	r3, [r7, #0]
 8005024:	f893 2054 	ldrb.w	r2, [r3, #84]	; 0x54
 8005028:	b086      	sub	sp, #24
 800502a:	4606      	mov	r6, r0
 800502c:	b912      	cbnz	r2, 8005034 <WM__InitIVRSearch+0x18>
 800502e:	f7ff fcdf 	bl	80049f0 <WM__ActivateClipRect>
 8005032:	e064      	b.n	80050fe <WM__InitIVRSearch+0xe2>
 8005034:	4d35      	ldr	r5, [pc, #212]	; (800510c <WM__InitIVRSearch+0xf0>)
 8005036:	696a      	ldr	r2, [r5, #20]
 8005038:	3201      	adds	r2, #1
 800503a:	2a01      	cmp	r2, #1
 800503c:	616a      	str	r2, [r5, #20]
 800503e:	462c      	mov	r4, r5
 8005040:	dc5d      	bgt.n	80050fe <WM__InitIVRSearch+0xe2>
 8005042:	6c98      	ldr	r0, [r3, #72]	; 0x48
 8005044:	f003 f908 	bl	8008258 <GUI_ALLOC_LockH>
 8005048:	f04f 32ff 	mov.w	r2, #4294967295
 800504c:	612a      	str	r2, [r5, #16]
 800504e:	4a30      	ldr	r2, [pc, #192]	; (8005110 <WM__InitIVRSearch+0xf4>)
 8005050:	9000      	str	r0, [sp, #0]
 8005052:	7812      	ldrb	r2, [r2, #0]
 8005054:	b12a      	cbz	r2, 8005062 <WM__InitIVRSearch+0x46>
 8005056:	f100 0308 	add.w	r3, r0, #8
 800505a:	aa02      	add	r2, sp, #8
 800505c:	e893 0003 	ldmia.w	r3, {r0, r1}
 8005060:	e005      	b.n	800506e <WM__InitIVRSearch+0x52>
 8005062:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8005064:	f012 0802 	ands.w	r8, r2, #2
 8005068:	d00a      	beq.n	8005080 <WM__InitIVRSearch+0x64>
 800506a:	c803      	ldmia	r0, {r0, r1}
 800506c:	aa02      	add	r2, sp, #8
 800506e:	e882 0003 	stmia.w	r2, {r0, r1}
 8005072:	ad02      	add	r5, sp, #8
 8005074:	b166      	cbz	r6, 8005090 <WM__InitIVRSearch+0x74>
 8005076:	4628      	mov	r0, r5
 8005078:	4631      	mov	r1, r6
 800507a:	f002 f82d 	bl	80070d8 <GUI__IntersectRect>
 800507e:	e007      	b.n	8005090 <WM__InitIVRSearch+0x74>
 8005080:	696b      	ldr	r3, [r5, #20]
 8005082:	4668      	mov	r0, sp
 8005084:	3b01      	subs	r3, #1
 8005086:	616b      	str	r3, [r5, #20]
 8005088:	f003 f8f4 	bl	8008274 <GUI_ALLOC_UnlockH>
 800508c:	4640      	mov	r0, r8
 800508e:	e037      	b.n	8005100 <WM__InitIVRSearch+0xe4>
 8005090:	683b      	ldr	r3, [r7, #0]
 8005092:	4e20      	ldr	r6, [pc, #128]	; (8005114 <WM__InitIVRSearch+0xf8>)
 8005094:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8005096:	b1c2      	cbz	r2, 80050ca <WM__InitIVRSearch+0xae>
 8005098:	9b00      	ldr	r3, [sp, #0]
 800509a:	6810      	ldr	r0, [r2, #0]
 800509c:	6851      	ldr	r1, [r2, #4]
 800509e:	9301      	str	r3, [sp, #4]
 80050a0:	ab04      	add	r3, sp, #16
 80050a2:	c303      	stmia	r3!, {r0, r1}
 80050a4:	6833      	ldr	r3, [r6, #0]
 80050a6:	b133      	cbz	r3, 80050b6 <WM__InitIVRSearch+0x9a>
 80050a8:	a801      	add	r0, sp, #4
 80050aa:	f003 f8e3 	bl	8008274 <GUI_ALLOC_UnlockH>
 80050ae:	6830      	ldr	r0, [r6, #0]
 80050b0:	f003 f8d2 	bl	8008258 <GUI_ALLOC_LockH>
 80050b4:	9001      	str	r0, [sp, #4]
 80050b6:	9801      	ldr	r0, [sp, #4]
 80050b8:	a904      	add	r1, sp, #16
 80050ba:	f7ff fc69 	bl	8004990 <WM__Client2Screen>
 80050be:	4628      	mov	r0, r5
 80050c0:	a904      	add	r1, sp, #16
 80050c2:	f002 f809 	bl	80070d8 <GUI__IntersectRect>
 80050c6:	a801      	add	r0, sp, #4
 80050c8:	e000      	b.n	80050cc <WM__InitIVRSearch+0xb0>
 80050ca:	4668      	mov	r0, sp
 80050cc:	f003 f8d2 	bl	8008274 <GUI_ALLOC_UnlockH>
 80050d0:	6831      	ldr	r1, [r6, #0]
 80050d2:	b119      	cbz	r1, 80050dc <WM__InitIVRSearch+0xc0>
 80050d4:	4628      	mov	r0, r5
 80050d6:	f7ff fbdb 	bl	8004890 <WM__ClipAtParentBorders>
 80050da:	b128      	cbz	r0, 80050e8 <WM__InitIVRSearch+0xcc>
 80050dc:	683b      	ldr	r3, [r7, #0]
 80050de:	4628      	mov	r0, r5
 80050e0:	6c99      	ldr	r1, [r3, #72]	; 0x48
 80050e2:	f7ff fbd5 	bl	8004890 <WM__ClipAtParentBorders>
 80050e6:	b918      	cbnz	r0, 80050f0 <WM__InitIVRSearch+0xd4>
 80050e8:	6963      	ldr	r3, [r4, #20]
 80050ea:	3b01      	subs	r3, #1
 80050ec:	6163      	str	r3, [r4, #20]
 80050ee:	e007      	b.n	8005100 <WM__InitIVRSearch+0xe4>
 80050f0:	e895 0003 	ldmia.w	r5, {r0, r1}
 80050f4:	e884 0003 	stmia.w	r4, {r0, r1}
 80050f8:	f7ff fece 	bl	8004e98 <WM__GetNextIVR>
 80050fc:	e000      	b.n	8005100 <WM__InitIVRSearch+0xe4>
 80050fe:	2001      	movs	r0, #1
 8005100:	b006      	add	sp, #24
 8005102:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005106:	bf00      	nop
 8005108:	20000060 	.word	0x20000060
 800510c:	20001f98 	.word	0x20001f98
 8005110:	200222b5 	.word	0x200222b5
 8005114:	2002228c 	.word	0x2002228c

08005118 <WM_Activate>:
 8005118:	4b02      	ldr	r3, [pc, #8]	; (8005124 <WM_Activate+0xc>)
 800511a:	681b      	ldr	r3, [r3, #0]
 800511c:	2201      	movs	r2, #1
 800511e:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
 8005122:	4770      	bx	lr
 8005124:	20000060 	.word	0x20000060

08005128 <WM_DefaultProc>:
 8005128:	b510      	push	{r4, lr}
 800512a:	4604      	mov	r4, r0
 800512c:	6840      	ldr	r0, [r0, #4]
 800512e:	6823      	ldr	r3, [r4, #0]
 8005130:	68e1      	ldr	r1, [r4, #12]
 8005132:	2b17      	cmp	r3, #23
 8005134:	d00f      	beq.n	8005156 <WM_DefaultProc+0x2e>
 8005136:	dc06      	bgt.n	8005146 <WM_DefaultProc+0x1e>
 8005138:	2b0e      	cmp	r3, #14
 800513a:	d00e      	beq.n	800515a <WM_DefaultProc+0x32>
 800513c:	2b14      	cmp	r3, #20
 800513e:	d114      	bne.n	800516a <WM_DefaultProc+0x42>
 8005140:	f003 fb62 	bl	8008808 <WM__GetClientRectEx>
 8005144:	e011      	b.n	800516a <WM_DefaultProc+0x42>
 8005146:	2b22      	cmp	r3, #34	; 0x22
 8005148:	d00c      	beq.n	8005164 <WM_DefaultProc+0x3c>
 800514a:	2b28      	cmp	r3, #40	; 0x28
 800514c:	d10d      	bne.n	800516a <WM_DefaultProc+0x42>
 800514e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005152:	f7ff bdb6 	b.w	8004cc2 <WM_InvalidateWindow>
 8005156:	60e0      	str	r0, [r4, #12]
 8005158:	bd10      	pop	{r4, pc}
 800515a:	4621      	mov	r1, r4
 800515c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8005160:	f003 bb28 	b.w	80087b4 <WM_SendToParent>
 8005164:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8005168:	e000      	b.n	800516c <WM_DefaultProc+0x44>
 800516a:	2300      	movs	r3, #0
 800516c:	60e3      	str	r3, [r4, #12]
 800516e:	bd10      	pop	{r4, pc}

08005170 <cbBackWin>:
 8005170:	6803      	ldr	r3, [r0, #0]
 8005172:	2b0e      	cmp	r3, #14
 8005174:	b510      	push	{r4, lr}
 8005176:	4604      	mov	r4, r0
 8005178:	d002      	beq.n	8005180 <cbBackWin+0x10>
 800517a:	2b0f      	cmp	r3, #15
 800517c:	d009      	beq.n	8005192 <cbBackWin+0x22>
 800517e:	e020      	b.n	80051c2 <cbBackWin+0x52>
 8005180:	68c3      	ldr	r3, [r0, #12]
 8005182:	685a      	ldr	r2, [r3, #4]
 8005184:	2a01      	cmp	r2, #1
 8005186:	d121      	bne.n	80051cc <cbBackWin+0x5c>
 8005188:	6818      	ldr	r0, [r3, #0]
 800518a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800518e:	f002 b9cb 	b.w	8007528 <GUI_StoreKey>
 8005192:	4a0f      	ldr	r2, [pc, #60]	; (80051d0 <cbBackWin+0x60>)
 8005194:	6843      	ldr	r3, [r0, #4]
 8005196:	6811      	ldr	r1, [r2, #0]
 8005198:	428b      	cmp	r3, r1
 800519a:	d006      	beq.n	80051aa <cbBackWin+0x3a>
 800519c:	6852      	ldr	r2, [r2, #4]
 800519e:	4293      	cmp	r3, r2
 80051a0:	bf14      	ite	ne
 80051a2:	f04f 33ff 	movne.w	r3, #4294967295
 80051a6:	2301      	moveq	r3, #1
 80051a8:	e000      	b.n	80051ac <cbBackWin+0x3c>
 80051aa:	2300      	movs	r3, #0
 80051ac:	4a09      	ldr	r2, [pc, #36]	; (80051d4 <cbBackWin+0x64>)
 80051ae:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
 80051b2:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 80051b6:	4298      	cmp	r0, r3
 80051b8:	d003      	beq.n	80051c2 <cbBackWin+0x52>
 80051ba:	f002 f96f 	bl	800749c <GUI_SetBkColor>
 80051be:	f002 fc2d 	bl	8007a1c <GUI_Clear>
 80051c2:	4620      	mov	r0, r4
 80051c4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80051c8:	f7ff bfae 	b.w	8005128 <WM_DefaultProc>
 80051cc:	bd10      	pop	{r4, pc}
 80051ce:	bf00      	nop
 80051d0:	20022290 	.word	0x20022290
 80051d4:	200222bc 	.word	0x200222bc

080051d8 <WM_Init>:
 80051d8:	b530      	push	{r4, r5, lr}
 80051da:	4b2b      	ldr	r3, [pc, #172]	; (8005288 <WM_Init+0xb0>)
 80051dc:	7818      	ldrb	r0, [r3, #0]
 80051de:	b085      	sub	sp, #20
 80051e0:	461d      	mov	r5, r3
 80051e2:	2800      	cmp	r0, #0
 80051e4:	d14d      	bne.n	8005282 <WM_Init+0xaa>
 80051e6:	4b29      	ldr	r3, [pc, #164]	; (800528c <WM_Init+0xb4>)
 80051e8:	6018      	str	r0, [r3, #0]
 80051ea:	4b29      	ldr	r3, [pc, #164]	; (8005290 <WM_Init+0xb8>)
 80051ec:	6018      	str	r0, [r3, #0]
 80051ee:	4b29      	ldr	r3, [pc, #164]	; (8005294 <WM_Init+0xbc>)
 80051f0:	681b      	ldr	r3, [r3, #0]
 80051f2:	6458      	str	r0, [r3, #68]	; 0x44
 80051f4:	4b28      	ldr	r3, [pc, #160]	; (8005298 <WM_Init+0xc0>)
 80051f6:	8018      	strh	r0, [r3, #0]
 80051f8:	4b28      	ldr	r3, [pc, #160]	; (800529c <WM_Init+0xc4>)
 80051fa:	4604      	mov	r4, r0
 80051fc:	8018      	strh	r0, [r3, #0]
 80051fe:	4620      	mov	r0, r4
 8005200:	f002 faf6 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8005204:	b1c0      	cbz	r0, 8005238 <WM_Init+0x60>
 8005206:	f04f 32ff 	mov.w	r2, #4294967295
 800520a:	2302      	movs	r3, #2
 800520c:	e88d 000c 	stmia.w	sp, {r2, r3}
 8005210:	2000      	movs	r0, #0
 8005212:	f643 72ff 	movw	r2, #16383	; 0x3fff
 8005216:	4b22      	ldr	r3, [pc, #136]	; (80052a0 <WM_Init+0xc8>)
 8005218:	9302      	str	r3, [sp, #8]
 800521a:	9003      	str	r0, [sp, #12]
 800521c:	4613      	mov	r3, r2
 800521e:	4601      	mov	r1, r0
 8005220:	f7ff fd90 	bl	8004d44 <WM_CreateWindowAsChild>
 8005224:	4b1f      	ldr	r3, [pc, #124]	; (80052a4 <WM_Init+0xcc>)
 8005226:	f843 0024 	str.w	r0, [r3, r4, lsl #2]
 800522a:	4b1f      	ldr	r3, [pc, #124]	; (80052a8 <WM_Init+0xd0>)
 800522c:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
 8005230:	f843 2024 	str.w	r2, [r3, r4, lsl #2]
 8005234:	f7ff fd45 	bl	8004cc2 <WM_InvalidateWindow>
 8005238:	3401      	adds	r4, #1
 800523a:	2c02      	cmp	r4, #2
 800523c:	d1df      	bne.n	80051fe <WM_Init+0x26>
 800523e:	481b      	ldr	r0, [pc, #108]	; (80052ac <WM_Init+0xd4>)
 8005240:	f003 faf4 	bl	800882c <WM__AddCriticalHandle>
 8005244:	481a      	ldr	r0, [pc, #104]	; (80052b0 <WM_Init+0xd8>)
 8005246:	f003 faf1 	bl	800882c <WM__AddCriticalHandle>
 800524a:	481a      	ldr	r0, [pc, #104]	; (80052b4 <WM_Init+0xdc>)
 800524c:	f003 faee 	bl	800882c <WM__AddCriticalHandle>
 8005250:	4819      	ldr	r0, [pc, #100]	; (80052b8 <WM_Init+0xe0>)
 8005252:	f003 faeb 	bl	800882c <WM__AddCriticalHandle>
 8005256:	4819      	ldr	r0, [pc, #100]	; (80052bc <WM_Init+0xe4>)
 8005258:	f003 fae8 	bl	800882c <WM__AddCriticalHandle>
 800525c:	4818      	ldr	r0, [pc, #96]	; (80052c0 <WM_Init+0xe8>)
 800525e:	f003 fae5 	bl	800882c <WM__AddCriticalHandle>
 8005262:	4b10      	ldr	r3, [pc, #64]	; (80052a4 <WM_Init+0xcc>)
 8005264:	6818      	ldr	r0, [r3, #0]
 8005266:	f7ff fd4d 	bl	8004d04 <WM_SelectWindow>
 800526a:	f7ff ff55 	bl	8005118 <WM_Activate>
 800526e:	2301      	movs	r3, #1
 8005270:	702b      	strb	r3, [r5, #0]
 8005272:	4814      	ldr	r0, [pc, #80]	; (80052c4 <WM_Init+0xec>)
 8005274:	4b14      	ldr	r3, [pc, #80]	; (80052c8 <WM_Init+0xf0>)
 8005276:	6003      	str	r3, [r0, #0]
 8005278:	b005      	add	sp, #20
 800527a:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800527e:	f002 bbdd 	b.w	8007a3c <GUI__RegisterExit>
 8005282:	b005      	add	sp, #20
 8005284:	bd30      	pop	{r4, r5, pc}
 8005286:	bf00      	nop
 8005288:	20001fbc 	.word	0x20001fbc
 800528c:	200222ac 	.word	0x200222ac
 8005290:	20001fb8 	.word	0x20001fb8
 8005294:	20000060 	.word	0x20000060
 8005298:	200222a8 	.word	0x200222a8
 800529c:	20022288 	.word	0x20022288
 80052a0:	08005171 	.word	0x08005171
 80052a4:	20022290 	.word	0x20022290
 80052a8:	200222bc 	.word	0x200222bc
 80052ac:	200223f8 	.word	0x200223f8
 80052b0:	200223e8 	.word	0x200223e8
 80052b4:	200223d8 	.word	0x200223d8
 80052b8:	20022400 	.word	0x20022400
 80052bc:	200223f0 	.word	0x200223f0
 80052c0:	200223e0 	.word	0x200223e0
 80052c4:	20001fb0 	.word	0x20001fb0
 80052c8:	08004695 	.word	0x08004695

080052cc <GUI_MEMDEV_GetDataPtr>:
 80052cc:	b513      	push	{r0, r1, r4, lr}
 80052ce:	b150      	cbz	r0, 80052e6 <GUI_MEMDEV_GetDataPtr+0x1a>
 80052d0:	f002 ffc2 	bl	8008258 <GUI_ALLOC_LockH>
 80052d4:	4604      	mov	r4, r0
 80052d6:	a802      	add	r0, sp, #8
 80052d8:	f840 4d04 	str.w	r4, [r0, #-4]!
 80052dc:	f002 ffca 	bl	8008274 <GUI_ALLOC_UnlockH>
 80052e0:	f104 0018 	add.w	r0, r4, #24
 80052e4:	e7ff      	b.n	80052e6 <GUI_MEMDEV_GetDataPtr+0x1a>
 80052e6:	b002      	add	sp, #8
 80052e8:	bd10      	pop	{r4, pc}
	...

080052ec <_GetDevData>:
 80052ec:	4802      	ldr	r0, [pc, #8]	; (80052f8 <_GetDevData+0xc>)
 80052ee:	2901      	cmp	r1, #1
 80052f0:	bf18      	it	ne
 80052f2:	2000      	movne	r0, #0
 80052f4:	4770      	bx	lr
 80052f6:	bf00      	nop
 80052f8:	08009c1c 	.word	0x08009c1c

080052fc <_GetDevFunc>:
 80052fc:	4802      	ldr	r0, [pc, #8]	; (8005308 <_GetDevFunc+0xc>)
 80052fe:	2916      	cmp	r1, #22
 8005300:	bf18      	it	ne
 8005302:	2000      	movne	r0, #0
 8005304:	4770      	bx	lr
 8005306:	bf00      	nop
 8005308:	080088c5 	.word	0x080088c5

0800530c <_GetDevProp>:
 800530c:	2908      	cmp	r1, #8
 800530e:	bf0c      	ite	eq
 8005310:	2020      	moveq	r0, #32
 8005312:	2000      	movne	r0, #0
 8005314:	4770      	bx	lr

08005316 <_SetOrg>:
 8005316:	b508      	push	{r3, lr}
 8005318:	6800      	ldr	r0, [r0, #0]
 800531a:	68c3      	ldr	r3, [r0, #12]
 800531c:	6a1b      	ldr	r3, [r3, #32]
 800531e:	4798      	blx	r3
 8005320:	bd08      	pop	{r3, pc}

08005322 <_GetRect>:
 8005322:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8005324:	6880      	ldr	r0, [r0, #8]
 8005326:	460c      	mov	r4, r1
 8005328:	f002 ff96 	bl	8008258 <GUI_ALLOC_LockH>
 800532c:	4603      	mov	r3, r0
 800532e:	a802      	add	r0, sp, #8
 8005330:	8899      	ldrh	r1, [r3, #4]
 8005332:	88da      	ldrh	r2, [r3, #6]
 8005334:	891d      	ldrh	r5, [r3, #8]
 8005336:	f840 3d04 	str.w	r3, [r0, #-4]!
 800533a:	895b      	ldrh	r3, [r3, #10]
 800533c:	8021      	strh	r1, [r4, #0]
 800533e:	8062      	strh	r2, [r4, #2]
 8005340:	4429      	add	r1, r5
 8005342:	441a      	add	r2, r3
 8005344:	3901      	subs	r1, #1
 8005346:	3a01      	subs	r2, #1
 8005348:	80a1      	strh	r1, [r4, #4]
 800534a:	80e2      	strh	r2, [r4, #6]
 800534c:	f002 ff92 	bl	8008274 <GUI_ALLOC_UnlockH>
 8005350:	b003      	add	sp, #12
 8005352:	bd30      	pop	{r4, r5, pc}

08005354 <_XY2PTR>:
 8005354:	4b0e      	ldr	r3, [pc, #56]	; (8005390 <_XY2PTR+0x3c>)
 8005356:	681b      	ldr	r3, [r3, #0]
 8005358:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800535a:	4605      	mov	r5, r0
 800535c:	6e18      	ldr	r0, [r3, #96]	; 0x60
 800535e:	460e      	mov	r6, r1
 8005360:	f002 ff7a 	bl	8008258 <GUI_ALLOC_LockH>
 8005364:	4603      	mov	r3, r0
 8005366:	a802      	add	r0, sp, #8
 8005368:	f9b3 4006 	ldrsh.w	r4, [r3, #6]
 800536c:	f840 3d04 	str.w	r3, [r0, #-4]!
 8005370:	f103 0118 	add.w	r1, r3, #24
 8005374:	1b36      	subs	r6, r6, r4
 8005376:	68dc      	ldr	r4, [r3, #12]
 8005378:	f9b3 3004 	ldrsh.w	r3, [r3, #4]
 800537c:	fb04 1406 	mla	r4, r4, r6, r1
 8005380:	1aed      	subs	r5, r5, r3
 8005382:	f002 ff77 	bl	8008274 <GUI_ALLOC_UnlockH>
 8005386:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 800538a:	4620      	mov	r0, r4
 800538c:	b002      	add	sp, #8
 800538e:	bd70      	pop	{r4, r5, r6, pc}
 8005390:	20000060 	.word	0x20000060

08005394 <_GetPixelIndex>:
 8005394:	b508      	push	{r3, lr}
 8005396:	4608      	mov	r0, r1
 8005398:	4611      	mov	r1, r2
 800539a:	f7ff ffdb 	bl	8005354 <_XY2PTR>
 800539e:	6800      	ldr	r0, [r0, #0]
 80053a0:	bd08      	pop	{r3, pc}
	...

080053a4 <_XorPixel>:
 80053a4:	4b15      	ldr	r3, [pc, #84]	; (80053fc <_XorPixel+0x58>)
 80053a6:	681b      	ldr	r3, [r3, #0]
 80053a8:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80053aa:	6e18      	ldr	r0, [r3, #96]	; 0x60
 80053ac:	4615      	mov	r5, r2
 80053ae:	460e      	mov	r6, r1
 80053b0:	f002 ff52 	bl	8008258 <GUI_ALLOC_LockH>
 80053b4:	4629      	mov	r1, r5
 80053b6:	9000      	str	r0, [sp, #0]
 80053b8:	4630      	mov	r0, r6
 80053ba:	f7ff ffcb 	bl	8005354 <_XY2PTR>
 80053be:	9b00      	ldr	r3, [sp, #0]
 80053c0:	681b      	ldr	r3, [r3, #0]
 80053c2:	691b      	ldr	r3, [r3, #16]
 80053c4:	4604      	mov	r4, r0
 80053c6:	689b      	ldr	r3, [r3, #8]
 80053c8:	4798      	blx	r3
 80053ca:	6823      	ldr	r3, [r4, #0]
 80053cc:	4058      	eors	r0, r3
 80053ce:	9b00      	ldr	r3, [sp, #0]
 80053d0:	6020      	str	r0, [r4, #0]
 80053d2:	6958      	ldr	r0, [r3, #20]
 80053d4:	b160      	cbz	r0, 80053f0 <_XorPixel+0x4c>
 80053d6:	f002 ff3f 	bl	8008258 <GUI_ALLOC_LockH>
 80053da:	ac02      	add	r4, sp, #8
 80053dc:	6883      	ldr	r3, [r0, #8]
 80053de:	f844 0d04 	str.w	r0, [r4, #-4]!
 80053e2:	681b      	ldr	r3, [r3, #0]
 80053e4:	4631      	mov	r1, r6
 80053e6:	462a      	mov	r2, r5
 80053e8:	4798      	blx	r3
 80053ea:	4620      	mov	r0, r4
 80053ec:	f002 ff42 	bl	8008274 <GUI_ALLOC_UnlockH>
 80053f0:	4668      	mov	r0, sp
 80053f2:	f002 ff3f 	bl	8008274 <GUI_ALLOC_UnlockH>
 80053f6:	b002      	add	sp, #8
 80053f8:	bd70      	pop	{r4, r5, r6, pc}
 80053fa:	bf00      	nop
 80053fc:	20000060 	.word	0x20000060

08005400 <_SetPixelIndex>:
 8005400:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005402:	461c      	mov	r4, r3
 8005404:	4b10      	ldr	r3, [pc, #64]	; (8005448 <_SetPixelIndex+0x48>)
 8005406:	681b      	ldr	r3, [r3, #0]
 8005408:	6e18      	ldr	r0, [r3, #96]	; 0x60
 800540a:	460e      	mov	r6, r1
 800540c:	4615      	mov	r5, r2
 800540e:	f002 ff23 	bl	8008258 <GUI_ALLOC_LockH>
 8005412:	4629      	mov	r1, r5
 8005414:	9000      	str	r0, [sp, #0]
 8005416:	4630      	mov	r0, r6
 8005418:	f7ff ff9c 	bl	8005354 <_XY2PTR>
 800541c:	9b00      	ldr	r3, [sp, #0]
 800541e:	6004      	str	r4, [r0, #0]
 8005420:	6958      	ldr	r0, [r3, #20]
 8005422:	b160      	cbz	r0, 800543e <_SetPixelIndex+0x3e>
 8005424:	f002 ff18 	bl	8008258 <GUI_ALLOC_LockH>
 8005428:	ac02      	add	r4, sp, #8
 800542a:	6883      	ldr	r3, [r0, #8]
 800542c:	f844 0d04 	str.w	r0, [r4, #-4]!
 8005430:	681b      	ldr	r3, [r3, #0]
 8005432:	4631      	mov	r1, r6
 8005434:	462a      	mov	r2, r5
 8005436:	4798      	blx	r3
 8005438:	4620      	mov	r0, r4
 800543a:	f002 ff1b 	bl	8008274 <GUI_ALLOC_UnlockH>
 800543e:	4668      	mov	r0, sp
 8005440:	f002 ff18 	bl	8008274 <GUI_ALLOC_UnlockH>
 8005444:	b002      	add	sp, #8
 8005446:	bd70      	pop	{r4, r5, r6, pc}
 8005448:	20000060 	.word	0x20000060

0800544c <_DrawVLine>:
 800544c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8005450:	4d2c      	ldr	r5, [pc, #176]	; (8005504 <_DrawVLine+0xb8>)
 8005452:	461e      	mov	r6, r3
 8005454:	682b      	ldr	r3, [r5, #0]
 8005456:	6e18      	ldr	r0, [r3, #96]	; 0x60
 8005458:	460f      	mov	r7, r1
 800545a:	4614      	mov	r4, r2
 800545c:	f002 fefc 	bl	8008258 <GUI_ALLOC_LockH>
 8005460:	9000      	str	r0, [sp, #0]
 8005462:	6940      	ldr	r0, [r0, #20]
 8005464:	46a9      	mov	r9, r5
 8005466:	b108      	cbz	r0, 800546c <_DrawVLine+0x20>
 8005468:	f002 fef6 	bl	8008258 <GUI_ALLOC_LockH>
 800546c:	9001      	str	r0, [sp, #4]
 800546e:	4621      	mov	r1, r4
 8005470:	4638      	mov	r0, r7
 8005472:	f7ff ff6f 	bl	8005354 <_XY2PTR>
 8005476:	f8d9 2000 	ldr.w	r2, [r9]
 800547a:	9b00      	ldr	r3, [sp, #0]
 800547c:	6bd1      	ldr	r1, [r2, #60]	; 0x3c
 800547e:	7c12      	ldrb	r2, [r2, #16]
 8005480:	f8d3 800c 	ldr.w	r8, [r3, #12]
 8005484:	f8d1 9000 	ldr.w	r9, [r1]
 8005488:	07d2      	lsls	r2, r2, #31
 800548a:	4605      	mov	r5, r0
 800548c:	d51f      	bpl.n	80054ce <_DrawVLine+0x82>
 800548e:	681b      	ldr	r3, [r3, #0]
 8005490:	691b      	ldr	r3, [r3, #16]
 8005492:	689b      	ldr	r3, [r3, #8]
 8005494:	4798      	blx	r3
 8005496:	4680      	mov	r8, r0
 8005498:	9801      	ldr	r0, [sp, #4]
 800549a:	b128      	cbz	r0, 80054a8 <_DrawVLine+0x5c>
 800549c:	6882      	ldr	r2, [r0, #8]
 800549e:	4639      	mov	r1, r7
 80054a0:	f8d2 c000 	ldr.w	ip, [r2]
 80054a4:	4622      	mov	r2, r4
 80054a6:	47e0      	blx	ip
 80054a8:	682b      	ldr	r3, [r5, #0]
 80054aa:	ea83 0308 	eor.w	r3, r3, r8
 80054ae:	602b      	str	r3, [r5, #0]
 80054b0:	9b00      	ldr	r3, [sp, #0]
 80054b2:	3401      	adds	r4, #1
 80054b4:	68db      	ldr	r3, [r3, #12]
 80054b6:	42b4      	cmp	r4, r6
 80054b8:	441d      	add	r5, r3
 80054ba:	dded      	ble.n	8005498 <_DrawVLine+0x4c>
 80054bc:	4668      	mov	r0, sp
 80054be:	f002 fed9 	bl	8008274 <GUI_ALLOC_UnlockH>
 80054c2:	9b01      	ldr	r3, [sp, #4]
 80054c4:	b1d3      	cbz	r3, 80054fc <_DrawVLine+0xb0>
 80054c6:	a801      	add	r0, sp, #4
 80054c8:	f002 fed4 	bl	8008274 <GUI_ALLOC_UnlockH>
 80054cc:	e016      	b.n	80054fc <_DrawVLine+0xb0>
 80054ce:	9b01      	ldr	r3, [sp, #4]
 80054d0:	b163      	cbz	r3, 80054ec <_DrawVLine+0xa0>
 80054d2:	9801      	ldr	r0, [sp, #4]
 80054d4:	6883      	ldr	r3, [r0, #8]
 80054d6:	4622      	mov	r2, r4
 80054d8:	681b      	ldr	r3, [r3, #0]
 80054da:	4639      	mov	r1, r7
 80054dc:	3401      	adds	r4, #1
 80054de:	4798      	blx	r3
 80054e0:	42b4      	cmp	r4, r6
 80054e2:	f8c5 9000 	str.w	r9, [r5]
 80054e6:	4445      	add	r5, r8
 80054e8:	ddf3      	ble.n	80054d2 <_DrawVLine+0x86>
 80054ea:	e7e7      	b.n	80054bc <_DrawVLine+0x70>
 80054ec:	1b34      	subs	r4, r6, r4
 80054ee:	3401      	adds	r4, #1
 80054f0:	3c01      	subs	r4, #1
 80054f2:	f8c5 9000 	str.w	r9, [r5]
 80054f6:	4445      	add	r5, r8
 80054f8:	d1fa      	bne.n	80054f0 <_DrawVLine+0xa4>
 80054fa:	e7df      	b.n	80054bc <_DrawVLine+0x70>
 80054fc:	b003      	add	sp, #12
 80054fe:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8005502:	bf00      	nop
 8005504:	20000060 	.word	0x20000060

08005508 <_FillRect>:
 8005508:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800550c:	f8df b0ac 	ldr.w	fp, [pc, #172]	; 80055bc <_FillRect+0xb4>
 8005510:	4614      	mov	r4, r2
 8005512:	f8db 2000 	ldr.w	r2, [fp]
 8005516:	b085      	sub	sp, #20
 8005518:	6e10      	ldr	r0, [r2, #96]	; 0x60
 800551a:	460f      	mov	r7, r1
 800551c:	461d      	mov	r5, r3
 800551e:	f002 fe9b 	bl	8008258 <GUI_ALLOC_LockH>
 8005522:	4621      	mov	r1, r4
 8005524:	9002      	str	r0, [sp, #8]
 8005526:	4638      	mov	r0, r7
 8005528:	f7ff ff14 	bl	8005354 <_XY2PTR>
 800552c:	9a02      	ldr	r2, [sp, #8]
 800552e:	f8db 3000 	ldr.w	r3, [fp]
 8005532:	f8d2 900c 	ldr.w	r9, [r2, #12]
 8005536:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8005538:	4606      	mov	r6, r0
 800553a:	6950      	ldr	r0, [r2, #20]
 800553c:	f8d3 a000 	ldr.w	sl, [r3]
 8005540:	1bed      	subs	r5, r5, r7
 8005542:	3501      	adds	r5, #1
 8005544:	b338      	cbz	r0, 8005596 <_FillRect+0x8e>
 8005546:	f002 fe87 	bl	8008258 <GUI_ALLOC_LockH>
 800554a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 800554c:	f10d 0810 	add.w	r8, sp, #16
 8005550:	1b13      	subs	r3, r2, r4
 8005552:	f848 0d04 	str.w	r0, [r8, #-4]!
 8005556:	3301      	adds	r3, #1
 8005558:	9300      	str	r3, [sp, #0]
 800555a:	4639      	mov	r1, r7
 800555c:	4622      	mov	r2, r4
 800555e:	462b      	mov	r3, r5
 8005560:	f003 fa8c 	bl	8008a7c <GUI_USAGE_AddRect>
 8005564:	4640      	mov	r0, r8
 8005566:	f002 fe85 	bl	8008274 <GUI_ALLOC_UnlockH>
 800556a:	e014      	b.n	8005596 <_FillRect+0x8e>
 800556c:	f8db 3000 	ldr.w	r3, [fp]
 8005570:	7c1b      	ldrb	r3, [r3, #16]
 8005572:	07db      	lsls	r3, r3, #31
 8005574:	d513      	bpl.n	800559e <_FillRect+0x96>
 8005576:	9b02      	ldr	r3, [sp, #8]
 8005578:	681b      	ldr	r3, [r3, #0]
 800557a:	691b      	ldr	r3, [r3, #16]
 800557c:	689b      	ldr	r3, [r3, #8]
 800557e:	4798      	blx	r3
 8005580:	4632      	mov	r2, r6
 8005582:	462b      	mov	r3, r5
 8005584:	6811      	ldr	r1, [r2, #0]
 8005586:	3b01      	subs	r3, #1
 8005588:	ea81 0100 	eor.w	r1, r1, r0
 800558c:	f842 1b04 	str.w	r1, [r2], #4
 8005590:	d1f8      	bne.n	8005584 <_FillRect+0x7c>
 8005592:	444e      	add	r6, r9
 8005594:	3401      	adds	r4, #1
 8005596:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8005598:	429c      	cmp	r4, r3
 800559a:	dde7      	ble.n	800556c <_FillRect+0x64>
 800559c:	e008      	b.n	80055b0 <_FillRect+0xa8>
 800559e:	2d00      	cmp	r5, #0
 80055a0:	ddf7      	ble.n	8005592 <_FillRect+0x8a>
 80055a2:	462b      	mov	r3, r5
 80055a4:	4632      	mov	r2, r6
 80055a6:	3b01      	subs	r3, #1
 80055a8:	f842 ab04 	str.w	sl, [r2], #4
 80055ac:	d1fb      	bne.n	80055a6 <_FillRect+0x9e>
 80055ae:	e7f0      	b.n	8005592 <_FillRect+0x8a>
 80055b0:	a802      	add	r0, sp, #8
 80055b2:	f002 fe5f 	bl	8008274 <GUI_ALLOC_UnlockH>
 80055b6:	b005      	add	sp, #20
 80055b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80055bc:	20000060 	.word	0x20000060

080055c0 <_DrawHLine>:
 80055c0:	b507      	push	{r0, r1, r2, lr}
 80055c2:	9200      	str	r2, [sp, #0]
 80055c4:	f7ff ffa0 	bl	8005508 <_FillRect>
 80055c8:	b003      	add	sp, #12
 80055ca:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080055d0 <_DrawBitmap>:
 80055d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80055d4:	4c9e      	ldr	r4, [pc, #632]	; (8005850 <_DrawBitmap+0x280>)
 80055d6:	469a      	mov	sl, r3
 80055d8:	6823      	ldr	r3, [r4, #0]
 80055da:	b091      	sub	sp, #68	; 0x44
 80055dc:	4680      	mov	r8, r0
 80055de:	6e18      	ldr	r0, [r3, #96]	; 0x60
 80055e0:	9207      	str	r2, [sp, #28]
 80055e2:	460e      	mov	r6, r1
 80055e4:	f8dd b074 	ldr.w	fp, [sp, #116]	; 0x74
 80055e8:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
 80055ea:	2800      	cmp	r0, #0
 80055ec:	f000 837f 	beq.w	8005cee <_DrawBitmap+0x71e>
 80055f0:	f002 fe32 	bl	8008258 <GUI_ALLOC_LockH>
 80055f4:	900e      	str	r0, [sp, #56]	; 0x38
 80055f6:	6940      	ldr	r0, [r0, #20]
 80055f8:	b108      	cbz	r0, 80055fe <_DrawBitmap+0x2e>
 80055fa:	f002 fe2d 	bl	8008258 <GUI_ALLOC_LockH>
 80055fe:	900f      	str	r0, [sp, #60]	; 0x3c
 8005600:	a810      	add	r0, sp, #64	; 0x40
 8005602:	f850 3d08 	ldr.w	r3, [r0, #-8]!
 8005606:	68db      	ldr	r3, [r3, #12]
 8005608:	930a      	str	r3, [sp, #40]	; 0x28
 800560a:	f002 fe33 	bl	8008274 <GUI_ALLOC_UnlockH>
 800560e:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8005610:	980f      	ldr	r0, [sp, #60]	; 0x3c
 8005612:	4437      	add	r7, r6
 8005614:	9704      	str	r7, [sp, #16]
 8005616:	b150      	cbz	r0, 800562e <_DrawBitmap+0x5e>
 8005618:	6823      	ldr	r3, [r4, #0]
 800561a:	7c1b      	ldrb	r3, [r3, #16]
 800561c:	079c      	lsls	r4, r3, #30
 800561e:	d406      	bmi.n	800562e <_DrawBitmap+0x5e>
 8005620:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8005622:	9700      	str	r7, [sp, #0]
 8005624:	9904      	ldr	r1, [sp, #16]
 8005626:	9a07      	ldr	r2, [sp, #28]
 8005628:	4653      	mov	r3, sl
 800562a:	f003 fa27 	bl	8008a7c <GUI_USAGE_AddRect>
 800562e:	9804      	ldr	r0, [sp, #16]
 8005630:	9907      	ldr	r1, [sp, #28]
 8005632:	f7ff fe8f 	bl	8005354 <_XY2PTR>
 8005636:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 8005638:	2f17      	cmp	r7, #23
 800563a:	4606      	mov	r6, r0
 800563c:	dd5b      	ble.n	80056f6 <_DrawBitmap+0x126>
 800563e:	ea4f 078a 	mov.w	r7, sl, lsl #2
 8005642:	9705      	str	r7, [sp, #20]
 8005644:	f04f 0900 	mov.w	r9, #0
 8005648:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 800564a:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800564c:	45b9      	cmp	r9, r7
 800564e:	da4e      	bge.n	80056ee <_DrawBitmap+0x11e>
 8005650:	b130      	cbz	r0, 8005660 <_DrawBitmap+0x90>
 8005652:	6883      	ldr	r3, [r0, #8]
 8005654:	9a07      	ldr	r2, [sp, #28]
 8005656:	685c      	ldr	r4, [r3, #4]
 8005658:	9904      	ldr	r1, [sp, #16]
 800565a:	444a      	add	r2, r9
 800565c:	4653      	mov	r3, sl
 800565e:	47a0      	blx	r4
 8005660:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8005664:	68db      	ldr	r3, [r3, #12]
 8005666:	b12b      	cbz	r3, 8005674 <_DrawBitmap+0xa4>
 8005668:	4630      	mov	r0, r6
 800566a:	4659      	mov	r1, fp
 800566c:	9a05      	ldr	r2, [sp, #20]
 800566e:	f003 fea9 	bl	80093c4 <memcpy>
 8005672:	e035      	b.n	80056e0 <_DrawBitmap+0x110>
 8005674:	4635      	mov	r5, r6
 8005676:	4657      	mov	r7, sl
 8005678:	465c      	mov	r4, fp
 800567a:	463b      	mov	r3, r7
 800567c:	4622      	mov	r2, r4
 800567e:	f04f 0c00 	mov.w	ip, #0
 8005682:	f852 1b04 	ldr.w	r1, [r2], #4
 8005686:	0e09      	lsrs	r1, r1, #24
 8005688:	bf08      	it	eq
 800568a:	f10c 0c01 	addeq.w	ip, ip, #1
 800568e:	3b01      	subs	r3, #1
 8005690:	b1a1      	cbz	r1, 80056bc <_DrawBitmap+0xec>
 8005692:	f1bc 0f00 	cmp.w	ip, #0
 8005696:	d014      	beq.n	80056c2 <_DrawBitmap+0xf2>
 8005698:	ea4f 038c 	mov.w	r3, ip, lsl #2
 800569c:	4628      	mov	r0, r5
 800569e:	4621      	mov	r1, r4
 80056a0:	461a      	mov	r2, r3
 80056a2:	9303      	str	r3, [sp, #12]
 80056a4:	f8cd c008 	str.w	ip, [sp, #8]
 80056a8:	f003 fe8c 	bl	80093c4 <memcpy>
 80056ac:	9b03      	ldr	r3, [sp, #12]
 80056ae:	f8dd c008 	ldr.w	ip, [sp, #8]
 80056b2:	441d      	add	r5, r3
 80056b4:	441c      	add	r4, r3
 80056b6:	ebcc 0707 	rsb	r7, ip, r7
 80056ba:	e00f      	b.n	80056dc <_DrawBitmap+0x10c>
 80056bc:	2b00      	cmp	r3, #0
 80056be:	d1e0      	bne.n	8005682 <_DrawBitmap+0xb2>
 80056c0:	e7e7      	b.n	8005692 <_DrawBitmap+0xc2>
 80056c2:	6820      	ldr	r0, [r4, #0]
 80056c4:	0e02      	lsrs	r2, r0, #24
 80056c6:	2aff      	cmp	r2, #255	; 0xff
 80056c8:	d005      	beq.n	80056d6 <_DrawBitmap+0x106>
 80056ca:	43d2      	mvns	r2, r2
 80056cc:	6829      	ldr	r1, [r5, #0]
 80056ce:	b2d2      	uxtb	r2, r2
 80056d0:	f001 fd20 	bl	8007114 <GUI__MixColors>
 80056d4:	6028      	str	r0, [r5, #0]
 80056d6:	3504      	adds	r5, #4
 80056d8:	3404      	adds	r4, #4
 80056da:	3f01      	subs	r7, #1
 80056dc:	2f00      	cmp	r7, #0
 80056de:	d1cc      	bne.n	800567a <_DrawBitmap+0xaa>
 80056e0:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 80056e2:	44bb      	add	fp, r7
 80056e4:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80056e6:	f109 0901 	add.w	r9, r9, #1
 80056ea:	443e      	add	r6, r7
 80056ec:	e7ac      	b.n	8005648 <_DrawBitmap+0x78>
 80056ee:	2800      	cmp	r0, #0
 80056f0:	f040 82fa 	bne.w	8005ce8 <_DrawBitmap+0x718>
 80056f4:	e2fb      	b.n	8005cee <_DrawBitmap+0x71e>
 80056f6:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 80056f8:	2f10      	cmp	r7, #16
 80056fa:	d137      	bne.n	800576c <_DrawBitmap+0x19c>
 80056fc:	1f06      	subs	r6, r0, #4
 80056fe:	2500      	movs	r5, #0
 8005700:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8005702:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 8005704:	42bd      	cmp	r5, r7
 8005706:	f280 809e 	bge.w	8005846 <_DrawBitmap+0x276>
 800570a:	9f07      	ldr	r7, [sp, #28]
 800570c:	442f      	add	r7, r5
 800570e:	b13c      	cbz	r4, 8005720 <_DrawBitmap+0x150>
 8005710:	68a3      	ldr	r3, [r4, #8]
 8005712:	9904      	ldr	r1, [sp, #16]
 8005714:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8005718:	4620      	mov	r0, r4
 800571a:	463a      	mov	r2, r7
 800571c:	4653      	mov	r3, sl
 800571e:	47e0      	blx	ip
 8005720:	f1ab 0302 	sub.w	r3, fp, #2
 8005724:	9306      	str	r3, [sp, #24]
 8005726:	9605      	str	r6, [sp, #20]
 8005728:	46d1      	mov	r9, sl
 800572a:	9904      	ldr	r1, [sp, #16]
 800572c:	f8d8 3010 	ldr.w	r3, [r8, #16]
 8005730:	9a06      	ldr	r2, [sp, #24]
 8005732:	685b      	ldr	r3, [r3, #4]
 8005734:	f832 0f02 	ldrh.w	r0, [r2, #2]!
 8005738:	9206      	str	r2, [sp, #24]
 800573a:	4451      	add	r1, sl
 800573c:	ebc9 0101 	rsb	r1, r9, r1
 8005740:	9103      	str	r1, [sp, #12]
 8005742:	4798      	blx	r3
 8005744:	9b05      	ldr	r3, [sp, #20]
 8005746:	9903      	ldr	r1, [sp, #12]
 8005748:	f843 0f04 	str.w	r0, [r3, #4]!
 800574c:	9305      	str	r3, [sp, #20]
 800574e:	b124      	cbz	r4, 800575a <_DrawBitmap+0x18a>
 8005750:	68a3      	ldr	r3, [r4, #8]
 8005752:	4620      	mov	r0, r4
 8005754:	681b      	ldr	r3, [r3, #0]
 8005756:	463a      	mov	r2, r7
 8005758:	4798      	blx	r3
 800575a:	f1b9 0901 	subs.w	r9, r9, #1
 800575e:	d1e4      	bne.n	800572a <_DrawBitmap+0x15a>
 8005760:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 8005762:	44bb      	add	fp, r7
 8005764:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8005766:	3501      	adds	r5, #1
 8005768:	443e      	add	r6, r7
 800576a:	e7c9      	b.n	8005700 <_DrawBitmap+0x130>
 800576c:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 800576e:	2f08      	cmp	r7, #8
 8005770:	f100 0604 	add.w	r6, r0, #4
 8005774:	d16e      	bne.n	8005854 <_DrawBitmap+0x284>
 8005776:	9f07      	ldr	r7, [sp, #28]
 8005778:	9a07      	ldr	r2, [sp, #28]
 800577a:	991a      	ldr	r1, [sp, #104]	; 0x68
 800577c:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
 800577e:	1abb      	subs	r3, r7, r2
 8005780:	428b      	cmp	r3, r1
 8005782:	f1a6 0004 	sub.w	r0, r6, #4
 8005786:	da5e      	bge.n	8005846 <_DrawBitmap+0x276>
 8005788:	4b31      	ldr	r3, [pc, #196]	; (8005850 <_DrawBitmap+0x280>)
 800578a:	681b      	ldr	r3, [r3, #0]
 800578c:	7c1b      	ldrb	r3, [r3, #16]
 800578e:	b36d      	cbz	r5, 80057ec <_DrawBitmap+0x21c>
 8005790:	f013 0303 	ands.w	r3, r3, #3
 8005794:	d005      	beq.n	80057a2 <_DrawBitmap+0x1d2>
 8005796:	2b02      	cmp	r3, #2
 8005798:	d14f      	bne.n	800583a <_DrawBitmap+0x26a>
 800579a:	46b1      	mov	r9, r6
 800579c:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80057a0:	e01c      	b.n	80057dc <_DrawBitmap+0x20c>
 80057a2:	f81b 2003 	ldrb.w	r2, [fp, r3]
 80057a6:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 80057aa:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
 80057ae:	3301      	adds	r3, #1
 80057b0:	4553      	cmp	r3, sl
 80057b2:	d1f6      	bne.n	80057a2 <_DrawBitmap+0x1d2>
 80057b4:	e041      	b.n	800583a <_DrawBitmap+0x26a>
 80057b6:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80057ba:	f849 3c04 	str.w	r3, [r9, #-4]
 80057be:	b12c      	cbz	r4, 80057cc <_DrawBitmap+0x1fc>
 80057c0:	68a3      	ldr	r3, [r4, #8]
 80057c2:	4620      	mov	r0, r4
 80057c4:	681b      	ldr	r3, [r3, #0]
 80057c6:	4641      	mov	r1, r8
 80057c8:	463a      	mov	r2, r7
 80057ca:	4798      	blx	r3
 80057cc:	9b04      	ldr	r3, [sp, #16]
 80057ce:	f108 0801 	add.w	r8, r8, #1
 80057d2:	4453      	add	r3, sl
 80057d4:	4543      	cmp	r3, r8
 80057d6:	f109 0904 	add.w	r9, r9, #4
 80057da:	d02e      	beq.n	800583a <_DrawBitmap+0x26a>
 80057dc:	9904      	ldr	r1, [sp, #16]
 80057de:	ebc1 030b 	rsb	r3, r1, fp
 80057e2:	f813 3008 	ldrb.w	r3, [r3, r8]
 80057e6:	2b00      	cmp	r3, #0
 80057e8:	d0f0      	beq.n	80057cc <_DrawBitmap+0x1fc>
 80057ea:	e7e4      	b.n	80057b6 <_DrawBitmap+0x1e6>
 80057ec:	f013 0303 	ands.w	r3, r3, #3
 80057f0:	d005      	beq.n	80057fe <_DrawBitmap+0x22e>
 80057f2:	2b02      	cmp	r3, #2
 80057f4:	d121      	bne.n	800583a <_DrawBitmap+0x26a>
 80057f6:	46b1      	mov	r9, r6
 80057f8:	f8dd 8010 	ldr.w	r8, [sp, #16]
 80057fc:	e015      	b.n	800582a <_DrawBitmap+0x25a>
 80057fe:	4659      	mov	r1, fp
 8005800:	4652      	mov	r2, sl
 8005802:	f003 fddf 	bl	80093c4 <memcpy>
 8005806:	e018      	b.n	800583a <_DrawBitmap+0x26a>
 8005808:	f849 3c04 	str.w	r3, [r9, #-4]
 800580c:	b12c      	cbz	r4, 800581a <_DrawBitmap+0x24a>
 800580e:	68a3      	ldr	r3, [r4, #8]
 8005810:	4620      	mov	r0, r4
 8005812:	681b      	ldr	r3, [r3, #0]
 8005814:	4641      	mov	r1, r8
 8005816:	463a      	mov	r2, r7
 8005818:	4798      	blx	r3
 800581a:	9b04      	ldr	r3, [sp, #16]
 800581c:	f108 0801 	add.w	r8, r8, #1
 8005820:	4453      	add	r3, sl
 8005822:	4543      	cmp	r3, r8
 8005824:	f109 0904 	add.w	r9, r9, #4
 8005828:	d007      	beq.n	800583a <_DrawBitmap+0x26a>
 800582a:	9a04      	ldr	r2, [sp, #16]
 800582c:	ebc2 030b 	rsb	r3, r2, fp
 8005830:	f813 3008 	ldrb.w	r3, [r3, r8]
 8005834:	2b00      	cmp	r3, #0
 8005836:	d0f0      	beq.n	800581a <_DrawBitmap+0x24a>
 8005838:	e7e6      	b.n	8005808 <_DrawBitmap+0x238>
 800583a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 800583c:	990a      	ldr	r1, [sp, #40]	; 0x28
 800583e:	449b      	add	fp, r3
 8005840:	3701      	adds	r7, #1
 8005842:	440e      	add	r6, r1
 8005844:	e798      	b.n	8005778 <_DrawBitmap+0x1a8>
 8005846:	2c00      	cmp	r4, #0
 8005848:	f040 824e 	bne.w	8005ce8 <_DrawBitmap+0x718>
 800584c:	e24f      	b.n	8005cee <_DrawBitmap+0x71e>
 800584e:	bf00      	nop
 8005850:	20000060 	.word	0x20000060
 8005854:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8005856:	4bb2      	ldr	r3, [pc, #712]	; (8005b20 <_DrawBitmap+0x550>)
 8005858:	9609      	str	r6, [sp, #36]	; 0x24
 800585a:	007f      	lsls	r7, r7, #1
 800585c:	970c      	str	r7, [sp, #48]	; 0x30
 800585e:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8005860:	00bf      	lsls	r7, r7, #2
 8005862:	970d      	str	r7, [sp, #52]	; 0x34
 8005864:	9f07      	ldr	r7, [sp, #28]
 8005866:	9705      	str	r7, [sp, #20]
 8005868:	2d00      	cmp	r5, #0
 800586a:	bf08      	it	eq
 800586c:	461d      	moveq	r5, r3
 800586e:	9f09      	ldr	r7, [sp, #36]	; 0x24
 8005870:	9907      	ldr	r1, [sp, #28]
 8005872:	1f3c      	subs	r4, r7, #4
 8005874:	9f05      	ldr	r7, [sp, #20]
 8005876:	1a7b      	subs	r3, r7, r1
 8005878:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 800587a:	42bb      	cmp	r3, r7
 800587c:	f280 8232 	bge.w	8005ce4 <_DrawBitmap+0x714>
 8005880:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 8005882:	2f02      	cmp	r7, #2
 8005884:	f000 80ad 	beq.w	80059e2 <_DrawBitmap+0x412>
 8005888:	2f04      	cmp	r7, #4
 800588a:	f000 814f 	beq.w	8005b2c <_DrawBitmap+0x55c>
 800588e:	2f01      	cmp	r7, #1
 8005890:	f040 821e 	bne.w	8005cd0 <_DrawBitmap+0x700>
 8005894:	f8df 9290 	ldr.w	r9, [pc, #656]	; 8005b28 <_DrawBitmap+0x558>
 8005898:	f8d9 3000 	ldr.w	r3, [r9]
 800589c:	6e18      	ldr	r0, [r3, #96]	; 0x60
 800589e:	f002 fcdb 	bl	8008258 <GUI_ALLOC_LockH>
 80058a2:	f89b 3000 	ldrb.w	r3, [fp]
 80058a6:	4a9f      	ldr	r2, [pc, #636]	; (8005b24 <_DrawBitmap+0x554>)
 80058a8:	991e      	ldr	r1, [sp, #120]	; 0x78
 80058aa:	5cd6      	ldrb	r6, [r2, r3]
 80058ac:	f8d9 3000 	ldr.w	r3, [r9]
 80058b0:	900e      	str	r0, [sp, #56]	; 0x38
 80058b2:	7c1b      	ldrb	r3, [r3, #16]
 80058b4:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
 80058b8:	f003 0303 	and.w	r3, r3, #3
 80058bc:	2b02      	cmp	r3, #2
 80058be:	4657      	mov	r7, sl
 80058c0:	f1c1 0808 	rsb	r8, r1, #8
 80058c4:	fa46 f601 	asr.w	r6, r6, r1
 80058c8:	d020      	beq.n	800590c <_DrawBitmap+0x33c>
 80058ca:	2b03      	cmp	r3, #3
 80058cc:	d061      	beq.n	8005992 <_DrawBitmap+0x3c2>
 80058ce:	2b01      	cmp	r3, #1
 80058d0:	d05f      	beq.n	8005992 <_DrawBitmap+0x3c2>
 80058d2:	465a      	mov	r2, fp
 80058d4:	4547      	cmp	r7, r8
 80058d6:	bf38      	it	cc
 80058d8:	46b8      	movcc	r8, r7
 80058da:	ebc8 0707 	rsb	r7, r8, r7
 80058de:	4643      	mov	r3, r8
 80058e0:	4621      	mov	r1, r4
 80058e2:	f006 0001 	and.w	r0, r6, #1
 80058e6:	3b01      	subs	r3, #1
 80058e8:	f855 0020 	ldr.w	r0, [r5, r0, lsl #2]
 80058ec:	f841 0b04 	str.w	r0, [r1], #4
 80058f0:	ea4f 0656 	mov.w	r6, r6, lsr #1
 80058f4:	d1f5      	bne.n	80058e2 <_DrawBitmap+0x312>
 80058f6:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 80058fa:	2f00      	cmp	r7, #0
 80058fc:	d06d      	beq.n	80059da <_DrawBitmap+0x40a>
 80058fe:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8005902:	4988      	ldr	r1, [pc, #544]	; (8005b24 <_DrawBitmap+0x554>)
 8005904:	f04f 0808 	mov.w	r8, #8
 8005908:	5cce      	ldrb	r6, [r1, r3]
 800590a:	e7e3      	b.n	80058d4 <_DrawBitmap+0x304>
 800590c:	686b      	ldr	r3, [r5, #4]
 800590e:	f8dd 9010 	ldr.w	r9, [sp, #16]
 8005912:	930b      	str	r3, [sp, #44]	; 0x2c
 8005914:	f8cd b020 	str.w	fp, [sp, #32]
 8005918:	4547      	cmp	r7, r8
 800591a:	bf38      	it	cc
 800591c:	46b8      	movcc	r8, r7
 800591e:	ebc8 0707 	rsb	r7, r8, r7
 8005922:	f1bc 0f00 	cmp.w	ip, #0
 8005926:	d026      	beq.n	8005976 <_DrawBitmap+0x3a6>
 8005928:	b91e      	cbnz	r6, 8005932 <_DrawBitmap+0x362>
 800592a:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 800592e:	44c1      	add	r9, r8
 8005930:	e025      	b.n	800597e <_DrawBitmap+0x3ae>
 8005932:	07f0      	lsls	r0, r6, #31
 8005934:	d50c      	bpl.n	8005950 <_DrawBitmap+0x380>
 8005936:	f8dc 3008 	ldr.w	r3, [ip, #8]
 800593a:	9a05      	ldr	r2, [sp, #20]
 800593c:	681b      	ldr	r3, [r3, #0]
 800593e:	f8cd c008 	str.w	ip, [sp, #8]
 8005942:	4660      	mov	r0, ip
 8005944:	4649      	mov	r1, r9
 8005946:	4798      	blx	r3
 8005948:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800594a:	f8dd c008 	ldr.w	ip, [sp, #8]
 800594e:	6023      	str	r3, [r4, #0]
 8005950:	f1b8 0801 	subs.w	r8, r8, #1
 8005954:	f109 0901 	add.w	r9, r9, #1
 8005958:	f104 0404 	add.w	r4, r4, #4
 800595c:	d00f      	beq.n	800597e <_DrawBitmap+0x3ae>
 800595e:	0876      	lsrs	r6, r6, #1
 8005960:	e7e2      	b.n	8005928 <_DrawBitmap+0x358>
 8005962:	07f1      	lsls	r1, r6, #31
 8005964:	bf44      	itt	mi
 8005966:	9b0b      	ldrmi	r3, [sp, #44]	; 0x2c
 8005968:	6023      	strmi	r3, [r4, #0]
 800596a:	f1b8 0801 	subs.w	r8, r8, #1
 800596e:	f104 0404 	add.w	r4, r4, #4
 8005972:	d004      	beq.n	800597e <_DrawBitmap+0x3ae>
 8005974:	0876      	lsrs	r6, r6, #1
 8005976:	2e00      	cmp	r6, #0
 8005978:	d1f3      	bne.n	8005962 <_DrawBitmap+0x392>
 800597a:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 800597e:	b367      	cbz	r7, 80059da <_DrawBitmap+0x40a>
 8005980:	9908      	ldr	r1, [sp, #32]
 8005982:	4a68      	ldr	r2, [pc, #416]	; (8005b24 <_DrawBitmap+0x554>)
 8005984:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 8005988:	9108      	str	r1, [sp, #32]
 800598a:	5cd6      	ldrb	r6, [r2, r3]
 800598c:	f04f 0808 	mov.w	r8, #8
 8005990:	e7c2      	b.n	8005918 <_DrawBitmap+0x348>
 8005992:	6803      	ldr	r3, [r0, #0]
 8005994:	691b      	ldr	r3, [r3, #16]
 8005996:	689b      	ldr	r3, [r3, #8]
 8005998:	4798      	blx	r3
 800599a:	4659      	mov	r1, fp
 800599c:	4547      	cmp	r7, r8
 800599e:	bf38      	it	cc
 80059a0:	46b8      	movcc	r8, r7
 80059a2:	ebc8 0707 	rsb	r7, r8, r7
 80059a6:	1d23      	adds	r3, r4, #4
 80059a8:	46c6      	mov	lr, r8
 80059aa:	07f2      	lsls	r2, r6, #31
 80059ac:	d504      	bpl.n	80059b8 <_DrawBitmap+0x3e8>
 80059ae:	f853 2c04 	ldr.w	r2, [r3, #-4]
 80059b2:	4042      	eors	r2, r0
 80059b4:	f843 2c04 	str.w	r2, [r3, #-4]
 80059b8:	f1be 0e01 	subs.w	lr, lr, #1
 80059bc:	ea4f 0656 	mov.w	r6, r6, lsr #1
 80059c0:	f103 0304 	add.w	r3, r3, #4
 80059c4:	d1f1      	bne.n	80059aa <_DrawBitmap+0x3da>
 80059c6:	eb04 0488 	add.w	r4, r4, r8, lsl #2
 80059ca:	b137      	cbz	r7, 80059da <_DrawBitmap+0x40a>
 80059cc:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 80059d0:	4a54      	ldr	r2, [pc, #336]	; (8005b24 <_DrawBitmap+0x554>)
 80059d2:	f04f 0808 	mov.w	r8, #8
 80059d6:	5cd6      	ldrb	r6, [r2, r3]
 80059d8:	e7e0      	b.n	800599c <_DrawBitmap+0x3cc>
 80059da:	a80e      	add	r0, sp, #56	; 0x38
 80059dc:	f002 fc4a 	bl	8008274 <GUI_ALLOC_UnlockH>
 80059e0:	e176      	b.n	8005cd0 <_DrawBitmap+0x700>
 80059e2:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 80059e4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80059e6:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
 80059ea:	f1c7 0604 	rsb	r6, r7, #4
 80059ee:	f89b 7000 	ldrb.w	r7, [fp]
 80059f2:	409f      	lsls	r7, r3
 80059f4:	4b4c      	ldr	r3, [pc, #304]	; (8005b28 <_DrawBitmap+0x558>)
 80059f6:	681b      	ldr	r3, [r3, #0]
 80059f8:	7c1b      	ldrb	r3, [r3, #16]
 80059fa:	f003 0303 	and.w	r3, r3, #3
 80059fe:	2b01      	cmp	r3, #1
 8005a00:	b2f6      	uxtb	r6, r6
 8005a02:	b2ff      	uxtb	r7, r7
 8005a04:	d066      	beq.n	8005ad4 <_DrawBitmap+0x504>
 8005a06:	d308      	bcc.n	8005a1a <_DrawBitmap+0x44a>
 8005a08:	2b02      	cmp	r3, #2
 8005a0a:	f040 8161 	bne.w	8005cd0 <_DrawBitmap+0x700>
 8005a0e:	9904      	ldr	r1, [sp, #16]
 8005a10:	f8cd b020 	str.w	fp, [sp, #32]
 8005a14:	46d0      	mov	r8, sl
 8005a16:	9106      	str	r1, [sp, #24]
 8005a18:	e03e      	b.n	8005a98 <_DrawBitmap+0x4c8>
 8005a1a:	465a      	mov	r2, fp
 8005a1c:	4653      	mov	r3, sl
 8005a1e:	429e      	cmp	r6, r3
 8005a20:	bfc8      	it	gt
 8005a22:	b2de      	uxtbgt	r6, r3
 8005a24:	1b9b      	subs	r3, r3, r6
 8005a26:	4631      	mov	r1, r6
 8005a28:	4620      	mov	r0, r4
 8005a2a:	ea4f 1c97 	mov.w	ip, r7, lsr #6
 8005a2e:	3901      	subs	r1, #1
 8005a30:	f855 c02c 	ldr.w	ip, [r5, ip, lsl #2]
 8005a34:	f840 cb04 	str.w	ip, [r0], #4
 8005a38:	00bf      	lsls	r7, r7, #2
 8005a3a:	f011 01ff 	ands.w	r1, r1, #255	; 0xff
 8005a3e:	b2ff      	uxtb	r7, r7
 8005a40:	d1f3      	bne.n	8005a2a <_DrawBitmap+0x45a>
 8005a42:	3e01      	subs	r6, #1
 8005a44:	b2f6      	uxtb	r6, r6
 8005a46:	3601      	adds	r6, #1
 8005a48:	eb04 0486 	add.w	r4, r4, r6, lsl #2
 8005a4c:	2b00      	cmp	r3, #0
 8005a4e:	f000 813f 	beq.w	8005cd0 <_DrawBitmap+0x700>
 8005a52:	f812 7f01 	ldrb.w	r7, [r2, #1]!
 8005a56:	2604      	movs	r6, #4
 8005a58:	e7e1      	b.n	8005a1e <_DrawBitmap+0x44e>
 8005a5a:	9906      	ldr	r1, [sp, #24]
 8005a5c:	f017 0fc0 	tst.w	r7, #192	; 0xc0
 8005a60:	4449      	add	r1, r9
 8005a62:	d122      	bne.n	8005aaa <_DrawBitmap+0x4da>
 8005a64:	f109 0901 	add.w	r9, r9, #1
 8005a68:	fa5f f289 	uxtb.w	r2, r9
 8005a6c:	00bf      	lsls	r7, r7, #2
 8005a6e:	4296      	cmp	r6, r2
 8005a70:	b2ff      	uxtb	r7, r7
 8005a72:	d1f2      	bne.n	8005a5a <_DrawBitmap+0x48a>
 8005a74:	9f06      	ldr	r7, [sp, #24]
 8005a76:	3e01      	subs	r6, #1
 8005a78:	b2f6      	uxtb	r6, r6
 8005a7a:	1c7b      	adds	r3, r7, #1
 8005a7c:	1c72      	adds	r2, r6, #1
 8005a7e:	199e      	adds	r6, r3, r6
 8005a80:	eb04 0482 	add.w	r4, r4, r2, lsl #2
 8005a84:	9606      	str	r6, [sp, #24]
 8005a86:	f1b8 0f00 	cmp.w	r8, #0
 8005a8a:	f000 8121 	beq.w	8005cd0 <_DrawBitmap+0x700>
 8005a8e:	9b08      	ldr	r3, [sp, #32]
 8005a90:	f813 7f01 	ldrb.w	r7, [r3, #1]!
 8005a94:	9308      	str	r3, [sp, #32]
 8005a96:	2604      	movs	r6, #4
 8005a98:	4546      	cmp	r6, r8
 8005a9a:	bfc8      	it	gt
 8005a9c:	fa5f f688 	uxtbgt.w	r6, r8
 8005aa0:	ebc6 0808 	rsb	r8, r6, r8
 8005aa4:	f04f 0900 	mov.w	r9, #0
 8005aa8:	e7d7      	b.n	8005a5a <_DrawBitmap+0x48a>
 8005aaa:	09ba      	lsrs	r2, r7, #6
 8005aac:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8005ab0:	f844 2029 	str.w	r2, [r4, r9, lsl #2]
 8005ab4:	f1bc 0f00 	cmp.w	ip, #0
 8005ab8:	d0d4      	beq.n	8005a64 <_DrawBitmap+0x494>
 8005aba:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8005abe:	6812      	ldr	r2, [r2, #0]
 8005ac0:	920b      	str	r2, [sp, #44]	; 0x2c
 8005ac2:	4660      	mov	r0, ip
 8005ac4:	f8cd c008 	str.w	ip, [sp, #8]
 8005ac8:	9a05      	ldr	r2, [sp, #20]
 8005aca:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8005acc:	4798      	blx	r3
 8005ace:	f8dd c008 	ldr.w	ip, [sp, #8]
 8005ad2:	e7c7      	b.n	8005a64 <_DrawBitmap+0x494>
 8005ad4:	4658      	mov	r0, fp
 8005ad6:	4653      	mov	r3, sl
 8005ad8:	429e      	cmp	r6, r3
 8005ada:	bfc8      	it	gt
 8005adc:	b2de      	uxtbgt	r6, r3
 8005ade:	1b9b      	subs	r3, r3, r6
 8005ae0:	1d22      	adds	r2, r4, #4
 8005ae2:	46b4      	mov	ip, r6
 8005ae4:	f017 0fc0 	tst.w	r7, #192	; 0xc0
 8005ae8:	d005      	beq.n	8005af6 <_DrawBitmap+0x526>
 8005aea:	f852 1c04 	ldr.w	r1, [r2, #-4]
 8005aee:	f081 01ff 	eor.w	r1, r1, #255	; 0xff
 8005af2:	f842 1c04 	str.w	r1, [r2, #-4]
 8005af6:	f10c 3cff 	add.w	ip, ip, #4294967295
 8005afa:	00bf      	lsls	r7, r7, #2
 8005afc:	f01c 0cff 	ands.w	ip, ip, #255	; 0xff
 8005b00:	b2ff      	uxtb	r7, r7
 8005b02:	f102 0204 	add.w	r2, r2, #4
 8005b06:	d1ed      	bne.n	8005ae4 <_DrawBitmap+0x514>
 8005b08:	3e01      	subs	r6, #1
 8005b0a:	b2f6      	uxtb	r6, r6
 8005b0c:	3601      	adds	r6, #1
 8005b0e:	eb04 0486 	add.w	r4, r4, r6, lsl #2
 8005b12:	2b00      	cmp	r3, #0
 8005b14:	f000 80dc 	beq.w	8005cd0 <_DrawBitmap+0x700>
 8005b18:	f810 7f01 	ldrb.w	r7, [r0, #1]!
 8005b1c:	2604      	movs	r6, #4
 8005b1e:	e7db      	b.n	8005ad8 <_DrawBitmap+0x508>
 8005b20:	08009bdc 	.word	0x08009bdc
 8005b24:	0800b36c 	.word	0x0800b36c
 8005b28:	20000060 	.word	0x20000060
 8005b2c:	4a71      	ldr	r2, [pc, #452]	; (8005cf4 <_DrawBitmap+0x724>)
 8005b2e:	f89b 3000 	ldrb.w	r3, [fp]
 8005b32:	6812      	ldr	r2, [r2, #0]
 8005b34:	990d      	ldr	r1, [sp, #52]	; 0x34
 8005b36:	7c12      	ldrb	r2, [r2, #16]
 8005b38:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
 8005b3a:	f002 0203 	and.w	r2, r2, #3
 8005b3e:	408b      	lsls	r3, r1
 8005b40:	2a01      	cmp	r2, #1
 8005b42:	b2de      	uxtb	r6, r3
 8005b44:	f000 809c 	beq.w	8005c80 <_DrawBitmap+0x6b0>
 8005b48:	d302      	bcc.n	8005b50 <_DrawBitmap+0x580>
 8005b4a:	2a02      	cmp	r2, #2
 8005b4c:	d035      	beq.n	8005bba <_DrawBitmap+0x5ea>
 8005b4e:	e0bf      	b.n	8005cd0 <_DrawBitmap+0x700>
 8005b50:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8005b52:	b15f      	cbz	r7, 8005b6c <_DrawBitmap+0x59c>
 8005b54:	0936      	lsrs	r6, r6, #4
 8005b56:	f10b 0201 	add.w	r2, fp, #1
 8005b5a:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
 8005b5e:	6023      	str	r3, [r4, #0]
 8005b60:	f89b 6001 	ldrb.w	r6, [fp, #1]
 8005b64:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8005b66:	f10a 33ff 	add.w	r3, sl, #4294967295
 8005b6a:	e001      	b.n	8005b70 <_DrawBitmap+0x5a0>
 8005b6c:	4653      	mov	r3, sl
 8005b6e:	465a      	mov	r2, fp
 8005b70:	2b01      	cmp	r3, #1
 8005b72:	dd1a      	ble.n	8005baa <_DrawBitmap+0x5da>
 8005b74:	1058      	asrs	r0, r3, #1
 8005b76:	f104 0108 	add.w	r1, r4, #8
 8005b7a:	f003 0301 	and.w	r3, r3, #1
 8005b7e:	eb02 0800 	add.w	r8, r2, r0
 8005b82:	ea4f 1c16 	mov.w	ip, r6, lsr #4
 8005b86:	f006 060f 	and.w	r6, r6, #15
 8005b8a:	f855 702c 	ldr.w	r7, [r5, ip, lsl #2]
 8005b8e:	f841 7c08 	str.w	r7, [r1, #-8]
 8005b92:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8005b96:	f841 6c04 	str.w	r6, [r1, #-4]
 8005b9a:	f812 6f01 	ldrb.w	r6, [r2, #1]!
 8005b9e:	4542      	cmp	r2, r8
 8005ba0:	f101 0108 	add.w	r1, r1, #8
 8005ba4:	d1ed      	bne.n	8005b82 <_DrawBitmap+0x5b2>
 8005ba6:	eb04 04c0 	add.w	r4, r4, r0, lsl #3
 8005baa:	2b00      	cmp	r3, #0
 8005bac:	f000 8090 	beq.w	8005cd0 <_DrawBitmap+0x700>
 8005bb0:	0936      	lsrs	r6, r6, #4
 8005bb2:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
 8005bb6:	6023      	str	r3, [r4, #0]
 8005bb8:	e08a      	b.n	8005cd0 <_DrawBitmap+0x700>
 8005bba:	991e      	ldr	r1, [sp, #120]	; 0x78
 8005bbc:	b1c1      	cbz	r1, 8005bf0 <_DrawBitmap+0x620>
 8005bbe:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8005bc2:	d00a      	beq.n	8005bda <_DrawBitmap+0x60a>
 8005bc4:	0936      	lsrs	r6, r6, #4
 8005bc6:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
 8005bca:	6023      	str	r3, [r4, #0]
 8005bcc:	b12f      	cbz	r7, 8005bda <_DrawBitmap+0x60a>
 8005bce:	68bb      	ldr	r3, [r7, #8]
 8005bd0:	9904      	ldr	r1, [sp, #16]
 8005bd2:	681b      	ldr	r3, [r3, #0]
 8005bd4:	9a05      	ldr	r2, [sp, #20]
 8005bd6:	4638      	mov	r0, r7
 8005bd8:	4798      	blx	r3
 8005bda:	9a04      	ldr	r2, [sp, #16]
 8005bdc:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8005bde:	f89b 6001 	ldrb.w	r6, [fp, #1]
 8005be2:	f102 0801 	add.w	r8, r2, #1
 8005be6:	f10a 3cff 	add.w	ip, sl, #4294967295
 8005bea:	f10b 0901 	add.w	r9, fp, #1
 8005bee:	e011      	b.n	8005c14 <_DrawBitmap+0x644>
 8005bf0:	46d4      	mov	ip, sl
 8005bf2:	46d9      	mov	r9, fp
 8005bf4:	f8dd 8010 	ldr.w	r8, [sp, #16]
 8005bf8:	e00c      	b.n	8005c14 <_DrawBitmap+0x644>
 8005bfa:	f016 0ff0 	tst.w	r6, #240	; 0xf0
 8005bfe:	d10d      	bne.n	8005c1c <_DrawBitmap+0x64c>
 8005c00:	f016 060f 	ands.w	r6, r6, #15
 8005c04:	d11b      	bne.n	8005c3e <_DrawBitmap+0x66e>
 8005c06:	f819 6f01 	ldrb.w	r6, [r9, #1]!
 8005c0a:	3408      	adds	r4, #8
 8005c0c:	f108 0802 	add.w	r8, r8, #2
 8005c10:	f1ac 0c02 	sub.w	ip, ip, #2
 8005c14:	f1bc 0f01 	cmp.w	ip, #1
 8005c18:	dcef      	bgt.n	8005bfa <_DrawBitmap+0x62a>
 8005c1a:	e021      	b.n	8005c60 <_DrawBitmap+0x690>
 8005c1c:	0933      	lsrs	r3, r6, #4
 8005c1e:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 8005c22:	6023      	str	r3, [r4, #0]
 8005c24:	2f00      	cmp	r7, #0
 8005c26:	d0eb      	beq.n	8005c00 <_DrawBitmap+0x630>
 8005c28:	68bb      	ldr	r3, [r7, #8]
 8005c2a:	9a05      	ldr	r2, [sp, #20]
 8005c2c:	681b      	ldr	r3, [r3, #0]
 8005c2e:	f8cd c008 	str.w	ip, [sp, #8]
 8005c32:	4638      	mov	r0, r7
 8005c34:	4641      	mov	r1, r8
 8005c36:	4798      	blx	r3
 8005c38:	f8dd c008 	ldr.w	ip, [sp, #8]
 8005c3c:	e7e0      	b.n	8005c00 <_DrawBitmap+0x630>
 8005c3e:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
 8005c42:	6063      	str	r3, [r4, #4]
 8005c44:	2f00      	cmp	r7, #0
 8005c46:	d0de      	beq.n	8005c06 <_DrawBitmap+0x636>
 8005c48:	68bb      	ldr	r3, [r7, #8]
 8005c4a:	9a05      	ldr	r2, [sp, #20]
 8005c4c:	681b      	ldr	r3, [r3, #0]
 8005c4e:	f8cd c008 	str.w	ip, [sp, #8]
 8005c52:	4638      	mov	r0, r7
 8005c54:	f108 0101 	add.w	r1, r8, #1
 8005c58:	4798      	blx	r3
 8005c5a:	f8dd c008 	ldr.w	ip, [sp, #8]
 8005c5e:	e7d2      	b.n	8005c06 <_DrawBitmap+0x636>
 8005c60:	f1bc 0f00 	cmp.w	ip, #0
 8005c64:	d034      	beq.n	8005cd0 <_DrawBitmap+0x700>
 8005c66:	0936      	lsrs	r6, r6, #4
 8005c68:	d032      	beq.n	8005cd0 <_DrawBitmap+0x700>
 8005c6a:	f855 3026 	ldr.w	r3, [r5, r6, lsl #2]
 8005c6e:	6023      	str	r3, [r4, #0]
 8005c70:	b377      	cbz	r7, 8005cd0 <_DrawBitmap+0x700>
 8005c72:	68bb      	ldr	r3, [r7, #8]
 8005c74:	9a05      	ldr	r2, [sp, #20]
 8005c76:	681b      	ldr	r3, [r3, #0]
 8005c78:	4638      	mov	r0, r7
 8005c7a:	4641      	mov	r1, r8
 8005c7c:	4798      	blx	r3
 8005c7e:	e027      	b.n	8005cd0 <_DrawBitmap+0x700>
 8005c80:	9f1e      	ldr	r7, [sp, #120]	; 0x78
 8005c82:	f1c7 0302 	rsb	r3, r7, #2
 8005c86:	b2db      	uxtb	r3, r3
 8005c88:	465f      	mov	r7, fp
 8005c8a:	4652      	mov	r2, sl
 8005c8c:	4293      	cmp	r3, r2
 8005c8e:	bfc8      	it	gt
 8005c90:	b2d3      	uxtbgt	r3, r2
 8005c92:	1ad2      	subs	r2, r2, r3
 8005c94:	1d20      	adds	r0, r4, #4
 8005c96:	469c      	mov	ip, r3
 8005c98:	f016 0fc0 	tst.w	r6, #192	; 0xc0
 8005c9c:	d005      	beq.n	8005caa <_DrawBitmap+0x6da>
 8005c9e:	f850 1c04 	ldr.w	r1, [r0, #-4]
 8005ca2:	f081 01ff 	eor.w	r1, r1, #255	; 0xff
 8005ca6:	f840 1c04 	str.w	r1, [r0, #-4]
 8005caa:	f10c 3cff 	add.w	ip, ip, #4294967295
 8005cae:	0136      	lsls	r6, r6, #4
 8005cb0:	f01c 0cff 	ands.w	ip, ip, #255	; 0xff
 8005cb4:	b2f6      	uxtb	r6, r6
 8005cb6:	f100 0004 	add.w	r0, r0, #4
 8005cba:	d1ed      	bne.n	8005c98 <_DrawBitmap+0x6c8>
 8005cbc:	3b01      	subs	r3, #1
 8005cbe:	b2db      	uxtb	r3, r3
 8005cc0:	3301      	adds	r3, #1
 8005cc2:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8005cc6:	b11a      	cbz	r2, 8005cd0 <_DrawBitmap+0x700>
 8005cc8:	f817 6f01 	ldrb.w	r6, [r7, #1]!
 8005ccc:	2302      	movs	r3, #2
 8005cce:	e7dd      	b.n	8005c8c <_DrawBitmap+0x6bc>
 8005cd0:	9b05      	ldr	r3, [sp, #20]
 8005cd2:	9f1c      	ldr	r7, [sp, #112]	; 0x70
 8005cd4:	3301      	adds	r3, #1
 8005cd6:	44bb      	add	fp, r7
 8005cd8:	9305      	str	r3, [sp, #20]
 8005cda:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8005cdc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005cde:	443b      	add	r3, r7
 8005ce0:	9309      	str	r3, [sp, #36]	; 0x24
 8005ce2:	e5c4      	b.n	800586e <_DrawBitmap+0x29e>
 8005ce4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8005ce6:	b113      	cbz	r3, 8005cee <_DrawBitmap+0x71e>
 8005ce8:	a80f      	add	r0, sp, #60	; 0x3c
 8005cea:	f002 fac3 	bl	8008274 <GUI_ALLOC_UnlockH>
 8005cee:	b011      	add	sp, #68	; 0x44
 8005cf0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005cf4:	20000060 	.word	0x20000060

08005cf8 <GUI_MEMDEV_Delete>:
 8005cf8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8005cfa:	4604      	mov	r4, r0
 8005cfc:	b1d0      	cbz	r0, 8005d34 <GUI_MEMDEV_Delete+0x3c>
 8005cfe:	4b0e      	ldr	r3, [pc, #56]	; (8005d38 <GUI_MEMDEV_Delete+0x40>)
 8005d00:	681b      	ldr	r3, [r3, #0]
 8005d02:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8005d04:	4283      	cmp	r3, r0
 8005d06:	d101      	bne.n	8005d0c <GUI_MEMDEV_Delete+0x14>
 8005d08:	f001 fbe8 	bl	80074dc <GUI_SelectLCD>
 8005d0c:	4620      	mov	r0, r4
 8005d0e:	f002 faa3 	bl	8008258 <GUI_ALLOC_LockH>
 8005d12:	9001      	str	r0, [sp, #4]
 8005d14:	6940      	ldr	r0, [r0, #20]
 8005d16:	b108      	cbz	r0, 8005d1c <GUI_MEMDEV_Delete+0x24>
 8005d18:	f002 fe9c 	bl	8008a54 <GUI_USAGE_DecUseCnt>
 8005d1c:	ad02      	add	r5, sp, #8
 8005d1e:	f855 3d04 	ldr.w	r3, [r5, #-4]!
 8005d22:	6818      	ldr	r0, [r3, #0]
 8005d24:	f001 fd74 	bl	8007810 <GUI_DEVICE_Delete>
 8005d28:	4628      	mov	r0, r5
 8005d2a:	f002 faa3 	bl	8008274 <GUI_ALLOC_UnlockH>
 8005d2e:	4620      	mov	r0, r4
 8005d30:	f002 fac0 	bl	80082b4 <GUI_ALLOC_Free>
 8005d34:	b003      	add	sp, #12
 8005d36:	bd30      	pop	{r4, r5, pc}
 8005d38:	20000060 	.word	0x20000060

08005d3c <_GetRect>:
 8005d3c:	6883      	ldr	r3, [r0, #8]
 8005d3e:	2200      	movs	r2, #0
 8005d40:	800a      	strh	r2, [r1, #0]
 8005d42:	804a      	strh	r2, [r1, #2]
 8005d44:	695a      	ldr	r2, [r3, #20]
 8005d46:	699b      	ldr	r3, [r3, #24]
 8005d48:	3a01      	subs	r2, #1
 8005d4a:	3b01      	subs	r3, #1
 8005d4c:	808a      	strh	r2, [r1, #4]
 8005d4e:	80cb      	strh	r3, [r1, #6]
 8005d50:	4770      	bx	lr

08005d52 <_SetPixelIndex>:
 8005d52:	b510      	push	{r4, lr}
 8005d54:	6880      	ldr	r0, [r0, #8]
 8005d56:	69c4      	ldr	r4, [r0, #28]
 8005d58:	6800      	ldr	r0, [r0, #0]
 8005d5a:	fb04 1202 	mla	r2, r4, r2, r1
 8005d5e:	f840 3022 	str.w	r3, [r0, r2, lsl #2]
 8005d62:	bd10      	pop	{r4, pc}

08005d64 <_GetPixelIndex>:
 8005d64:	6883      	ldr	r3, [r0, #8]
 8005d66:	69d8      	ldr	r0, [r3, #28]
 8005d68:	681b      	ldr	r3, [r3, #0]
 8005d6a:	fb00 1202 	mla	r2, r0, r2, r1
 8005d6e:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8005d72:	4770      	bx	lr

08005d74 <_XorPixel>:
 8005d74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005d78:	4604      	mov	r4, r0
 8005d7a:	460f      	mov	r7, r1
 8005d7c:	4616      	mov	r6, r2
 8005d7e:	f7ff fff1 	bl	8005d64 <_GetPixelIndex>
 8005d82:	6925      	ldr	r5, [r4, #16]
 8005d84:	68ab      	ldr	r3, [r5, #8]
 8005d86:	4680      	mov	r8, r0
 8005d88:	4798      	blx	r3
 8005d8a:	4639      	mov	r1, r7
 8005d8c:	ea80 0308 	eor.w	r3, r0, r8
 8005d90:	4632      	mov	r2, r6
 8005d92:	4620      	mov	r0, r4
 8005d94:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8005d98:	f7ff bfdb 	b.w	8005d52 <_SetPixelIndex>

08005d9c <_FillRect>:
 8005d9c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8005da0:	6886      	ldr	r6, [r0, #8]
 8005da2:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8005da4:	6b34      	ldr	r4, [r6, #48]	; 0x30
 8005da6:	f8df c114 	ldr.w	ip, [pc, #276]	; 8005ebc <_FillRect+0x120>
 8005daa:	4689      	mov	r9, r1
 8005dac:	4692      	mov	sl, r2
 8005dae:	b144      	cbz	r4, 8005dc2 <_FillRect+0x26>
 8005db0:	9700      	str	r7, [sp, #0]
 8005db2:	f8dc 5000 	ldr.w	r5, [ip]
 8005db6:	6bed      	ldr	r5, [r5, #60]	; 0x3c
 8005db8:	682d      	ldr	r5, [r5, #0]
 8005dba:	9501      	str	r5, [sp, #4]
 8005dbc:	6980      	ldr	r0, [r0, #24]
 8005dbe:	47a0      	blx	r4
 8005dc0:	e079      	b.n	8005eb6 <_FillRect+0x11a>
 8005dc2:	1a5b      	subs	r3, r3, r1
 8005dc4:	f8dc 1000 	ldr.w	r1, [ip]
 8005dc8:	f891 c010 	ldrb.w	ip, [r1, #16]
 8005dcc:	ebc2 0807 	rsb	r8, r2, r7
 8005dd0:	f01c 0c01 	ands.w	ip, ip, #1
 8005dd4:	f103 0401 	add.w	r4, r3, #1
 8005dd8:	f108 0501 	add.w	r5, r8, #1
 8005ddc:	69f7      	ldr	r7, [r6, #28]
 8005dde:	d021      	beq.n	8005e24 <_FillRect+0x88>
 8005de0:	6903      	ldr	r3, [r0, #16]
 8005de2:	689b      	ldr	r3, [r3, #8]
 8005de4:	4798      	blx	r3
 8005de6:	69f2      	ldr	r2, [r6, #28]
 8005de8:	2c00      	cmp	r4, #0
 8005dea:	d064      	beq.n	8005eb6 <_FillRect+0x11a>
 8005dec:	f06f 0c03 	mvn.w	ip, #3
 8005df0:	fb02 990a 	mla	r9, r2, sl, r9
 8005df4:	fb0c fc07 	mul.w	ip, ip, r7
 8005df8:	fb07 9708 	mla	r7, r7, r8, r9
 8005dfc:	00bf      	lsls	r7, r7, #2
 8005dfe:	2d00      	cmp	r5, #0
 8005e00:	d059      	beq.n	8005eb6 <_FillRect+0x11a>
 8005e02:	3d01      	subs	r5, #1
 8005e04:	463b      	mov	r3, r7
 8005e06:	4622      	mov	r2, r4
 8005e08:	f8d6 8000 	ldr.w	r8, [r6]
 8005e0c:	f853 1008 	ldr.w	r1, [r3, r8]
 8005e10:	3a01      	subs	r2, #1
 8005e12:	ea81 0100 	eor.w	r1, r1, r0
 8005e16:	f843 1008 	str.w	r1, [r3, r8]
 8005e1a:	f103 0304 	add.w	r3, r3, #4
 8005e1e:	d1f3      	bne.n	8005e08 <_FillRect+0x6c>
 8005e20:	4467      	add	r7, ip
 8005e22:	e7ec      	b.n	8005dfe <_FillRect+0x62>
 8005e24:	6830      	ldr	r0, [r6, #0]
 8005e26:	6bc9      	ldr	r1, [r1, #60]	; 0x3c
 8005e28:	fb07 9202 	mla	r2, r7, r2, r9
 8005e2c:	2c0f      	cmp	r4, #15
 8005e2e:	eb00 0282 	add.w	r2, r0, r2, lsl #2
 8005e32:	6808      	ldr	r0, [r1, #0]
 8005e34:	d92f      	bls.n	8005e96 <_FillRect+0xfa>
 8005e36:	f1a3 0a0f 	sub.w	sl, r3, #15
 8005e3a:	ea4f 1a1a 	mov.w	sl, sl, lsr #4
 8005e3e:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8005e42:	f108 4180 	add.w	r1, r8, #1073741824	; 0x40000000
 8005e46:	f10a 0a01 	add.w	sl, sl, #1
 8005e4a:	fb09 2101 	mla	r1, r9, r1, r2
 8005e4e:	ea4f 1a8a 	mov.w	sl, sl, lsl #6
 8005e52:	462e      	mov	r6, r5
 8005e54:	4662      	mov	r2, ip
 8005e56:	b1e6      	cbz	r6, 8005e92 <_FillRect+0xf6>
 8005e58:	4622      	mov	r2, r4
 8005e5a:	460b      	mov	r3, r1
 8005e5c:	3a10      	subs	r2, #16
 8005e5e:	2a0f      	cmp	r2, #15
 8005e60:	6018      	str	r0, [r3, #0]
 8005e62:	6058      	str	r0, [r3, #4]
 8005e64:	6098      	str	r0, [r3, #8]
 8005e66:	60d8      	str	r0, [r3, #12]
 8005e68:	6118      	str	r0, [r3, #16]
 8005e6a:	6158      	str	r0, [r3, #20]
 8005e6c:	6198      	str	r0, [r3, #24]
 8005e6e:	61d8      	str	r0, [r3, #28]
 8005e70:	6218      	str	r0, [r3, #32]
 8005e72:	6258      	str	r0, [r3, #36]	; 0x24
 8005e74:	6298      	str	r0, [r3, #40]	; 0x28
 8005e76:	62d8      	str	r0, [r3, #44]	; 0x2c
 8005e78:	6318      	str	r0, [r3, #48]	; 0x30
 8005e7a:	6358      	str	r0, [r3, #52]	; 0x34
 8005e7c:	6398      	str	r0, [r3, #56]	; 0x38
 8005e7e:	63d8      	str	r0, [r3, #60]	; 0x3c
 8005e80:	f103 0340 	add.w	r3, r3, #64	; 0x40
 8005e84:	d8ea      	bhi.n	8005e5c <_FillRect+0xc0>
 8005e86:	eb01 020a 	add.w	r2, r1, sl
 8005e8a:	3e01      	subs	r6, #1
 8005e8c:	ebc9 0101 	rsb	r1, r9, r1
 8005e90:	e7e1      	b.n	8005e56 <_FillRect+0xba>
 8005e92:	f004 040f 	and.w	r4, r4, #15
 8005e96:	b174      	cbz	r4, 8005eb6 <_FillRect+0x11a>
 8005e98:	00bf      	lsls	r7, r7, #2
 8005e9a:	f108 4880 	add.w	r8, r8, #1073741824	; 0x40000000
 8005e9e:	fb07 2208 	mla	r2, r7, r8, r2
 8005ea2:	b145      	cbz	r5, 8005eb6 <_FillRect+0x11a>
 8005ea4:	4611      	mov	r1, r2
 8005ea6:	4623      	mov	r3, r4
 8005ea8:	3b01      	subs	r3, #1
 8005eaa:	f841 0b04 	str.w	r0, [r1], #4
 8005eae:	d1fb      	bne.n	8005ea8 <_FillRect+0x10c>
 8005eb0:	3d01      	subs	r5, #1
 8005eb2:	1bd2      	subs	r2, r2, r7
 8005eb4:	e7f5      	b.n	8005ea2 <_FillRect+0x106>
 8005eb6:	b002      	add	sp, #8
 8005eb8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005ebc:	20000060 	.word	0x20000060

08005ec0 <_DrawHLine>:
 8005ec0:	b507      	push	{r0, r1, r2, lr}
 8005ec2:	9200      	str	r2, [sp, #0]
 8005ec4:	f7ff ff6a 	bl	8005d9c <_FillRect>
 8005ec8:	b003      	add	sp, #12
 8005eca:	f85d fb04 	ldr.w	pc, [sp], #4

08005ece <_DrawVLine>:
 8005ece:	b507      	push	{r0, r1, r2, lr}
 8005ed0:	9300      	str	r3, [sp, #0]
 8005ed2:	460b      	mov	r3, r1
 8005ed4:	f7ff ff62 	bl	8005d9c <_FillRect>
 8005ed8:	b003      	add	sp, #12
 8005eda:	f85d fb04 	ldr.w	pc, [sp], #4

08005ede <_GetDevProp>:
 8005ede:	3901      	subs	r1, #1
 8005ee0:	6883      	ldr	r3, [r0, #8]
 8005ee2:	290d      	cmp	r1, #13
 8005ee4:	d814      	bhi.n	8005f10 <_GetDevProp+0x32>
 8005ee6:	e8df f001 	tbb	[pc, r1]
 8005eea:	0b09      	.short	0x0b09
 8005eec:	13130f0d 	.word	0x13130f0d
 8005ef0:	11160713 	.word	0x11160713
 8005ef4:	16161611 	.word	0x16161611
 8005ef8:	2020      	movs	r0, #32
 8005efa:	4770      	bx	lr
 8005efc:	68d8      	ldr	r0, [r3, #12]
 8005efe:	4770      	bx	lr
 8005f00:	6918      	ldr	r0, [r3, #16]
 8005f02:	4770      	bx	lr
 8005f04:	6958      	ldr	r0, [r3, #20]
 8005f06:	4770      	bx	lr
 8005f08:	6998      	ldr	r0, [r3, #24]
 8005f0a:	4770      	bx	lr
 8005f0c:	2001      	movs	r0, #1
 8005f0e:	4770      	bx	lr
 8005f10:	f04f 30ff 	mov.w	r0, #4294967295
 8005f14:	4770      	bx	lr
 8005f16:	2000      	movs	r0, #0
 8005f18:	4770      	bx	lr
	...

08005f1c <_GetDevData>:
 8005f1c:	4802      	ldr	r0, [pc, #8]	; (8005f28 <_GetDevData+0xc>)
 8005f1e:	2901      	cmp	r1, #1
 8005f20:	bf18      	it	ne
 8005f22:	2000      	movne	r0, #0
 8005f24:	4770      	bx	lr
 8005f26:	bf00      	nop
 8005f28:	08009c1c 	.word	0x08009c1c

08005f2c <_ReadRect>:
 8005f2c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005f30:	460f      	mov	r7, r1
 8005f32:	6881      	ldr	r1, [r0, #8]
 8005f34:	69c8      	ldr	r0, [r1, #28]
 8005f36:	f06f 0903 	mvn.w	r9, #3
 8005f3a:	fb00 7502 	mla	r5, r0, r2, r7
 8005f3e:	1bdb      	subs	r3, r3, r7
 8005f40:	00ae      	lsls	r6, r5, #2
 8005f42:	fb09 fc00 	mul.w	ip, r9, r0
 8005f46:	fb09 f505 	mul.w	r5, r9, r5
 8005f4a:	f103 0901 	add.w	r9, r3, #1
 8005f4e:	ea4f 0880 	mov.w	r8, r0, lsl #2
 8005f52:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8005f56:	1c5f      	adds	r7, r3, #1
 8005f58:	4630      	mov	r0, r6
 8005f5a:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 8005f5e:	680c      	ldr	r4, [r1, #0]
 8005f60:	44aa      	add	sl, r5
 8005f62:	f850 b004 	ldr.w	fp, [r0, r4]
 8005f66:	f84a b000 	str.w	fp, [sl, r0]
 8005f6a:	3f01      	subs	r7, #1
 8005f6c:	f100 0004 	add.w	r0, r0, #4
 8005f70:	d1f3      	bne.n	8005f5a <_ReadRect+0x2e>
 8005f72:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8005f74:	444c      	add	r4, r9
 8005f76:	940a      	str	r4, [sp, #40]	; 0x28
 8005f78:	3201      	adds	r2, #1
 8005f7a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8005f7c:	1e50      	subs	r0, r2, #1
 8005f7e:	42a0      	cmp	r0, r4
 8005f80:	4446      	add	r6, r8
 8005f82:	4465      	add	r5, ip
 8005f84:	dbe7      	blt.n	8005f56 <_ReadRect+0x2a>
 8005f86:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08005f8c <_GetDevFunc>:
 8005f8c:	3901      	subs	r1, #1
 8005f8e:	2924      	cmp	r1, #36	; 0x24
 8005f90:	d844      	bhi.n	800601c <_GetDevFunc+0x90>
 8005f92:	e8df f001 	tbb	[pc, r1]
 8005f96:	1b41      	.short	0x1b41
 8005f98:	1d431917 	.word	0x1d431917
 8005f9c:	45134343 	.word	0x45134343
 8005fa0:	21431f15 	.word	0x21431f15
 8005fa4:	43434323 	.word	0x43434323
 8005fa8:	2f292725 	.word	0x2f292725
 8005fac:	43314343 	.word	0x43314343
 8005fb0:	43434343 	.word	0x43434343
 8005fb4:	2d2b3543 	.word	0x2d2b3543
 8005fb8:	433d      	.short	0x433d
 8005fba:	39          	.byte	0x39
 8005fbb:	00          	.byte	0x00
 8005fbc:	4819      	ldr	r0, [pc, #100]	; (8006024 <_GetDevFunc+0x98>)
 8005fbe:	4770      	bx	lr
 8005fc0:	4819      	ldr	r0, [pc, #100]	; (8006028 <_GetDevFunc+0x9c>)
 8005fc2:	4770      	bx	lr
 8005fc4:	4819      	ldr	r0, [pc, #100]	; (800602c <_GetDevFunc+0xa0>)
 8005fc6:	4770      	bx	lr
 8005fc8:	4819      	ldr	r0, [pc, #100]	; (8006030 <_GetDevFunc+0xa4>)
 8005fca:	4770      	bx	lr
 8005fcc:	4819      	ldr	r0, [pc, #100]	; (8006034 <_GetDevFunc+0xa8>)
 8005fce:	4770      	bx	lr
 8005fd0:	4819      	ldr	r0, [pc, #100]	; (8006038 <_GetDevFunc+0xac>)
 8005fd2:	4770      	bx	lr
 8005fd4:	4819      	ldr	r0, [pc, #100]	; (800603c <_GetDevFunc+0xb0>)
 8005fd6:	4770      	bx	lr
 8005fd8:	4819      	ldr	r0, [pc, #100]	; (8006040 <_GetDevFunc+0xb4>)
 8005fda:	4770      	bx	lr
 8005fdc:	4819      	ldr	r0, [pc, #100]	; (8006044 <_GetDevFunc+0xb8>)
 8005fde:	4770      	bx	lr
 8005fe0:	4819      	ldr	r0, [pc, #100]	; (8006048 <_GetDevFunc+0xbc>)
 8005fe2:	4770      	bx	lr
 8005fe4:	4819      	ldr	r0, [pc, #100]	; (800604c <_GetDevFunc+0xc0>)
 8005fe6:	4770      	bx	lr
 8005fe8:	4819      	ldr	r0, [pc, #100]	; (8006050 <_GetDevFunc+0xc4>)
 8005fea:	4770      	bx	lr
 8005fec:	4819      	ldr	r0, [pc, #100]	; (8006054 <_GetDevFunc+0xc8>)
 8005fee:	4770      	bx	lr
 8005ff0:	4819      	ldr	r0, [pc, #100]	; (8006058 <_GetDevFunc+0xcc>)
 8005ff2:	4770      	bx	lr
 8005ff4:	4819      	ldr	r0, [pc, #100]	; (800605c <_GetDevFunc+0xd0>)
 8005ff6:	4770      	bx	lr
 8005ff8:	6803      	ldr	r3, [r0, #0]
 8005ffa:	689b      	ldr	r3, [r3, #8]
 8005ffc:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8005ffe:	4770      	bx	lr
 8006000:	6803      	ldr	r3, [r0, #0]
 8006002:	689b      	ldr	r3, [r3, #8]
 8006004:	6b98      	ldr	r0, [r3, #56]	; 0x38
 8006006:	4770      	bx	lr
 8006008:	6803      	ldr	r3, [r0, #0]
 800600a:	689b      	ldr	r3, [r3, #8]
 800600c:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 800600e:	4770      	bx	lr
 8006010:	6803      	ldr	r3, [r0, #0]
 8006012:	689b      	ldr	r3, [r3, #8]
 8006014:	6c18      	ldr	r0, [r3, #64]	; 0x40
 8006016:	4770      	bx	lr
 8006018:	4811      	ldr	r0, [pc, #68]	; (8006060 <_GetDevFunc+0xd4>)
 800601a:	4770      	bx	lr
 800601c:	2000      	movs	r0, #0
 800601e:	4770      	bx	lr
 8006020:	4810      	ldr	r0, [pc, #64]	; (8006064 <_GetDevFunc+0xd8>)
 8006022:	4770      	bx	lr
 8006024:	08006725 	.word	0x08006725
 8006028:	080067a1 	.word	0x080067a1
 800602c:	080066f7 	.word	0x080066f7
 8006030:	0800664b 	.word	0x0800664b
 8006034:	080066cf 	.word	0x080066cf
 8006038:	080066a7 	.word	0x080066a7
 800603c:	0800668d 	.word	0x0800668d
 8006040:	080060b5 	.word	0x080060b5
 8006044:	080060ab 	.word	0x080060ab
 8006048:	08006095 	.word	0x08006095
 800604c:	0800607f 	.word	0x0800607f
 8006050:	08006069 	.word	0x08006069
 8006054:	0800674f 	.word	0x0800674f
 8006058:	08006667 	.word	0x08006667
 800605c:	08006605 	.word	0x08006605
 8006060:	08005f2d 	.word	0x08005f2d
 8006064:	080067e3 	.word	0x080067e3

08006068 <_SetChroma>:
 8006068:	b507      	push	{r0, r1, r2, lr}
 800606a:	6980      	ldr	r0, [r0, #24]
 800606c:	e88d 0006 	stmia.w	sp, {r1, r2}
 8006070:	210d      	movs	r1, #13
 8006072:	466a      	mov	r2, sp
 8006074:	f7fe fa48 	bl	8004508 <LCD_X_DisplayDriver>
 8006078:	b003      	add	sp, #12
 800607a:	f85d fb04 	ldr.w	pc, [sp], #4

0800607e <_SetChromaMode>:
 800607e:	b507      	push	{r0, r1, r2, lr}
 8006080:	aa02      	add	r2, sp, #8
 8006082:	6980      	ldr	r0, [r0, #24]
 8006084:	f842 1d04 	str.w	r1, [r2, #-4]!
 8006088:	210c      	movs	r1, #12
 800608a:	f7fe fa3d 	bl	8004508 <LCD_X_DisplayDriver>
 800608e:	b003      	add	sp, #12
 8006090:	f85d fb04 	ldr.w	pc, [sp], #4

08006094 <_SetAlphaMode>:
 8006094:	b507      	push	{r0, r1, r2, lr}
 8006096:	aa02      	add	r2, sp, #8
 8006098:	6980      	ldr	r0, [r0, #24]
 800609a:	f842 1d04 	str.w	r1, [r2, #-4]!
 800609e:	210b      	movs	r1, #11
 80060a0:	f7fe fa32 	bl	8004508 <LCD_X_DisplayDriver>
 80060a4:	b003      	add	sp, #12
 80060a6:	f85d fb04 	ldr.w	pc, [sp], #4

080060aa <_Off>:
 80060aa:	6980      	ldr	r0, [r0, #24]
 80060ac:	2106      	movs	r1, #6
 80060ae:	2200      	movs	r2, #0
 80060b0:	f7fe ba2a 	b.w	8004508 <LCD_X_DisplayDriver>

080060b4 <_On>:
 80060b4:	6980      	ldr	r0, [r0, #24]
 80060b6:	2105      	movs	r1, #5
 80060b8:	2200      	movs	r2, #0
 80060ba:	f7fe ba25 	b.w	8004508 <LCD_X_DisplayDriver>

080060be <_SetOrg>:
 80060be:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80060c2:	2300      	movs	r3, #0
 80060c4:	4607      	mov	r7, r0
 80060c6:	6884      	ldr	r4, [r0, #8]
 80060c8:	6980      	ldr	r0, [r0, #24]
 80060ca:	9300      	str	r3, [sp, #0]
 80060cc:	460d      	mov	r5, r1
 80060ce:	4616      	mov	r6, r2
 80060d0:	9301      	str	r3, [sp, #4]
 80060d2:	f000 fc7d 	bl	80069d0 <LCD_GetMirrorXEx>
 80060d6:	4680      	mov	r8, r0
 80060d8:	69b8      	ldr	r0, [r7, #24]
 80060da:	f000 fc7c 	bl	80069d6 <LCD_GetMirrorYEx>
 80060de:	4681      	mov	r9, r0
 80060e0:	69b8      	ldr	r0, [r7, #24]
 80060e2:	f000 fc7b 	bl	80069dc <LCD_GetSwapXYEx>
 80060e6:	0080      	lsls	r0, r0, #2
 80060e8:	ea40 0049 	orr.w	r0, r0, r9, lsl #1
 80060ec:	ea40 0008 	orr.w	r0, r0, r8
 80060f0:	2807      	cmp	r0, #7
 80060f2:	d826      	bhi.n	8006142 <_SetOrg+0x84>
 80060f4:	e8df f000 	tbb	[pc, r0]
 80060f8:	0b0f0408 	.word	0x0b0f0408
 80060fc:	1b1f1519 	.word	0x1b1f1519
 8006100:	6962      	ldr	r2, [r4, #20]
 8006102:	68e3      	ldr	r3, [r4, #12]
 8006104:	1ad3      	subs	r3, r2, r3
 8006106:	1b5d      	subs	r5, r3, r5
 8006108:	9500      	str	r5, [sp, #0]
 800610a:	9601      	str	r6, [sp, #4]
 800610c:	e019      	b.n	8006142 <_SetOrg+0x84>
 800610e:	6962      	ldr	r2, [r4, #20]
 8006110:	68e3      	ldr	r3, [r4, #12]
 8006112:	1ad3      	subs	r3, r2, r3
 8006114:	1b5d      	subs	r5, r3, r5
 8006116:	69a2      	ldr	r2, [r4, #24]
 8006118:	6923      	ldr	r3, [r4, #16]
 800611a:	9500      	str	r5, [sp, #0]
 800611c:	1ad3      	subs	r3, r2, r3
 800611e:	1b9e      	subs	r6, r3, r6
 8006120:	e7f3      	b.n	800610a <_SetOrg+0x4c>
 8006122:	69a2      	ldr	r2, [r4, #24]
 8006124:	6923      	ldr	r3, [r4, #16]
 8006126:	1ad3      	subs	r3, r2, r3
 8006128:	1b9e      	subs	r6, r3, r6
 800612a:	9600      	str	r6, [sp, #0]
 800612c:	e008      	b.n	8006140 <_SetOrg+0x82>
 800612e:	69a2      	ldr	r2, [r4, #24]
 8006130:	6923      	ldr	r3, [r4, #16]
 8006132:	1ad3      	subs	r3, r2, r3
 8006134:	1b9e      	subs	r6, r3, r6
 8006136:	6962      	ldr	r2, [r4, #20]
 8006138:	68e3      	ldr	r3, [r4, #12]
 800613a:	9600      	str	r6, [sp, #0]
 800613c:	1ad3      	subs	r3, r2, r3
 800613e:	1b5d      	subs	r5, r3, r5
 8006140:	9501      	str	r5, [sp, #4]
 8006142:	69b8      	ldr	r0, [r7, #24]
 8006144:	2103      	movs	r1, #3
 8006146:	466a      	mov	r2, sp
 8006148:	f7fe f9de 	bl	8004508 <LCD_X_DisplayDriver>
 800614c:	b003      	add	sp, #12
 800614e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

08006154 <_DrawBitmap>:
 8006154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006158:	b08d      	sub	sp, #52	; 0x34
 800615a:	4606      	mov	r6, r0
 800615c:	9817      	ldr	r0, [sp, #92]	; 0x5c
 800615e:	910a      	str	r1, [sp, #40]	; 0x28
 8006160:	2804      	cmp	r0, #4
 8006162:	469b      	mov	fp, r3
 8006164:	9209      	str	r2, [sp, #36]	; 0x24
 8006166:	9c19      	ldr	r4, [sp, #100]	; 0x64
 8006168:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
 800616a:	68b3      	ldr	r3, [r6, #8]
 800616c:	d011      	beq.n	8006192 <_DrawBitmap+0x3e>
 800616e:	dc09      	bgt.n	8006184 <_DrawBitmap+0x30>
 8006170:	2801      	cmp	r0, #1
 8006172:	d013      	beq.n	800619c <_DrawBitmap+0x48>
 8006174:	2802      	cmp	r0, #2
 8006176:	f040 822d 	bne.w	80065d4 <_DrawBitmap+0x480>
 800617a:	4aab      	ldr	r2, [pc, #684]	; (8006428 <_DrawBitmap+0x2d4>)
 800617c:	6812      	ldr	r2, [r2, #0]
 800617e:	920b      	str	r2, [sp, #44]	; 0x2c
 8006180:	2100      	movs	r1, #0
 8006182:	e0b8      	b.n	80062f6 <_DrawBitmap+0x1a2>
 8006184:	2808      	cmp	r0, #8
 8006186:	f000 8172 	beq.w	800646e <_DrawBitmap+0x31a>
 800618a:	2820      	cmp	r0, #32
 800618c:	f000 81fb 	beq.w	8006586 <_DrawBitmap+0x432>
 8006190:	e220      	b.n	80065d4 <_DrawBitmap+0x480>
 8006192:	4aa5      	ldr	r2, [pc, #660]	; (8006428 <_DrawBitmap+0x2d4>)
 8006194:	6812      	ldr	r2, [r2, #0]
 8006196:	920b      	str	r2, [sp, #44]	; 0x2c
 8006198:	2100      	movs	r1, #0
 800619a:	e10a      	b.n	80063b2 <_DrawBitmap+0x25e>
 800619c:	6b9f      	ldr	r7, [r3, #56]	; 0x38
 800619e:	b90f      	cbnz	r7, 80061a4 <_DrawBitmap+0x50>
 80061a0:	9f09      	ldr	r7, [sp, #36]	; 0x24
 80061a2:	e042      	b.n	800622a <_DrawBitmap+0xd6>
 80061a4:	4ba0      	ldr	r3, [pc, #640]	; (8006428 <_DrawBitmap+0x2d4>)
 80061a6:	681b      	ldr	r3, [r3, #0]
 80061a8:	7c1b      	ldrb	r3, [r3, #16]
 80061aa:	07db      	lsls	r3, r3, #31
 80061ac:	d4f8      	bmi.n	80061a0 <_DrawBitmap+0x4c>
 80061ae:	981a      	ldr	r0, [sp, #104]	; 0x68
 80061b0:	9b16      	ldr	r3, [sp, #88]	; 0x58
 80061b2:	9302      	str	r3, [sp, #8]
 80061b4:	e88d 0801 	stmia.w	sp, {r0, fp}
 80061b8:	9818      	ldr	r0, [sp, #96]	; 0x60
 80061ba:	9003      	str	r0, [sp, #12]
 80061bc:	9504      	str	r5, [sp, #16]
 80061be:	69b0      	ldr	r0, [r6, #24]
 80061c0:	4623      	mov	r3, r4
 80061c2:	47b8      	blx	r7
 80061c4:	e206      	b.n	80065d4 <_DrawBitmap+0x480>
 80061c6:	4b98      	ldr	r3, [pc, #608]	; (8006428 <_DrawBitmap+0x2d4>)
 80061c8:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
 80061cc:	681b      	ldr	r3, [r3, #0]
 80061ce:	991a      	ldr	r1, [sp, #104]	; 0x68
 80061d0:	7c1b      	ldrb	r3, [r3, #16]
 80061d2:	f8d5 c000 	ldr.w	ip, [r5]
 80061d6:	f8d5 9004 	ldr.w	r9, [r5, #4]
 80061da:	68b0      	ldr	r0, [r6, #8]
 80061dc:	f003 0303 	and.w	r3, r3, #3
 80061e0:	2b02      	cmp	r3, #2
 80061e2:	448a      	add	sl, r1
 80061e4:	d02d      	beq.n	8006242 <_DrawBitmap+0xee>
 80061e6:	2b03      	cmp	r3, #3
 80061e8:	d04d      	beq.n	8006286 <_DrawBitmap+0x132>
 80061ea:	2b01      	cmp	r3, #1
 80061ec:	d04b      	beq.n	8006286 <_DrawBitmap+0x132>
 80061ee:	f1c1 0308 	rsb	r3, r1, #8
 80061f2:	7822      	ldrb	r2, [r4, #0]
 80061f4:	498d      	ldr	r1, [pc, #564]	; (800642c <_DrawBitmap+0x2d8>)
 80061f6:	5c8a      	ldrb	r2, [r1, r2]
 80061f8:	991a      	ldr	r1, [sp, #104]	; 0x68
 80061fa:	410a      	asrs	r2, r1
 80061fc:	69c1      	ldr	r1, [r0, #28]
 80061fe:	6800      	ldr	r0, [r0, #0]
 8006200:	fb01 a107 	mla	r1, r1, r7, sl
 8006204:	eb00 0a81 	add.w	sl, r0, r1, lsl #2
 8006208:	4659      	mov	r1, fp
 800620a:	4620      	mov	r0, r4
 800620c:	f012 0f01 	tst.w	r2, #1
 8006210:	bf0c      	ite	eq
 8006212:	46e0      	moveq	r8, ip
 8006214:	46c8      	movne	r8, r9
 8006216:	3b01      	subs	r3, #1
 8006218:	d00d      	beq.n	8006236 <_DrawBitmap+0xe2>
 800621a:	0852      	lsrs	r2, r2, #1
 800621c:	3901      	subs	r1, #1
 800621e:	f84a 8b04 	str.w	r8, [sl], #4
 8006222:	d1f3      	bne.n	800620c <_DrawBitmap+0xb8>
 8006224:	9a18      	ldr	r2, [sp, #96]	; 0x60
 8006226:	3701      	adds	r7, #1
 8006228:	4414      	add	r4, r2
 800622a:	9809      	ldr	r0, [sp, #36]	; 0x24
 800622c:	9916      	ldr	r1, [sp, #88]	; 0x58
 800622e:	1a3b      	subs	r3, r7, r0
 8006230:	428b      	cmp	r3, r1
 8006232:	dbc8      	blt.n	80061c6 <_DrawBitmap+0x72>
 8006234:	e1ce      	b.n	80065d4 <_DrawBitmap+0x480>
 8006236:	7843      	ldrb	r3, [r0, #1]
 8006238:	4a7c      	ldr	r2, [pc, #496]	; (800642c <_DrawBitmap+0x2d8>)
 800623a:	3001      	adds	r0, #1
 800623c:	5cd2      	ldrb	r2, [r2, r3]
 800623e:	2308      	movs	r3, #8
 8006240:	e7ec      	b.n	800621c <_DrawBitmap+0xc8>
 8006242:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8006244:	4979      	ldr	r1, [pc, #484]	; (800642c <_DrawBitmap+0x2d8>)
 8006246:	f1c2 0308 	rsb	r3, r2, #8
 800624a:	7822      	ldrb	r2, [r4, #0]
 800624c:	5c89      	ldrb	r1, [r1, r2]
 800624e:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8006250:	4111      	asrs	r1, r2
 8006252:	69c2      	ldr	r2, [r0, #28]
 8006254:	6800      	ldr	r0, [r0, #0]
 8006256:	fb02 a207 	mla	r2, r2, r7, sl
 800625a:	eb00 0a82 	add.w	sl, r0, r2, lsl #2
 800625e:	4622      	mov	r2, r4
 8006260:	2000      	movs	r0, #0
 8006262:	f011 0f01 	tst.w	r1, #1
 8006266:	bf18      	it	ne
 8006268:	f84a 9020 	strne.w	r9, [sl, r0, lsl #2]
 800626c:	3b01      	subs	r3, #1
 800626e:	d001      	beq.n	8006274 <_DrawBitmap+0x120>
 8006270:	0849      	lsrs	r1, r1, #1
 8006272:	e004      	b.n	800627e <_DrawBitmap+0x12a>
 8006274:	7853      	ldrb	r3, [r2, #1]
 8006276:	496d      	ldr	r1, [pc, #436]	; (800642c <_DrawBitmap+0x2d8>)
 8006278:	3201      	adds	r2, #1
 800627a:	5cc9      	ldrb	r1, [r1, r3]
 800627c:	2308      	movs	r3, #8
 800627e:	3001      	adds	r0, #1
 8006280:	4558      	cmp	r0, fp
 8006282:	d1ee      	bne.n	8006262 <_DrawBitmap+0x10e>
 8006284:	e7ce      	b.n	8006224 <_DrawBitmap+0xd0>
 8006286:	6933      	ldr	r3, [r6, #16]
 8006288:	689b      	ldr	r3, [r3, #8]
 800628a:	4798      	blx	r3
 800628c:	f8dd 8068 	ldr.w	r8, [sp, #104]	; 0x68
 8006290:	900b      	str	r0, [sp, #44]	; 0x2c
 8006292:	46d9      	mov	r9, fp
 8006294:	46a4      	mov	ip, r4
 8006296:	f89c 1000 	ldrb.w	r1, [ip]
 800629a:	2280      	movs	r2, #128	; 0x80
 800629c:	fa42 f208 	asr.w	r2, r2, r8
 80062a0:	eb0a 030b 	add.w	r3, sl, fp
 80062a4:	4211      	tst	r1, r2
 80062a6:	ebc9 0303 	rsb	r3, r9, r3
 80062aa:	d013      	beq.n	80062d4 <_DrawBitmap+0x180>
 80062ac:	4619      	mov	r1, r3
 80062ae:	463a      	mov	r2, r7
 80062b0:	4630      	mov	r0, r6
 80062b2:	f8cd c01c 	str.w	ip, [sp, #28]
 80062b6:	9308      	str	r3, [sp, #32]
 80062b8:	f7ff fd54 	bl	8005d64 <_GetPixelIndex>
 80062bc:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80062be:	9b08      	ldr	r3, [sp, #32]
 80062c0:	ea80 0e01 	eor.w	lr, r0, r1
 80062c4:	463a      	mov	r2, r7
 80062c6:	4619      	mov	r1, r3
 80062c8:	4630      	mov	r0, r6
 80062ca:	4673      	mov	r3, lr
 80062cc:	f7ff fd41 	bl	8005d52 <_SetPixelIndex>
 80062d0:	f8dd c01c 	ldr.w	ip, [sp, #28]
 80062d4:	f108 0801 	add.w	r8, r8, #1
 80062d8:	f1b8 0f08 	cmp.w	r8, #8
 80062dc:	bf04      	itt	eq
 80062de:	f10c 0c01 	addeq.w	ip, ip, #1
 80062e2:	f04f 0800 	moveq.w	r8, #0
 80062e6:	f1b9 0901 	subs.w	r9, r9, #1
 80062ea:	d1d4      	bne.n	8006296 <_DrawBitmap+0x142>
 80062ec:	e79a      	b.n	8006224 <_DrawBitmap+0xd0>
 80062ee:	b935      	cbnz	r5, 80062fe <_DrawBitmap+0x1aa>
 80062f0:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80062f2:	3101      	adds	r1, #1
 80062f4:	443c      	add	r4, r7
 80062f6:	9f16      	ldr	r7, [sp, #88]	; 0x58
 80062f8:	42b9      	cmp	r1, r7
 80062fa:	dbf8      	blt.n	80062ee <_DrawBitmap+0x19a>
 80062fc:	e16a      	b.n	80065d4 <_DrawBitmap+0x480>
 80062fe:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 8006302:	980a      	ldr	r0, [sp, #40]	; 0x28
 8006304:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8006306:	69da      	ldr	r2, [r3, #28]
 8006308:	7826      	ldrb	r6, [r4, #0]
 800630a:	4438      	add	r0, r7
 800630c:	4488      	add	r8, r1
 800630e:	fb02 0808 	mla	r8, r2, r8, r0
 8006312:	681a      	ldr	r2, [r3, #0]
 8006314:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8006316:	eb02 0888 	add.w	r8, r2, r8, lsl #2
 800631a:	7c02      	ldrb	r2, [r0, #16]
 800631c:	f012 0203 	ands.w	r2, r2, #3
 8006320:	46c4      	mov	ip, r8
 8006322:	d005      	beq.n	8006330 <_DrawBitmap+0x1dc>
 8006324:	2a02      	cmp	r2, #2
 8006326:	d1e3      	bne.n	80062f0 <_DrawBitmap+0x19c>
 8006328:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 800632a:	9406      	str	r4, [sp, #24]
 800632c:	2000      	movs	r0, #0
 800632e:	e020      	b.n	8006372 <_DrawBitmap+0x21e>
 8006330:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 8006332:	4658      	mov	r0, fp
 8006334:	4627      	mov	r7, r4
 8006336:	f1c2 0803 	rsb	r8, r2, #3
 800633a:	ea4f 0848 	mov.w	r8, r8, lsl #1
 800633e:	f1c8 0906 	rsb	r9, r8, #6
 8006342:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
 8006346:	fa4a f909 	asr.w	r9, sl, r9
 800634a:	ea09 0906 	and.w	r9, r9, r6
 800634e:	fa29 f808 	lsr.w	r8, r9, r8
 8006352:	3201      	adds	r2, #1
 8006354:	f855 8028 	ldr.w	r8, [r5, r8, lsl #2]
 8006358:	f84c 8b04 	str.w	r8, [ip], #4
 800635c:	2a04      	cmp	r2, #4
 800635e:	d102      	bne.n	8006366 <_DrawBitmap+0x212>
 8006360:	787e      	ldrb	r6, [r7, #1]
 8006362:	2200      	movs	r2, #0
 8006364:	3701      	adds	r7, #1
 8006366:	3801      	subs	r0, #1
 8006368:	d1e5      	bne.n	8006336 <_DrawBitmap+0x1e2>
 800636a:	e7c1      	b.n	80062f0 <_DrawBitmap+0x19c>
 800636c:	3001      	adds	r0, #1
 800636e:	4558      	cmp	r0, fp
 8006370:	d0be      	beq.n	80062f0 <_DrawBitmap+0x19c>
 8006372:	f1c2 0c03 	rsb	ip, r2, #3
 8006376:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 800637a:	f1cc 0906 	rsb	r9, ip, #6
 800637e:	f04f 0ac0 	mov.w	sl, #192	; 0xc0
 8006382:	fa4a f909 	asr.w	r9, sl, r9
 8006386:	ea09 0906 	and.w	r9, r9, r6
 800638a:	fa39 fc0c 	lsrs.w	ip, r9, ip
 800638e:	bf1c      	itt	ne
 8006390:	f855 702c 	ldrne.w	r7, [r5, ip, lsl #2]
 8006394:	f848 7020 	strne.w	r7, [r8, r0, lsl #2]
 8006398:	3201      	adds	r2, #1
 800639a:	2a04      	cmp	r2, #4
 800639c:	d1e6      	bne.n	800636c <_DrawBitmap+0x218>
 800639e:	9a06      	ldr	r2, [sp, #24]
 80063a0:	7856      	ldrb	r6, [r2, #1]
 80063a2:	3201      	adds	r2, #1
 80063a4:	9206      	str	r2, [sp, #24]
 80063a6:	2200      	movs	r2, #0
 80063a8:	e7e0      	b.n	800636c <_DrawBitmap+0x218>
 80063aa:	b935      	cbnz	r5, 80063ba <_DrawBitmap+0x266>
 80063ac:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80063ae:	3101      	adds	r1, #1
 80063b0:	443c      	add	r4, r7
 80063b2:	9f16      	ldr	r7, [sp, #88]	; 0x58
 80063b4:	42b9      	cmp	r1, r7
 80063b6:	dbf8      	blt.n	80063aa <_DrawBitmap+0x256>
 80063b8:	e10c      	b.n	80065d4 <_DrawBitmap+0x480>
 80063ba:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
 80063be:	980a      	ldr	r0, [sp, #40]	; 0x28
 80063c0:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 80063c2:	69da      	ldr	r2, [r3, #28]
 80063c4:	7826      	ldrb	r6, [r4, #0]
 80063c6:	4438      	add	r0, r7
 80063c8:	4488      	add	r8, r1
 80063ca:	fb02 0808 	mla	r8, r2, r8, r0
 80063ce:	681a      	ldr	r2, [r3, #0]
 80063d0:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80063d2:	eb02 0888 	add.w	r8, r2, r8, lsl #2
 80063d6:	7c02      	ldrb	r2, [r0, #16]
 80063d8:	f012 0203 	ands.w	r2, r2, #3
 80063dc:	46c4      	mov	ip, r8
 80063de:	d005      	beq.n	80063ec <_DrawBitmap+0x298>
 80063e0:	2a02      	cmp	r2, #2
 80063e2:	d1e3      	bne.n	80063ac <_DrawBitmap+0x258>
 80063e4:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80063e6:	9406      	str	r4, [sp, #24]
 80063e8:	2000      	movs	r0, #0
 80063ea:	e024      	b.n	8006436 <_DrawBitmap+0x2e2>
 80063ec:	9a1a      	ldr	r2, [sp, #104]	; 0x68
 80063ee:	4658      	mov	r0, fp
 80063f0:	4627      	mov	r7, r4
 80063f2:	f1c2 0801 	rsb	r8, r2, #1
 80063f6:	ea4f 0888 	mov.w	r8, r8, lsl #2
 80063fa:	f1c8 0904 	rsb	r9, r8, #4
 80063fe:	f04f 0af0 	mov.w	sl, #240	; 0xf0
 8006402:	fa4a f909 	asr.w	r9, sl, r9
 8006406:	ea09 0906 	and.w	r9, r9, r6
 800640a:	fa29 f808 	lsr.w	r8, r9, r8
 800640e:	3201      	adds	r2, #1
 8006410:	f855 8028 	ldr.w	r8, [r5, r8, lsl #2]
 8006414:	f84c 8b04 	str.w	r8, [ip], #4
 8006418:	2a02      	cmp	r2, #2
 800641a:	d102      	bne.n	8006422 <_DrawBitmap+0x2ce>
 800641c:	787e      	ldrb	r6, [r7, #1]
 800641e:	2200      	movs	r2, #0
 8006420:	3701      	adds	r7, #1
 8006422:	3801      	subs	r0, #1
 8006424:	d1e5      	bne.n	80063f2 <_DrawBitmap+0x29e>
 8006426:	e7c1      	b.n	80063ac <_DrawBitmap+0x258>
 8006428:	20000060 	.word	0x20000060
 800642c:	0800b36c 	.word	0x0800b36c
 8006430:	3001      	adds	r0, #1
 8006432:	4558      	cmp	r0, fp
 8006434:	d0ba      	beq.n	80063ac <_DrawBitmap+0x258>
 8006436:	f1c2 0c01 	rsb	ip, r2, #1
 800643a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 800643e:	f1cc 0904 	rsb	r9, ip, #4
 8006442:	f04f 0af0 	mov.w	sl, #240	; 0xf0
 8006446:	fa4a f909 	asr.w	r9, sl, r9
 800644a:	ea09 0906 	and.w	r9, r9, r6
 800644e:	fa39 fc0c 	lsrs.w	ip, r9, ip
 8006452:	bf1c      	itt	ne
 8006454:	f855 702c 	ldrne.w	r7, [r5, ip, lsl #2]
 8006458:	f848 7020 	strne.w	r7, [r8, r0, lsl #2]
 800645c:	3201      	adds	r2, #1
 800645e:	2a02      	cmp	r2, #2
 8006460:	d1e6      	bne.n	8006430 <_DrawBitmap+0x2dc>
 8006462:	9a06      	ldr	r2, [sp, #24]
 8006464:	7856      	ldrb	r6, [r2, #1]
 8006466:	3201      	adds	r2, #1
 8006468:	9206      	str	r2, [sp, #24]
 800646a:	2200      	movs	r2, #0
 800646c:	e7e0      	b.n	8006430 <_DrawBitmap+0x2dc>
 800646e:	6bdf      	ldr	r7, [r3, #60]	; 0x3c
 8006470:	f8df c168 	ldr.w	ip, [pc, #360]	; 80065dc <_DrawBitmap+0x488>
 8006474:	b127      	cbz	r7, 8006480 <_DrawBitmap+0x32c>
 8006476:	f8dc 0000 	ldr.w	r0, [ip]
 800647a:	7c00      	ldrb	r0, [r0, #16]
 800647c:	0780      	lsls	r0, r0, #30
 800647e:	d504      	bpl.n	800648a <_DrawBitmap+0x336>
 8006480:	f8dc c000 	ldr.w	ip, [ip]
 8006484:	f04f 0900 	mov.w	r9, #0
 8006488:	e011      	b.n	80064ae <_DrawBitmap+0x35a>
 800648a:	2d00      	cmp	r5, #0
 800648c:	d0f8      	beq.n	8006480 <_DrawBitmap+0x32c>
 800648e:	9816      	ldr	r0, [sp, #88]	; 0x58
 8006490:	9b18      	ldr	r3, [sp, #96]	; 0x60
 8006492:	9302      	str	r3, [sp, #8]
 8006494:	f8cd b000 	str.w	fp, [sp]
 8006498:	9001      	str	r0, [sp, #4]
 800649a:	9503      	str	r5, [sp, #12]
 800649c:	69b0      	ldr	r0, [r6, #24]
 800649e:	4623      	mov	r3, r4
 80064a0:	47b8      	blx	r7
 80064a2:	e097      	b.n	80065d4 <_DrawBitmap+0x480>
 80064a4:	b93d      	cbnz	r5, 80064b6 <_DrawBitmap+0x362>
 80064a6:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80064a8:	f109 0901 	add.w	r9, r9, #1
 80064ac:	443c      	add	r4, r7
 80064ae:	9f16      	ldr	r7, [sp, #88]	; 0x58
 80064b0:	45b9      	cmp	r9, r7
 80064b2:	dbf7      	blt.n	80064a4 <_DrawBitmap+0x350>
 80064b4:	e08e      	b.n	80065d4 <_DrawBitmap+0x480>
 80064b6:	9809      	ldr	r0, [sp, #36]	; 0x24
 80064b8:	69da      	ldr	r2, [r3, #28]
 80064ba:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 80064bc:	4448      	add	r0, r9
 80064be:	fb02 7000 	mla	r0, r2, r0, r7
 80064c2:	681a      	ldr	r2, [r3, #0]
 80064c4:	eb02 0080 	add.w	r0, r2, r0, lsl #2
 80064c8:	f89c 2010 	ldrb.w	r2, [ip, #16]
 80064cc:	f012 0203 	ands.w	r2, r2, #3
 80064d0:	4601      	mov	r1, r0
 80064d2:	d003      	beq.n	80064dc <_DrawBitmap+0x388>
 80064d4:	2a02      	cmp	r2, #2
 80064d6:	d1e6      	bne.n	80064a6 <_DrawBitmap+0x352>
 80064d8:	2100      	movs	r1, #0
 80064da:	e04f      	b.n	800657c <_DrawBitmap+0x428>
 80064dc:	4658      	mov	r0, fp
 80064de:	4622      	mov	r2, r4
 80064e0:	2807      	cmp	r0, #7
 80064e2:	dd23      	ble.n	800652c <_DrawBitmap+0x3d8>
 80064e4:	7816      	ldrb	r6, [r2, #0]
 80064e6:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 80064ea:	600e      	str	r6, [r1, #0]
 80064ec:	7856      	ldrb	r6, [r2, #1]
 80064ee:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 80064f2:	604e      	str	r6, [r1, #4]
 80064f4:	7896      	ldrb	r6, [r2, #2]
 80064f6:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 80064fa:	608e      	str	r6, [r1, #8]
 80064fc:	78d6      	ldrb	r6, [r2, #3]
 80064fe:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8006502:	60ce      	str	r6, [r1, #12]
 8006504:	7916      	ldrb	r6, [r2, #4]
 8006506:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 800650a:	610e      	str	r6, [r1, #16]
 800650c:	7956      	ldrb	r6, [r2, #5]
 800650e:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8006512:	614e      	str	r6, [r1, #20]
 8006514:	7996      	ldrb	r6, [r2, #6]
 8006516:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 800651a:	618e      	str	r6, [r1, #24]
 800651c:	79d6      	ldrb	r6, [r2, #7]
 800651e:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8006522:	61ce      	str	r6, [r1, #28]
 8006524:	3808      	subs	r0, #8
 8006526:	3208      	adds	r2, #8
 8006528:	3120      	adds	r1, #32
 800652a:	e7d9      	b.n	80064e0 <_DrawBitmap+0x38c>
 800652c:	2803      	cmp	r0, #3
 800652e:	dd13      	ble.n	8006558 <_DrawBitmap+0x404>
 8006530:	7816      	ldrb	r6, [r2, #0]
 8006532:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8006536:	600e      	str	r6, [r1, #0]
 8006538:	7856      	ldrb	r6, [r2, #1]
 800653a:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 800653e:	604e      	str	r6, [r1, #4]
 8006540:	7896      	ldrb	r6, [r2, #2]
 8006542:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 8006546:	608e      	str	r6, [r1, #8]
 8006548:	78d6      	ldrb	r6, [r2, #3]
 800654a:	f855 6026 	ldr.w	r6, [r5, r6, lsl #2]
 800654e:	60ce      	str	r6, [r1, #12]
 8006550:	3804      	subs	r0, #4
 8006552:	3204      	adds	r2, #4
 8006554:	3110      	adds	r1, #16
 8006556:	e7e9      	b.n	800652c <_DrawBitmap+0x3d8>
 8006558:	2600      	movs	r6, #0
 800655a:	4286      	cmp	r6, r0
 800655c:	d0a3      	beq.n	80064a6 <_DrawBitmap+0x352>
 800655e:	f812 8006 	ldrb.w	r8, [r2, r6]
 8006562:	f855 7028 	ldr.w	r7, [r5, r8, lsl #2]
 8006566:	f841 7026 	str.w	r7, [r1, r6, lsl #2]
 800656a:	3601      	adds	r6, #1
 800656c:	e7f5      	b.n	800655a <_DrawBitmap+0x406>
 800656e:	5c62      	ldrb	r2, [r4, r1]
 8006570:	b11a      	cbz	r2, 800657a <_DrawBitmap+0x426>
 8006572:	f855 2022 	ldr.w	r2, [r5, r2, lsl #2]
 8006576:	f840 2021 	str.w	r2, [r0, r1, lsl #2]
 800657a:	3101      	adds	r1, #1
 800657c:	ebc1 020b 	rsb	r2, r1, fp
 8006580:	2a00      	cmp	r2, #0
 8006582:	dcf4      	bgt.n	800656e <_DrawBitmap+0x41a>
 8006584:	e78f      	b.n	80064a6 <_DrawBitmap+0x352>
 8006586:	6c5d      	ldr	r5, [r3, #68]	; 0x44
 8006588:	b90d      	cbnz	r5, 800658e <_DrawBitmap+0x43a>
 800658a:	462b      	mov	r3, r5
 800658c:	e012      	b.n	80065b4 <_DrawBitmap+0x460>
 800658e:	9f16      	ldr	r7, [sp, #88]	; 0x58
 8006590:	9701      	str	r7, [sp, #4]
 8006592:	9f18      	ldr	r7, [sp, #96]	; 0x60
 8006594:	f8cd b000 	str.w	fp, [sp]
 8006598:	9702      	str	r7, [sp, #8]
 800659a:	69b0      	ldr	r0, [r6, #24]
 800659c:	4623      	mov	r3, r4
 800659e:	47a8      	blx	r5
 80065a0:	e018      	b.n	80065d4 <_DrawBitmap+0x480>
 80065a2:	f851 7f04 	ldr.w	r7, [r1, #4]!
 80065a6:	1b0d      	subs	r5, r1, r4
 80065a8:	3a01      	subs	r2, #1
 80065aa:	502f      	str	r7, [r5, r0]
 80065ac:	d1f9      	bne.n	80065a2 <_DrawBitmap+0x44e>
 80065ae:	9f18      	ldr	r7, [sp, #96]	; 0x60
 80065b0:	3301      	adds	r3, #1
 80065b2:	443c      	add	r4, r7
 80065b4:	9d16      	ldr	r5, [sp, #88]	; 0x58
 80065b6:	42ab      	cmp	r3, r5
 80065b8:	da0c      	bge.n	80065d4 <_DrawBitmap+0x480>
 80065ba:	68b2      	ldr	r2, [r6, #8]
 80065bc:	9809      	ldr	r0, [sp, #36]	; 0x24
 80065be:	69d1      	ldr	r1, [r2, #28]
 80065c0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80065c2:	6812      	ldr	r2, [r2, #0]
 80065c4:	4418      	add	r0, r3
 80065c6:	fb01 5100 	mla	r1, r1, r0, r5
 80065ca:	eb02 0081 	add.w	r0, r2, r1, lsl #2
 80065ce:	1f21      	subs	r1, r4, #4
 80065d0:	465a      	mov	r2, fp
 80065d2:	e7e6      	b.n	80065a2 <_DrawBitmap+0x44e>
 80065d4:	b00d      	add	sp, #52	; 0x34
 80065d6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80065da:	bf00      	nop
 80065dc:	20000060 	.word	0x20000060

080065e0 <_InitOnce.isra.4>:
 80065e0:	b538      	push	{r3, r4, r5, lr}
 80065e2:	6805      	ldr	r5, [r0, #0]
 80065e4:	4604      	mov	r4, r0
 80065e6:	b93d      	cbnz	r5, 80065f8 <_InitOnce.isra.4+0x18>
 80065e8:	2048      	movs	r0, #72	; 0x48
 80065ea:	f001 ff81 	bl	80084f0 <GUI_ALLOC_GetFixedBlock>
 80065ee:	4629      	mov	r1, r5
 80065f0:	6020      	str	r0, [r4, #0]
 80065f2:	2248      	movs	r2, #72	; 0x48
 80065f4:	f000 fca0 	bl	8006f38 <GUI__memset>
 80065f8:	6820      	ldr	r0, [r4, #0]
 80065fa:	f1d0 0001 	rsbs	r0, r0, #1
 80065fe:	bf38      	it	cc
 8006600:	2000      	movcc	r0, #0
 8006602:	bd38      	pop	{r3, r4, r5, pc}

08006604 <_SetDevFunc>:
 8006604:	b570      	push	{r4, r5, r6, lr}
 8006606:	4605      	mov	r5, r0
 8006608:	3008      	adds	r0, #8
 800660a:	460e      	mov	r6, r1
 800660c:	4614      	mov	r4, r2
 800660e:	f7ff ffe7 	bl	80065e0 <_InitOnce.isra.4>
 8006612:	68ab      	ldr	r3, [r5, #8]
 8006614:	b1c3      	cbz	r3, 8006648 <_SetDevFunc+0x44>
 8006616:	f1a6 0119 	sub.w	r1, r6, #25
 800661a:	290f      	cmp	r1, #15
 800661c:	d814      	bhi.n	8006648 <_SetDevFunc+0x44>
 800661e:	e8df f001 	tbb	[pc, r1]
 8006622:	1308      	.short	0x1308
 8006624:	13131313 	.word	0x13131313
 8006628:	130a0c13 	.word	0x130a0c13
 800662c:	130e1310 	.word	0x130e1310
 8006630:	1213      	.short	0x1213
 8006632:	631c      	str	r4, [r3, #48]	; 0x30
 8006634:	bd70      	pop	{r4, r5, r6, pc}
 8006636:	635c      	str	r4, [r3, #52]	; 0x34
 8006638:	bd70      	pop	{r4, r5, r6, pc}
 800663a:	639c      	str	r4, [r3, #56]	; 0x38
 800663c:	bd70      	pop	{r4, r5, r6, pc}
 800663e:	63dc      	str	r4, [r3, #60]	; 0x3c
 8006640:	bd70      	pop	{r4, r5, r6, pc}
 8006642:	641c      	str	r4, [r3, #64]	; 0x40
 8006644:	bd70      	pop	{r4, r5, r6, pc}
 8006646:	645c      	str	r4, [r3, #68]	; 0x44
 8006648:	bd70      	pop	{r4, r5, r6, pc}

0800664a <_GetPos>:
 800664a:	b570      	push	{r4, r5, r6, lr}
 800664c:	4604      	mov	r4, r0
 800664e:	3008      	adds	r0, #8
 8006650:	460d      	mov	r5, r1
 8006652:	4616      	mov	r6, r2
 8006654:	f7ff ffc4 	bl	80065e0 <_InitOnce.isra.4>
 8006658:	68a3      	ldr	r3, [r4, #8]
 800665a:	b11b      	cbz	r3, 8006664 <_GetPos+0x1a>
 800665c:	6a18      	ldr	r0, [r3, #32]
 800665e:	6028      	str	r0, [r5, #0]
 8006660:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006662:	6033      	str	r3, [r6, #0]
 8006664:	bd70      	pop	{r4, r5, r6, pc}

08006666 <_ShowBuffer>:
 8006666:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006668:	4604      	mov	r4, r0
 800666a:	2300      	movs	r3, #0
 800666c:	3008      	adds	r0, #8
 800666e:	9301      	str	r3, [sp, #4]
 8006670:	460d      	mov	r5, r1
 8006672:	f7ff ffb5 	bl	80065e0 <_InitOnce.isra.4>
 8006676:	68a3      	ldr	r3, [r4, #8]
 8006678:	b133      	cbz	r3, 8006688 <_ShowBuffer+0x22>
 800667a:	aa02      	add	r2, sp, #8
 800667c:	69a0      	ldr	r0, [r4, #24]
 800667e:	f842 5d04 	str.w	r5, [r2, #-4]!
 8006682:	210e      	movs	r1, #14
 8006684:	f7fd ff40 	bl	8004508 <LCD_X_DisplayDriver>
 8006688:	b003      	add	sp, #12
 800668a:	bd30      	pop	{r4, r5, pc}

0800668c <_Init>:
 800668c:	b538      	push	{r3, r4, r5, lr}
 800668e:	4604      	mov	r4, r0
 8006690:	3008      	adds	r0, #8
 8006692:	f7ff ffa5 	bl	80065e0 <_InitOnce.isra.4>
 8006696:	2101      	movs	r1, #1
 8006698:	4605      	mov	r5, r0
 800669a:	2200      	movs	r2, #0
 800669c:	69a0      	ldr	r0, [r4, #24]
 800669e:	f7fd ff33 	bl	8004508 <LCD_X_DisplayDriver>
 80066a2:	4328      	orrs	r0, r5
 80066a4:	bd38      	pop	{r3, r4, r5, pc}

080066a6 <_SetVis>:
 80066a6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80066a8:	4604      	mov	r4, r0
 80066aa:	2300      	movs	r3, #0
 80066ac:	3008      	adds	r0, #8
 80066ae:	9301      	str	r3, [sp, #4]
 80066b0:	460d      	mov	r5, r1
 80066b2:	f7ff ff95 	bl	80065e0 <_InitOnce.isra.4>
 80066b6:	68a3      	ldr	r3, [r4, #8]
 80066b8:	b13b      	cbz	r3, 80066ca <_SetVis+0x24>
 80066ba:	aa02      	add	r2, sp, #8
 80066bc:	62dd      	str	r5, [r3, #44]	; 0x2c
 80066be:	f842 5d04 	str.w	r5, [r2, #-4]!
 80066c2:	69a0      	ldr	r0, [r4, #24]
 80066c4:	2109      	movs	r1, #9
 80066c6:	f7fd ff1f 	bl	8004508 <LCD_X_DisplayDriver>
 80066ca:	b003      	add	sp, #12
 80066cc:	bd30      	pop	{r4, r5, pc}

080066ce <_SetAlpha>:
 80066ce:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80066d0:	4604      	mov	r4, r0
 80066d2:	2300      	movs	r3, #0
 80066d4:	3008      	adds	r0, #8
 80066d6:	9301      	str	r3, [sp, #4]
 80066d8:	460d      	mov	r5, r1
 80066da:	f7ff ff81 	bl	80065e0 <_InitOnce.isra.4>
 80066de:	68a3      	ldr	r3, [r4, #8]
 80066e0:	b13b      	cbz	r3, 80066f2 <_SetAlpha+0x24>
 80066e2:	aa02      	add	r2, sp, #8
 80066e4:	629d      	str	r5, [r3, #40]	; 0x28
 80066e6:	f842 5d04 	str.w	r5, [r2, #-4]!
 80066ea:	69a0      	ldr	r0, [r4, #24]
 80066ec:	210a      	movs	r1, #10
 80066ee:	f7fd ff0b 	bl	8004508 <LCD_X_DisplayDriver>
 80066f2:	b003      	add	sp, #12
 80066f4:	bd30      	pop	{r4, r5, pc}

080066f6 <_SetPos>:
 80066f6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80066f8:	4604      	mov	r4, r0
 80066fa:	2300      	movs	r3, #0
 80066fc:	3008      	adds	r0, #8
 80066fe:	9300      	str	r3, [sp, #0]
 8006700:	9301      	str	r3, [sp, #4]
 8006702:	460d      	mov	r5, r1
 8006704:	4616      	mov	r6, r2
 8006706:	f7ff ff6b 	bl	80065e0 <_InitOnce.isra.4>
 800670a:	68a3      	ldr	r3, [r4, #8]
 800670c:	b143      	cbz	r3, 8006720 <_SetPos+0x2a>
 800670e:	621d      	str	r5, [r3, #32]
 8006710:	625e      	str	r6, [r3, #36]	; 0x24
 8006712:	69a0      	ldr	r0, [r4, #24]
 8006714:	2108      	movs	r1, #8
 8006716:	466a      	mov	r2, sp
 8006718:	e88d 0060 	stmia.w	sp, {r5, r6}
 800671c:	f7fd fef4 	bl	8004508 <LCD_X_DisplayDriver>
 8006720:	b002      	add	sp, #8
 8006722:	bd70      	pop	{r4, r5, r6, pc}

08006724 <_SetVRAMAddr>:
 8006724:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006726:	4604      	mov	r4, r0
 8006728:	2300      	movs	r3, #0
 800672a:	3008      	adds	r0, #8
 800672c:	9301      	str	r3, [sp, #4]
 800672e:	460d      	mov	r5, r1
 8006730:	f7ff ff56 	bl	80065e0 <_InitOnce.isra.4>
 8006734:	68a3      	ldr	r3, [r4, #8]
 8006736:	b143      	cbz	r3, 800674a <_SetVRAMAddr+0x26>
 8006738:	aa02      	add	r2, sp, #8
 800673a:	601d      	str	r5, [r3, #0]
 800673c:	605d      	str	r5, [r3, #4]
 800673e:	f842 5d04 	str.w	r5, [r2, #-4]!
 8006742:	69a0      	ldr	r0, [r4, #24]
 8006744:	2102      	movs	r1, #2
 8006746:	f7fd fedf 	bl	8004508 <LCD_X_DisplayDriver>
 800674a:	b003      	add	sp, #12
 800674c:	bd30      	pop	{r4, r5, pc}

0800674e <_CopyBuffer>:
 800674e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8006752:	4605      	mov	r5, r0
 8006754:	3008      	adds	r0, #8
 8006756:	460e      	mov	r6, r1
 8006758:	4617      	mov	r7, r2
 800675a:	f7ff ff41 	bl	80065e0 <_InitOnce.isra.4>
 800675e:	68ac      	ldr	r4, [r5, #8]
 8006760:	b1e4      	cbz	r4, 800679c <_CopyBuffer+0x4e>
 8006762:	42be      	cmp	r6, r7
 8006764:	d01a      	beq.n	800679c <_CopyBuffer+0x4e>
 8006766:	68eb      	ldr	r3, [r5, #12]
 8006768:	2108      	movs	r1, #8
 800676a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800676c:	4628      	mov	r0, r5
 800676e:	4798      	blx	r3
 8006770:	6923      	ldr	r3, [r4, #16]
 8006772:	68e2      	ldr	r2, [r4, #12]
 8006774:	6861      	ldr	r1, [r4, #4]
 8006776:	435a      	muls	r2, r3
 8006778:	4350      	muls	r0, r2
 800677a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800677c:	08c2      	lsrs	r2, r0, #3
 800677e:	fb07 1802 	mla	r8, r7, r2, r1
 8006782:	b123      	cbz	r3, 800678e <_CopyBuffer+0x40>
 8006784:	69a8      	ldr	r0, [r5, #24]
 8006786:	4631      	mov	r1, r6
 8006788:	463a      	mov	r2, r7
 800678a:	4798      	blx	r3
 800678c:	e004      	b.n	8006798 <_CopyBuffer+0x4a>
 800678e:	4640      	mov	r0, r8
 8006790:	fb06 1102 	mla	r1, r6, r2, r1
 8006794:	f002 fe16 	bl	80093c4 <memcpy>
 8006798:	f8c4 8000 	str.w	r8, [r4]
 800679c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080067a0 <_SetSize>:
 80067a0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80067a2:	4605      	mov	r5, r0
 80067a4:	2300      	movs	r3, #0
 80067a6:	3008      	adds	r0, #8
 80067a8:	460e      	mov	r6, r1
 80067aa:	4617      	mov	r7, r2
 80067ac:	9300      	str	r3, [sp, #0]
 80067ae:	9301      	str	r3, [sp, #4]
 80067b0:	f7ff ff16 	bl	80065e0 <_InitOnce.isra.4>
 80067b4:	68ac      	ldr	r4, [r5, #8]
 80067b6:	b194      	cbz	r4, 80067de <_SetSize+0x3e>
 80067b8:	69e3      	ldr	r3, [r4, #28]
 80067ba:	b93b      	cbnz	r3, 80067cc <_SetSize+0x2c>
 80067bc:	69a8      	ldr	r0, [r5, #24]
 80067be:	f000 f90d 	bl	80069dc <LCD_GetSwapXYEx>
 80067c2:	2800      	cmp	r0, #0
 80067c4:	bf0c      	ite	eq
 80067c6:	4630      	moveq	r0, r6
 80067c8:	4638      	movne	r0, r7
 80067ca:	61e0      	str	r0, [r4, #28]
 80067cc:	60e6      	str	r6, [r4, #12]
 80067ce:	6127      	str	r7, [r4, #16]
 80067d0:	69a8      	ldr	r0, [r5, #24]
 80067d2:	2107      	movs	r1, #7
 80067d4:	466a      	mov	r2, sp
 80067d6:	e88d 00c0 	stmia.w	sp, {r6, r7}
 80067da:	f7fd fe95 	bl	8004508 <LCD_X_DisplayDriver>
 80067de:	b003      	add	sp, #12
 80067e0:	bdf0      	pop	{r4, r5, r6, r7, pc}

080067e2 <_SetVSize>:
 80067e2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80067e4:	4606      	mov	r6, r0
 80067e6:	3008      	adds	r0, #8
 80067e8:	460d      	mov	r5, r1
 80067ea:	4617      	mov	r7, r2
 80067ec:	f7ff fef8 	bl	80065e0 <_InitOnce.isra.4>
 80067f0:	68b4      	ldr	r4, [r6, #8]
 80067f2:	b144      	cbz	r4, 8006806 <_SetVSize+0x24>
 80067f4:	69b0      	ldr	r0, [r6, #24]
 80067f6:	f000 f8f1 	bl	80069dc <LCD_GetSwapXYEx>
 80067fa:	6165      	str	r5, [r4, #20]
 80067fc:	61a7      	str	r7, [r4, #24]
 80067fe:	b108      	cbz	r0, 8006804 <_SetVSize+0x22>
 8006800:	61e7      	str	r7, [r4, #28]
 8006802:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006804:	61e5      	str	r5, [r4, #28]
 8006806:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006808 <LCD_UpdateColorIndices>:
 8006808:	b510      	push	{r4, lr}
 800680a:	4c07      	ldr	r4, [pc, #28]	; (8006828 <LCD_UpdateColorIndices+0x20>)
 800680c:	6823      	ldr	r3, [r4, #0]
 800680e:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8006810:	f000 fb2a 	bl	8006e68 <LCD_Color2Index>
 8006814:	f000 fb48 	bl	8006ea8 <LCD_SetColorIndex>
 8006818:	6823      	ldr	r3, [r4, #0]
 800681a:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800681c:	f000 fb24 	bl	8006e68 <LCD_Color2Index>
 8006820:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8006824:	f000 bb5c 	b.w	8006ee0 <LCD_SetBkColorIndex>
 8006828:	20000060 	.word	0x20000060

0800682c <LCD_SetClipRectEx>:
 800682c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800682e:	4c09      	ldr	r4, [pc, #36]	; (8006854 <LCD_SetClipRectEx+0x28>)
 8006830:	6823      	ldr	r3, [r4, #0]
 8006832:	7c5a      	ldrb	r2, [r3, #17]
 8006834:	4b08      	ldr	r3, [pc, #32]	; (8006858 <LCD_SetClipRectEx+0x2c>)
 8006836:	4605      	mov	r5, r0
 8006838:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800683c:	68c2      	ldr	r2, [r0, #12]
 800683e:	4669      	mov	r1, sp
 8006840:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8006842:	4790      	blx	r2
 8006844:	6820      	ldr	r0, [r4, #0]
 8006846:	4629      	mov	r1, r5
 8006848:	466a      	mov	r2, sp
 800684a:	3008      	adds	r0, #8
 800684c:	f000 fc12 	bl	8007074 <GUI__IntersectRects>
 8006850:	b003      	add	sp, #12
 8006852:	bd30      	pop	{r4, r5, pc}
 8006854:	20000060 	.word	0x20000060
 8006858:	20022308 	.word	0x20022308

0800685c <LCD_SetVRAMAddrEx>:
 800685c:	b513      	push	{r0, r1, r4, lr}
 800685e:	460c      	mov	r4, r1
 8006860:	f000 ffc6 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006864:	9001      	str	r0, [sp, #4]
 8006866:	b908      	cbnz	r0, 800686c <LCD_SetVRAMAddrEx+0x10>
 8006868:	2001      	movs	r0, #1
 800686a:	e00b      	b.n	8006884 <LCD_SetVRAMAddrEx+0x28>
 800686c:	68c3      	ldr	r3, [r0, #12]
 800686e:	2109      	movs	r1, #9
 8006870:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006872:	a801      	add	r0, sp, #4
 8006874:	4798      	blx	r3
 8006876:	4603      	mov	r3, r0
 8006878:	2800      	cmp	r0, #0
 800687a:	d0f5      	beq.n	8006868 <LCD_SetVRAMAddrEx+0xc>
 800687c:	9801      	ldr	r0, [sp, #4]
 800687e:	4621      	mov	r1, r4
 8006880:	4798      	blx	r3
 8006882:	2000      	movs	r0, #0
 8006884:	b002      	add	sp, #8
 8006886:	bd10      	pop	{r4, pc}

08006888 <LCD_SetVSizeEx>:
 8006888:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800688a:	460d      	mov	r5, r1
 800688c:	4614      	mov	r4, r2
 800688e:	f000 ffaf 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006892:	9001      	str	r0, [sp, #4]
 8006894:	b908      	cbnz	r0, 800689a <LCD_SetVSizeEx+0x12>
 8006896:	2001      	movs	r0, #1
 8006898:	e00c      	b.n	80068b4 <LCD_SetVSizeEx+0x2c>
 800689a:	68c3      	ldr	r3, [r0, #12]
 800689c:	210a      	movs	r1, #10
 800689e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068a0:	a801      	add	r0, sp, #4
 80068a2:	4798      	blx	r3
 80068a4:	4603      	mov	r3, r0
 80068a6:	2800      	cmp	r0, #0
 80068a8:	d0f5      	beq.n	8006896 <LCD_SetVSizeEx+0xe>
 80068aa:	9801      	ldr	r0, [sp, #4]
 80068ac:	4629      	mov	r1, r5
 80068ae:	4622      	mov	r2, r4
 80068b0:	4798      	blx	r3
 80068b2:	2000      	movs	r0, #0
 80068b4:	b003      	add	sp, #12
 80068b6:	bd30      	pop	{r4, r5, pc}

080068b8 <LCD_SetSizeEx>:
 80068b8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80068ba:	460d      	mov	r5, r1
 80068bc:	4614      	mov	r4, r2
 80068be:	f000 ff97 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 80068c2:	9001      	str	r0, [sp, #4]
 80068c4:	b908      	cbnz	r0, 80068ca <LCD_SetSizeEx+0x12>
 80068c6:	2001      	movs	r0, #1
 80068c8:	e00c      	b.n	80068e4 <LCD_SetSizeEx+0x2c>
 80068ca:	68c3      	ldr	r3, [r0, #12]
 80068cc:	210b      	movs	r1, #11
 80068ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80068d0:	a801      	add	r0, sp, #4
 80068d2:	4798      	blx	r3
 80068d4:	4603      	mov	r3, r0
 80068d6:	2800      	cmp	r0, #0
 80068d8:	d0f5      	beq.n	80068c6 <LCD_SetSizeEx+0xe>
 80068da:	9801      	ldr	r0, [sp, #4]
 80068dc:	4629      	mov	r1, r5
 80068de:	4622      	mov	r2, r4
 80068e0:	4798      	blx	r3
 80068e2:	2000      	movs	r0, #0
 80068e4:	b003      	add	sp, #12
 80068e6:	bd30      	pop	{r4, r5, pc}

080068e8 <LCD_SetLUTEntryEx>:
 80068e8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80068ea:	460d      	mov	r5, r1
 80068ec:	4614      	mov	r4, r2
 80068ee:	f000 ff7f 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 80068f2:	9001      	str	r0, [sp, #4]
 80068f4:	b908      	cbnz	r0, 80068fa <LCD_SetLUTEntryEx+0x12>
 80068f6:	2001      	movs	r0, #1
 80068f8:	e00c      	b.n	8006914 <LCD_SetLUTEntryEx+0x2c>
 80068fa:	68c3      	ldr	r3, [r0, #12]
 80068fc:	2110      	movs	r1, #16
 80068fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006900:	a801      	add	r0, sp, #4
 8006902:	4798      	blx	r3
 8006904:	4603      	mov	r3, r0
 8006906:	2800      	cmp	r0, #0
 8006908:	d0f5      	beq.n	80068f6 <LCD_SetLUTEntryEx+0xe>
 800690a:	9801      	ldr	r0, [sp, #4]
 800690c:	4629      	mov	r1, r5
 800690e:	4622      	mov	r2, r4
 8006910:	4798      	blx	r3
 8006912:	2000      	movs	r0, #0
 8006914:	b003      	add	sp, #12
 8006916:	bd30      	pop	{r4, r5, pc}

08006918 <LCD_GetPosEx>:
 8006918:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800691a:	460d      	mov	r5, r1
 800691c:	4614      	mov	r4, r2
 800691e:	f000 ff67 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006922:	9001      	str	r0, [sp, #4]
 8006924:	b908      	cbnz	r0, 800692a <LCD_GetPosEx+0x12>
 8006926:	2001      	movs	r0, #1
 8006928:	e00c      	b.n	8006944 <LCD_GetPosEx+0x2c>
 800692a:	68c3      	ldr	r3, [r0, #12]
 800692c:	2104      	movs	r1, #4
 800692e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006930:	a801      	add	r0, sp, #4
 8006932:	4798      	blx	r3
 8006934:	4603      	mov	r3, r0
 8006936:	2800      	cmp	r0, #0
 8006938:	d0f5      	beq.n	8006926 <LCD_GetPosEx+0xe>
 800693a:	9801      	ldr	r0, [sp, #4]
 800693c:	4629      	mov	r1, r5
 800693e:	4622      	mov	r2, r4
 8006940:	4798      	blx	r3
 8006942:	2000      	movs	r0, #0
 8006944:	b003      	add	sp, #12
 8006946:	bd30      	pop	{r4, r5, pc}

08006948 <LCD_SetDevFunc>:
 8006948:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800694a:	460d      	mov	r5, r1
 800694c:	4614      	mov	r4, r2
 800694e:	f000 ff4f 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006952:	9001      	str	r0, [sp, #4]
 8006954:	b908      	cbnz	r0, 800695a <LCD_SetDevFunc+0x12>
 8006956:	2001      	movs	r0, #1
 8006958:	e00c      	b.n	8006974 <LCD_SetDevFunc+0x2c>
 800695a:	68c3      	ldr	r3, [r0, #12]
 800695c:	2116      	movs	r1, #22
 800695e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006960:	a801      	add	r0, sp, #4
 8006962:	4798      	blx	r3
 8006964:	4603      	mov	r3, r0
 8006966:	2800      	cmp	r0, #0
 8006968:	d0f5      	beq.n	8006956 <LCD_SetDevFunc+0xe>
 800696a:	9801      	ldr	r0, [sp, #4]
 800696c:	4629      	mov	r1, r5
 800696e:	4622      	mov	r2, r4
 8006970:	4798      	blx	r3
 8006972:	2000      	movs	r0, #0
 8006974:	b003      	add	sp, #12
 8006976:	bd30      	pop	{r4, r5, pc}

08006978 <_GetDevProp>:
 8006978:	2801      	cmp	r0, #1
 800697a:	b510      	push	{r4, lr}
 800697c:	460c      	mov	r4, r1
 800697e:	dc08      	bgt.n	8006992 <_GetDevProp+0x1a>
 8006980:	f000 ff36 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006984:	b120      	cbz	r0, 8006990 <_GetDevProp+0x18>
 8006986:	68c3      	ldr	r3, [r0, #12]
 8006988:	4621      	mov	r1, r4
 800698a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800698c:	4798      	blx	r3
 800698e:	bd10      	pop	{r4, pc}
 8006990:	bd10      	pop	{r4, pc}
 8006992:	2000      	movs	r0, #0
 8006994:	bd10      	pop	{r4, pc}

08006996 <_GetMaxValue>:
 8006996:	b538      	push	{r3, r4, r5, lr}
 8006998:	4604      	mov	r4, r0
 800699a:	4621      	mov	r1, r4
 800699c:	2001      	movs	r0, #1
 800699e:	f7ff ffeb 	bl	8006978 <_GetDevProp>
 80069a2:	4621      	mov	r1, r4
 80069a4:	4605      	mov	r5, r0
 80069a6:	2000      	movs	r0, #0
 80069a8:	f7ff ffe6 	bl	8006978 <_GetDevProp>
 80069ac:	42a8      	cmp	r0, r5
 80069ae:	bfb8      	it	lt
 80069b0:	4628      	movlt	r0, r5
 80069b2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80069b6:	bd38      	pop	{r3, r4, r5, pc}

080069b8 <LCD_GetXSizeEx>:
 80069b8:	2101      	movs	r1, #1
 80069ba:	f7ff bfdd 	b.w	8006978 <_GetDevProp>

080069be <LCD_GetYSizeEx>:
 80069be:	2102      	movs	r1, #2
 80069c0:	f7ff bfda 	b.w	8006978 <_GetDevProp>

080069c4 <LCD_GetBitsPerPixelEx>:
 80069c4:	2108      	movs	r1, #8
 80069c6:	f7ff bfd7 	b.w	8006978 <_GetDevProp>

080069ca <LCD_GetNumColorsEx>:
 80069ca:	2109      	movs	r1, #9
 80069cc:	f7ff bfd4 	b.w	8006978 <_GetDevProp>

080069d0 <LCD_GetMirrorXEx>:
 80069d0:	210c      	movs	r1, #12
 80069d2:	f7ff bfd1 	b.w	8006978 <_GetDevProp>

080069d6 <LCD_GetMirrorYEx>:
 80069d6:	210d      	movs	r1, #13
 80069d8:	f7ff bfce 	b.w	8006978 <_GetDevProp>

080069dc <LCD_GetSwapXYEx>:
 80069dc:	210e      	movs	r1, #14
 80069de:	f7ff bfcb 	b.w	8006978 <_GetDevProp>
	...

080069e4 <LCD_GetXSize>:
 80069e4:	4b02      	ldr	r3, [pc, #8]	; (80069f0 <LCD_GetXSize+0xc>)
 80069e6:	681b      	ldr	r3, [r3, #0]
 80069e8:	7c58      	ldrb	r0, [r3, #17]
 80069ea:	f7ff bfe5 	b.w	80069b8 <LCD_GetXSizeEx>
 80069ee:	bf00      	nop
 80069f0:	20000060 	.word	0x20000060

080069f4 <LCD_GetYSize>:
 80069f4:	4b02      	ldr	r3, [pc, #8]	; (8006a00 <LCD_GetYSize+0xc>)
 80069f6:	681b      	ldr	r3, [r3, #0]
 80069f8:	7c58      	ldrb	r0, [r3, #17]
 80069fa:	f7ff bfe0 	b.w	80069be <LCD_GetYSizeEx>
 80069fe:	bf00      	nop
 8006a00:	20000060 	.word	0x20000060

08006a04 <LCD_GetNumColors>:
 8006a04:	4b02      	ldr	r3, [pc, #8]	; (8006a10 <LCD_GetNumColors+0xc>)
 8006a06:	681b      	ldr	r3, [r3, #0]
 8006a08:	7c58      	ldrb	r0, [r3, #17]
 8006a0a:	f7ff bfde 	b.w	80069ca <LCD_GetNumColorsEx>
 8006a0e:	bf00      	nop
 8006a10:	20000060 	.word	0x20000060

08006a14 <GUI_GetBitsPerPixelEx>:
 8006a14:	b508      	push	{r3, lr}
 8006a16:	4b04      	ldr	r3, [pc, #16]	; (8006a28 <GUI_GetBitsPerPixelEx+0x14>)
 8006a18:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 8006a1c:	68c3      	ldr	r3, [r0, #12]
 8006a1e:	2108      	movs	r1, #8
 8006a20:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8006a22:	4798      	blx	r3
 8006a24:	bd08      	pop	{r3, pc}
 8006a26:	bf00      	nop
 8006a28:	20022308 	.word	0x20022308

08006a2c <LCD_GetPaletteEx>:
 8006a2c:	b508      	push	{r3, lr}
 8006a2e:	f000 fedf 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006a32:	b120      	cbz	r0, 8006a3e <LCD_GetPaletteEx+0x12>
 8006a34:	68c3      	ldr	r3, [r0, #12]
 8006a36:	2102      	movs	r1, #2
 8006a38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006a3a:	4798      	blx	r3
 8006a3c:	bd08      	pop	{r3, pc}
 8006a3e:	bd08      	pop	{r3, pc}

08006a40 <LCD_GetPalette>:
 8006a40:	4b02      	ldr	r3, [pc, #8]	; (8006a4c <LCD_GetPalette+0xc>)
 8006a42:	681b      	ldr	r3, [r3, #0]
 8006a44:	7c58      	ldrb	r0, [r3, #17]
 8006a46:	f7ff bff1 	b.w	8006a2c <LCD_GetPaletteEx>
 8006a4a:	bf00      	nop
 8006a4c:	20000060 	.word	0x20000060

08006a50 <GUI_GetpfIndex2ColorEx>:
 8006a50:	4b02      	ldr	r3, [pc, #8]	; (8006a5c <GUI_GetpfIndex2ColorEx+0xc>)
 8006a52:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 8006a56:	691b      	ldr	r3, [r3, #16]
 8006a58:	6858      	ldr	r0, [r3, #4]
 8006a5a:	4770      	bx	lr
 8006a5c:	20022308 	.word	0x20022308

08006a60 <LCD_GetVXSizeMax>:
 8006a60:	2003      	movs	r0, #3
 8006a62:	f7ff bf98 	b.w	8006996 <_GetMaxValue>
	...

08006a68 <_SetDrawMode>:
 8006a68:	b570      	push	{r4, r5, r6, lr}
 8006a6a:	4b08      	ldr	r3, [pc, #32]	; (8006a8c <_SetDrawMode+0x24>)
 8006a6c:	681b      	ldr	r3, [r3, #0]
 8006a6e:	7c1a      	ldrb	r2, [r3, #16]
 8006a70:	ea80 0102 	eor.w	r1, r0, r2
 8006a74:	0749      	lsls	r1, r1, #29
 8006a76:	d505      	bpl.n	8006a84 <_SetDrawMode+0x1c>
 8006a78:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 8006a7a:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8006a7c:	6826      	ldr	r6, [r4, #0]
 8006a7e:	680d      	ldr	r5, [r1, #0]
 8006a80:	6025      	str	r5, [r4, #0]
 8006a82:	600e      	str	r6, [r1, #0]
 8006a84:	7418      	strb	r0, [r3, #16]
 8006a86:	4610      	mov	r0, r2
 8006a88:	bd70      	pop	{r4, r5, r6, pc}
 8006a8a:	bf00      	nop
 8006a8c:	20000060 	.word	0x20000060

08006a90 <LCD_SetDrawMode>:
 8006a90:	b508      	push	{r3, lr}
 8006a92:	4b02      	ldr	r3, [pc, #8]	; (8006a9c <LCD_SetDrawMode+0xc>)
 8006a94:	681b      	ldr	r3, [r3, #0]
 8006a96:	689b      	ldr	r3, [r3, #8]
 8006a98:	4798      	blx	r3
 8006a9a:	bd08      	pop	{r3, pc}
 8006a9c:	2000005c 	.word	0x2000005c

08006aa0 <LCD_DrawPixel>:
 8006aa0:	b538      	push	{r3, r4, r5, lr}
 8006aa2:	4b14      	ldr	r3, [pc, #80]	; (8006af4 <LCD_DrawPixel+0x54>)
 8006aa4:	681b      	ldr	r3, [r3, #0]
 8006aa6:	460a      	mov	r2, r1
 8006aa8:	f9b3 100a 	ldrsh.w	r1, [r3, #10]
 8006aac:	428a      	cmp	r2, r1
 8006aae:	4604      	mov	r4, r0
 8006ab0:	db1e      	blt.n	8006af0 <LCD_DrawPixel+0x50>
 8006ab2:	f9b3 100e 	ldrsh.w	r1, [r3, #14]
 8006ab6:	428a      	cmp	r2, r1
 8006ab8:	dc1a      	bgt.n	8006af0 <LCD_DrawPixel+0x50>
 8006aba:	f9b3 1008 	ldrsh.w	r1, [r3, #8]
 8006abe:	4288      	cmp	r0, r1
 8006ac0:	db16      	blt.n	8006af0 <LCD_DrawPixel+0x50>
 8006ac2:	f9b3 100c 	ldrsh.w	r1, [r3, #12]
 8006ac6:	4288      	cmp	r0, r1
 8006ac8:	dc12      	bgt.n	8006af0 <LCD_DrawPixel+0x50>
 8006aca:	7c19      	ldrb	r1, [r3, #16]
 8006acc:	7c58      	ldrb	r0, [r3, #17]
 8006ace:	f011 0f01 	tst.w	r1, #1
 8006ad2:	4909      	ldr	r1, [pc, #36]	; (8006af8 <LCD_DrawPixel+0x58>)
 8006ad4:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 8006ad8:	d004      	beq.n	8006ae4 <LCD_DrawPixel+0x44>
 8006ada:	68c3      	ldr	r3, [r0, #12]
 8006adc:	4621      	mov	r1, r4
 8006ade:	69db      	ldr	r3, [r3, #28]
 8006ae0:	4798      	blx	r3
 8006ae2:	bd38      	pop	{r3, r4, r5, pc}
 8006ae4:	68c1      	ldr	r1, [r0, #12]
 8006ae6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006ae8:	698d      	ldr	r5, [r1, #24]
 8006aea:	681b      	ldr	r3, [r3, #0]
 8006aec:	4621      	mov	r1, r4
 8006aee:	47a8      	blx	r5
 8006af0:	bd38      	pop	{r3, r4, r5, pc}
 8006af2:	bf00      	nop
 8006af4:	20000060 	.word	0x20000060
 8006af8:	20022308 	.word	0x20022308

08006afc <LCD_DrawHLine>:
 8006afc:	b538      	push	{r3, r4, r5, lr}
 8006afe:	4b10      	ldr	r3, [pc, #64]	; (8006b40 <LCD_DrawHLine+0x44>)
 8006b00:	681c      	ldr	r4, [r3, #0]
 8006b02:	f9b4 300a 	ldrsh.w	r3, [r4, #10]
 8006b06:	4299      	cmp	r1, r3
 8006b08:	460d      	mov	r5, r1
 8006b0a:	db17      	blt.n	8006b3c <LCD_DrawHLine+0x40>
 8006b0c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 8006b10:	4299      	cmp	r1, r3
 8006b12:	dc13      	bgt.n	8006b3c <LCD_DrawHLine+0x40>
 8006b14:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
 8006b18:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8006b1c:	4288      	cmp	r0, r1
 8006b1e:	bfa8      	it	ge
 8006b20:	4601      	movge	r1, r0
 8006b22:	429a      	cmp	r2, r3
 8006b24:	bfb8      	it	lt
 8006b26:	4613      	movlt	r3, r2
 8006b28:	428b      	cmp	r3, r1
 8006b2a:	db07      	blt.n	8006b3c <LCD_DrawHLine+0x40>
 8006b2c:	7c60      	ldrb	r0, [r4, #17]
 8006b2e:	4a05      	ldr	r2, [pc, #20]	; (8006b44 <LCD_DrawHLine+0x48>)
 8006b30:	f852 0020 	ldr.w	r0, [r2, r0, lsl #2]
 8006b34:	68c2      	ldr	r2, [r0, #12]
 8006b36:	6894      	ldr	r4, [r2, #8]
 8006b38:	462a      	mov	r2, r5
 8006b3a:	47a0      	blx	r4
 8006b3c:	bd38      	pop	{r3, r4, r5, pc}
 8006b3e:	bf00      	nop
 8006b40:	20000060 	.word	0x20000060
 8006b44:	20022308 	.word	0x20022308

08006b48 <LCD_FillRect>:
 8006b48:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8006b4a:	460e      	mov	r6, r1
 8006b4c:	4912      	ldr	r1, [pc, #72]	; (8006b98 <LCD_FillRect+0x50>)
 8006b4e:	680c      	ldr	r4, [r1, #0]
 8006b50:	f9b4 1008 	ldrsh.w	r1, [r4, #8]
 8006b54:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8006b58:	4288      	cmp	r0, r1
 8006b5a:	bfa8      	it	ge
 8006b5c:	4601      	movge	r1, r0
 8006b5e:	42aa      	cmp	r2, r5
 8006b60:	bfb8      	it	lt
 8006b62:	4615      	movlt	r5, r2
 8006b64:	428d      	cmp	r5, r1
 8006b66:	db14      	blt.n	8006b92 <LCD_FillRect+0x4a>
 8006b68:	f9b4 200a 	ldrsh.w	r2, [r4, #10]
 8006b6c:	f9b4 000e 	ldrsh.w	r0, [r4, #14]
 8006b70:	4296      	cmp	r6, r2
 8006b72:	bfa8      	it	ge
 8006b74:	4632      	movge	r2, r6
 8006b76:	4283      	cmp	r3, r0
 8006b78:	bfa8      	it	ge
 8006b7a:	4603      	movge	r3, r0
 8006b7c:	4293      	cmp	r3, r2
 8006b7e:	db08      	blt.n	8006b92 <LCD_FillRect+0x4a>
 8006b80:	7c64      	ldrb	r4, [r4, #17]
 8006b82:	4806      	ldr	r0, [pc, #24]	; (8006b9c <LCD_FillRect+0x54>)
 8006b84:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 8006b88:	68c4      	ldr	r4, [r0, #12]
 8006b8a:	9300      	str	r3, [sp, #0]
 8006b8c:	6924      	ldr	r4, [r4, #16]
 8006b8e:	462b      	mov	r3, r5
 8006b90:	47a0      	blx	r4
 8006b92:	b002      	add	sp, #8
 8006b94:	bd70      	pop	{r4, r5, r6, pc}
 8006b96:	bf00      	nop
 8006b98:	20000060 	.word	0x20000060
 8006b9c:	20022308 	.word	0x20022308

08006ba0 <LCD_DrawBitmap>:
 8006ba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006ba4:	f8df c208 	ldr.w	ip, [pc, #520]	; 8006db0 <LCD_DrawBitmap+0x210>
 8006ba8:	b091      	sub	sp, #68	; 0x44
 8006baa:	f8dc c000 	ldr.w	ip, [ip]
 8006bae:	9207      	str	r2, [sp, #28]
 8006bb0:	4605      	mov	r5, r0
 8006bb2:	4688      	mov	r8, r1
 8006bb4:	469b      	mov	fp, r3
 8006bb6:	9e1c      	ldr	r6, [sp, #112]	; 0x70
 8006bb8:	9c1e      	ldr	r4, [sp, #120]	; 0x78
 8006bba:	f1bc 0f00 	cmp.w	ip, #0
 8006bbe:	d00c      	beq.n	8006bda <LCD_DrawBitmap+0x3a>
 8006bc0:	9d1a      	ldr	r5, [sp, #104]	; 0x68
 8006bc2:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
 8006bc4:	9500      	str	r5, [sp, #0]
 8006bc6:	9701      	str	r7, [sp, #4]
 8006bc8:	9d1d      	ldr	r5, [sp, #116]	; 0x74
 8006bca:	9f1f      	ldr	r7, [sp, #124]	; 0x7c
 8006bcc:	9602      	str	r6, [sp, #8]
 8006bce:	9503      	str	r5, [sp, #12]
 8006bd0:	9404      	str	r4, [sp, #16]
 8006bd2:	9705      	str	r7, [sp, #20]
 8006bd4:	f8dc 4000 	ldr.w	r4, [ip]
 8006bd8:	e081      	b.n	8006cde <LCD_DrawBitmap+0x13e>
 8006bda:	9f1a      	ldr	r7, [sp, #104]	; 0x68
 8006bdc:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8006bde:	ea47 0300 	orr.w	r3, r7, r0
 8006be2:	2b01      	cmp	r3, #1
 8006be4:	d17d      	bne.n	8006ce2 <LCD_DrawBitmap+0x142>
 8006be6:	4b70      	ldr	r3, [pc, #448]	; (8006da8 <LCD_DrawBitmap+0x208>)
 8006be8:	6818      	ldr	r0, [r3, #0]
 8006bea:	f9b0 200a 	ldrsh.w	r2, [r0, #10]
 8006bee:	1a53      	subs	r3, r2, r1
 8006bf0:	2b00      	cmp	r3, #0
 8006bf2:	dd08      	ble.n	8006c06 <LCD_DrawBitmap+0x66>
 8006bf4:	ebc3 010b 	rsb	r1, r3, fp
 8006bf8:	2900      	cmp	r1, #0
 8006bfa:	f340 80d2 	ble.w	8006da2 <LCD_DrawBitmap+0x202>
 8006bfe:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 8006c00:	fb07 4403 	mla	r4, r7, r3, r4
 8006c04:	e001      	b.n	8006c0a <LCD_DrawBitmap+0x6a>
 8006c06:	4659      	mov	r1, fp
 8006c08:	4642      	mov	r2, r8
 8006c0a:	44d8      	add	r8, fp
 8006c0c:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
 8006c10:	f108 38ff 	add.w	r8, r8, #4294967295
 8006c14:	ebc3 0808 	rsb	r8, r3, r8
 8006c18:	f1b8 0f00 	cmp.w	r8, #0
 8006c1c:	dd04      	ble.n	8006c28 <LCD_DrawBitmap+0x88>
 8006c1e:	ebc8 0101 	rsb	r1, r8, r1
 8006c22:	2900      	cmp	r1, #0
 8006c24:	f340 80bd 	ble.w	8006da2 <LCD_DrawBitmap+0x202>
 8006c28:	9b07      	ldr	r3, [sp, #28]
 8006c2a:	f9b0 c00c 	ldrsh.w	ip, [r0, #12]
 8006c2e:	442b      	add	r3, r5
 8006c30:	3b01      	subs	r3, #1
 8006c32:	ebcc 0303 	rsb	r3, ip, r3
 8006c36:	2b00      	cmp	r3, #0
 8006c38:	dd02      	ble.n	8006c40 <LCD_DrawBitmap+0xa0>
 8006c3a:	9f07      	ldr	r7, [sp, #28]
 8006c3c:	1aff      	subs	r7, r7, r3
 8006c3e:	9707      	str	r7, [sp, #28]
 8006c40:	f9b0 c008 	ldrsh.w	ip, [r0, #8]
 8006c44:	4565      	cmp	r5, ip
 8006c46:	da33      	bge.n	8006cb0 <LCD_DrawBitmap+0x110>
 8006c48:	9f07      	ldr	r7, [sp, #28]
 8006c4a:	ebc5 030c 	rsb	r3, r5, ip
 8006c4e:	1aff      	subs	r7, r7, r3
 8006c50:	2e08      	cmp	r6, #8
 8006c52:	9707      	str	r7, [sp, #28]
 8006c54:	d027      	beq.n	8006ca6 <LCD_DrawBitmap+0x106>
 8006c56:	dc0d      	bgt.n	8006c74 <LCD_DrawBitmap+0xd4>
 8006c58:	2e02      	cmp	r6, #2
 8006c5a:	d014      	beq.n	8006c86 <LCD_DrawBitmap+0xe6>
 8006c5c:	2e04      	cmp	r6, #4
 8006c5e:	d01a      	beq.n	8006c96 <LCD_DrawBitmap+0xf6>
 8006c60:	2e01      	cmp	r6, #1
 8006c62:	d126      	bne.n	8006cb2 <LCD_DrawBitmap+0x112>
 8006c64:	f023 0c07 	bic.w	ip, r3, #7
 8006c68:	eb04 04e3 	add.w	r4, r4, r3, asr #3
 8006c6c:	4465      	add	r5, ip
 8006c6e:	f003 0307 	and.w	r3, r3, #7
 8006c72:	e01e      	b.n	8006cb2 <LCD_DrawBitmap+0x112>
 8006c74:	2e18      	cmp	r6, #24
 8006c76:	d018      	beq.n	8006caa <LCD_DrawBitmap+0x10a>
 8006c78:	2e20      	cmp	r6, #32
 8006c7a:	d016      	beq.n	8006caa <LCD_DrawBitmap+0x10a>
 8006c7c:	2e10      	cmp	r6, #16
 8006c7e:	d118      	bne.n	8006cb2 <LCD_DrawBitmap+0x112>
 8006c80:	eb04 0443 	add.w	r4, r4, r3, lsl #1
 8006c84:	e013      	b.n	8006cae <LCD_DrawBitmap+0x10e>
 8006c86:	f023 0c03 	bic.w	ip, r3, #3
 8006c8a:	eb04 04a3 	add.w	r4, r4, r3, asr #2
 8006c8e:	4465      	add	r5, ip
 8006c90:	f003 0303 	and.w	r3, r3, #3
 8006c94:	e00d      	b.n	8006cb2 <LCD_DrawBitmap+0x112>
 8006c96:	f023 0c01 	bic.w	ip, r3, #1
 8006c9a:	eb04 0463 	add.w	r4, r4, r3, asr #1
 8006c9e:	4465      	add	r5, ip
 8006ca0:	f003 0301 	and.w	r3, r3, #1
 8006ca4:	e005      	b.n	8006cb2 <LCD_DrawBitmap+0x112>
 8006ca6:	441c      	add	r4, r3
 8006ca8:	e001      	b.n	8006cae <LCD_DrawBitmap+0x10e>
 8006caa:	eb04 0483 	add.w	r4, r4, r3, lsl #2
 8006cae:	4665      	mov	r5, ip
 8006cb0:	2300      	movs	r3, #0
 8006cb2:	9f07      	ldr	r7, [sp, #28]
 8006cb4:	2f00      	cmp	r7, #0
 8006cb6:	dd74      	ble.n	8006da2 <LCD_DrawBitmap+0x202>
 8006cb8:	f890 e011 	ldrb.w	lr, [r0, #17]
 8006cbc:	483b      	ldr	r0, [pc, #236]	; (8006dac <LCD_DrawBitmap+0x20c>)
 8006cbe:	9f1d      	ldr	r7, [sp, #116]	; 0x74
 8006cc0:	f850 002e 	ldr.w	r0, [r0, lr, lsl #2]
 8006cc4:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 8006cc8:	9403      	str	r4, [sp, #12]
 8006cca:	e88d 0042 	stmia.w	sp, {r1, r6}
 8006cce:	9c1f      	ldr	r4, [sp, #124]	; 0x7c
 8006cd0:	9304      	str	r3, [sp, #16]
 8006cd2:	9702      	str	r7, [sp, #8]
 8006cd4:	9405      	str	r4, [sp, #20]
 8006cd6:	f8de 4004 	ldr.w	r4, [lr, #4]
 8006cda:	9b07      	ldr	r3, [sp, #28]
 8006cdc:	4629      	mov	r1, r5
 8006cde:	47a0      	blx	r4
 8006ce0:	e05f      	b.n	8006da2 <LCD_DrawBitmap+0x202>
 8006ce2:	f1c6 0708 	rsb	r7, r6, #8
 8006ce6:	970e      	str	r7, [sp, #56]	; 0x38
 8006ce8:	4667      	mov	r7, ip
 8006cea:	45dc      	cmp	ip, fp
 8006cec:	da59      	bge.n	8006da2 <LCD_DrawBitmap+0x202>
 8006cee:	4b2e      	ldr	r3, [pc, #184]	; (8006da8 <LCD_DrawBitmap+0x208>)
 8006cf0:	981b      	ldr	r0, [sp, #108]	; 0x6c
 8006cf2:	681b      	ldr	r3, [r3, #0]
 8006cf4:	4440      	add	r0, r8
 8006cf6:	f9b3 200a 	ldrsh.w	r2, [r3, #10]
 8006cfa:	900c      	str	r0, [sp, #48]	; 0x30
 8006cfc:	1e41      	subs	r1, r0, #1
 8006cfe:	4291      	cmp	r1, r2
 8006d00:	910d      	str	r1, [sp, #52]	; 0x34
 8006d02:	db47      	blt.n	8006d94 <LCD_DrawBitmap+0x1f4>
 8006d04:	f9b3 300e 	ldrsh.w	r3, [r3, #14]
 8006d08:	4598      	cmp	r8, r3
 8006d0a:	dc43      	bgt.n	8006d94 <LCD_DrawBitmap+0x1f4>
 8006d0c:	f04f 0900 	mov.w	r9, #0
 8006d10:	940b      	str	r4, [sp, #44]	; 0x2c
 8006d12:	46aa      	mov	sl, r5
 8006d14:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
 8006d18:	9807      	ldr	r0, [sp, #28]
 8006d1a:	4581      	cmp	r9, r0
 8006d1c:	da3a      	bge.n	8006d94 <LCD_DrawBitmap+0x1f4>
 8006d1e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006d20:	b92a      	cbnz	r2, 8006d2e <LCD_DrawBitmap+0x18e>
 8006d22:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8006d24:	2008      	movs	r0, #8
 8006d26:	781f      	ldrb	r7, [r3, #0]
 8006d28:	900a      	str	r0, [sp, #40]	; 0x28
 8006d2a:	3301      	adds	r3, #1
 8006d2c:	930b      	str	r3, [sp, #44]	; 0x2c
 8006d2e:	990e      	ldr	r1, [sp, #56]	; 0x38
 8006d30:	fa07 f206 	lsl.w	r2, r7, r6
 8006d34:	fa47 f301 	asr.w	r3, r7, r1
 8006d38:	b2d7      	uxtb	r7, r2
 8006d3a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8006d3c:	f013 01ff 	ands.w	r1, r3, #255	; 0xff
 8006d40:	ebc6 0202 	rsb	r2, r6, r2
 8006d44:	920a      	str	r2, [sp, #40]	; 0x28
 8006d46:	4a18      	ldr	r2, [pc, #96]	; (8006da8 <LCD_DrawBitmap+0x208>)
 8006d48:	d103      	bne.n	8006d52 <LCD_DrawBitmap+0x1b2>
 8006d4a:	6810      	ldr	r0, [r2, #0]
 8006d4c:	7c00      	ldrb	r0, [r0, #16]
 8006d4e:	0780      	lsls	r0, r0, #30
 8006d50:	d41b      	bmi.n	8006d8a <LCD_DrawBitmap+0x1ea>
 8006d52:	6812      	ldr	r2, [r2, #0]
 8006d54:	6bd2      	ldr	r2, [r2, #60]	; 0x3c
 8006d56:	6810      	ldr	r0, [r2, #0]
 8006d58:	900f      	str	r0, [sp, #60]	; 0x3c
 8006d5a:	981f      	ldr	r0, [sp, #124]	; 0x7c
 8006d5c:	b110      	cbz	r0, 8006d64 <LCD_DrawBitmap+0x1c4>
 8006d5e:	f850 3021 	ldr.w	r3, [r0, r1, lsl #2]
 8006d62:	e000      	b.n	8006d66 <LCD_DrawBitmap+0x1c6>
 8006d64:	b2db      	uxtb	r3, r3
 8006d66:	991a      	ldr	r1, [sp, #104]	; 0x68
 8006d68:	6013      	str	r3, [r2, #0]
 8006d6a:	1e4a      	subs	r2, r1, #1
 8006d6c:	4452      	add	r2, sl
 8006d6e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8006d70:	f8cd c020 	str.w	ip, [sp, #32]
 8006d74:	4650      	mov	r0, sl
 8006d76:	4641      	mov	r1, r8
 8006d78:	f7ff fee6 	bl	8006b48 <LCD_FillRect>
 8006d7c:	4b0a      	ldr	r3, [pc, #40]	; (8006da8 <LCD_DrawBitmap+0x208>)
 8006d7e:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8006d80:	681b      	ldr	r3, [r3, #0]
 8006d82:	f8dd c020 	ldr.w	ip, [sp, #32]
 8006d86:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8006d88:	601a      	str	r2, [r3, #0]
 8006d8a:	9b1a      	ldr	r3, [sp, #104]	; 0x68
 8006d8c:	f109 0901 	add.w	r9, r9, #1
 8006d90:	449a      	add	sl, r3
 8006d92:	e7c1      	b.n	8006d18 <LCD_DrawBitmap+0x178>
 8006d94:	991d      	ldr	r1, [sp, #116]	; 0x74
 8006d96:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 8006d9a:	f10c 0c01 	add.w	ip, ip, #1
 8006d9e:	440c      	add	r4, r1
 8006da0:	e7a3      	b.n	8006cea <LCD_DrawBitmap+0x14a>
 8006da2:	b011      	add	sp, #68	; 0x44
 8006da4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006da8:	20000060 	.word	0x20000060
 8006dac:	20022308 	.word	0x20022308
 8006db0:	200222e0 	.word	0x200222e0

08006db4 <LCD_SetClipRectMax>:
 8006db4:	b508      	push	{r3, lr}
 8006db6:	4b05      	ldr	r3, [pc, #20]	; (8006dcc <LCD_SetClipRectMax+0x18>)
 8006db8:	6819      	ldr	r1, [r3, #0]
 8006dba:	4b05      	ldr	r3, [pc, #20]	; (8006dd0 <LCD_SetClipRectMax+0x1c>)
 8006dbc:	7c4a      	ldrb	r2, [r1, #17]
 8006dbe:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 8006dc2:	68c3      	ldr	r3, [r0, #12]
 8006dc4:	3108      	adds	r1, #8
 8006dc6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8006dc8:	4798      	blx	r3
 8006dca:	bd08      	pop	{r3, pc}
 8006dcc:	20000060 	.word	0x20000060
 8006dd0:	20022308 	.word	0x20022308

08006dd4 <emWin_LCD_Init>:
 8006dd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006dd6:	f7ff ffed 	bl	8006db4 <LCD_SetClipRectMax>
 8006dda:	f001 ffb3 	bl	8008d44 <LCD_InitColors>
 8006dde:	4604      	mov	r4, r0
 8006de0:	2800      	cmp	r0, #0
 8006de2:	d13d      	bne.n	8006e60 <emWin_LCD_Init+0x8c>
 8006de4:	4605      	mov	r5, r0
 8006de6:	4628      	mov	r0, r5
 8006de8:	f000 fd02 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006dec:	9001      	str	r0, [sp, #4]
 8006dee:	b148      	cbz	r0, 8006e04 <emWin_LCD_Init+0x30>
 8006df0:	68c3      	ldr	r3, [r0, #12]
 8006df2:	210c      	movs	r1, #12
 8006df4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006df6:	a801      	add	r0, sp, #4
 8006df8:	4798      	blx	r3
 8006dfa:	4603      	mov	r3, r0
 8006dfc:	b370      	cbz	r0, 8006e5c <emWin_LCD_Init+0x88>
 8006dfe:	9801      	ldr	r0, [sp, #4]
 8006e00:	4798      	blx	r3
 8006e02:	4304      	orrs	r4, r0
 8006e04:	3501      	adds	r5, #1
 8006e06:	2d02      	cmp	r5, #2
 8006e08:	d1ed      	bne.n	8006de6 <emWin_LCD_Init+0x12>
 8006e0a:	bb4c      	cbnz	r4, 8006e60 <emWin_LCD_Init+0x8c>
 8006e0c:	f001 ffb6 	bl	8008d7c <LCD_InitLUT>
 8006e10:	2401      	movs	r4, #1
 8006e12:	4620      	mov	r0, r4
 8006e14:	f000 fcec 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006e18:	9001      	str	r0, [sp, #4]
 8006e1a:	b1d0      	cbz	r0, 8006e52 <emWin_LCD_Init+0x7e>
 8006e1c:	4620      	mov	r0, r4
 8006e1e:	f000 fb4b 	bl	80074b8 <GUI_SelectLayer>
 8006e22:	2004      	movs	r0, #4
 8006e24:	f7ff fe34 	bl	8006a90 <LCD_SetDrawMode>
 8006e28:	f643 72ff 	movw	r2, #16383	; 0x3fff
 8006e2c:	2000      	movs	r0, #0
 8006e2e:	4601      	mov	r1, r0
 8006e30:	4613      	mov	r3, r2
 8006e32:	f7ff fe89 	bl	8006b48 <LCD_FillRect>
 8006e36:	2000      	movs	r0, #0
 8006e38:	f7ff fe2a 	bl	8006a90 <LCD_SetDrawMode>
 8006e3c:	a802      	add	r0, sp, #8
 8006e3e:	210e      	movs	r1, #14
 8006e40:	f850 3d04 	ldr.w	r3, [r0, #-4]!
 8006e44:	68db      	ldr	r3, [r3, #12]
 8006e46:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006e48:	4798      	blx	r3
 8006e4a:	4603      	mov	r3, r0
 8006e4c:	b108      	cbz	r0, 8006e52 <emWin_LCD_Init+0x7e>
 8006e4e:	9801      	ldr	r0, [sp, #4]
 8006e50:	4798      	blx	r3
 8006e52:	f114 34ff 	adds.w	r4, r4, #4294967295
 8006e56:	d2dc      	bcs.n	8006e12 <emWin_LCD_Init+0x3e>
 8006e58:	2000      	movs	r0, #0
 8006e5a:	e002      	b.n	8006e62 <emWin_LCD_Init+0x8e>
 8006e5c:	2001      	movs	r0, #1
 8006e5e:	e000      	b.n	8006e62 <emWin_LCD_Init+0x8e>
 8006e60:	4620      	mov	r0, r4
 8006e62:	b003      	add	sp, #12
 8006e64:	bd30      	pop	{r4, r5, pc}
	...

08006e68 <LCD_Color2Index>:
 8006e68:	b508      	push	{r3, lr}
 8006e6a:	4b05      	ldr	r3, [pc, #20]	; (8006e80 <LCD_Color2Index+0x18>)
 8006e6c:	681b      	ldr	r3, [r3, #0]
 8006e6e:	7c5a      	ldrb	r2, [r3, #17]
 8006e70:	4b04      	ldr	r3, [pc, #16]	; (8006e84 <LCD_Color2Index+0x1c>)
 8006e72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006e76:	691b      	ldr	r3, [r3, #16]
 8006e78:	681b      	ldr	r3, [r3, #0]
 8006e7a:	4798      	blx	r3
 8006e7c:	bd08      	pop	{r3, pc}
 8006e7e:	bf00      	nop
 8006e80:	20000060 	.word	0x20000060
 8006e84:	20022308 	.word	0x20022308

08006e88 <LCD_Index2Color>:
 8006e88:	b508      	push	{r3, lr}
 8006e8a:	4b05      	ldr	r3, [pc, #20]	; (8006ea0 <LCD_Index2Color+0x18>)
 8006e8c:	681b      	ldr	r3, [r3, #0]
 8006e8e:	7c5a      	ldrb	r2, [r3, #17]
 8006e90:	4b04      	ldr	r3, [pc, #16]	; (8006ea4 <LCD_Index2Color+0x1c>)
 8006e92:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8006e96:	691b      	ldr	r3, [r3, #16]
 8006e98:	685b      	ldr	r3, [r3, #4]
 8006e9a:	4798      	blx	r3
 8006e9c:	bd08      	pop	{r3, pc}
 8006e9e:	bf00      	nop
 8006ea0:	20000060 	.word	0x20000060
 8006ea4:	20022308 	.word	0x20022308

08006ea8 <LCD_SetColorIndex>:
 8006ea8:	4b04      	ldr	r3, [pc, #16]	; (8006ebc <LCD_SetColorIndex+0x14>)
 8006eaa:	681b      	ldr	r3, [r3, #0]
 8006eac:	7c1a      	ldrb	r2, [r3, #16]
 8006eae:	0752      	lsls	r2, r2, #29
 8006eb0:	bf4c      	ite	mi
 8006eb2:	6b9b      	ldrmi	r3, [r3, #56]	; 0x38
 8006eb4:	6bdb      	ldrpl	r3, [r3, #60]	; 0x3c
 8006eb6:	6018      	str	r0, [r3, #0]
 8006eb8:	4770      	bx	lr
 8006eba:	bf00      	nop
 8006ebc:	20000060 	.word	0x20000060

08006ec0 <_SetColor>:
 8006ec0:	b508      	push	{r3, lr}
 8006ec2:	4b06      	ldr	r3, [pc, #24]	; (8006edc <_SetColor+0x1c>)
 8006ec4:	681b      	ldr	r3, [r3, #0]
 8006ec6:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8006ec8:	4281      	cmp	r1, r0
 8006eca:	d006      	beq.n	8006eda <_SetColor+0x1a>
 8006ecc:	6318      	str	r0, [r3, #48]	; 0x30
 8006ece:	f7ff ffcb 	bl	8006e68 <LCD_Color2Index>
 8006ed2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8006ed6:	f7ff bfe7 	b.w	8006ea8 <LCD_SetColorIndex>
 8006eda:	bd08      	pop	{r3, pc}
 8006edc:	20000060 	.word	0x20000060

08006ee0 <LCD_SetBkColorIndex>:
 8006ee0:	4b04      	ldr	r3, [pc, #16]	; (8006ef4 <LCD_SetBkColorIndex+0x14>)
 8006ee2:	681b      	ldr	r3, [r3, #0]
 8006ee4:	7c1a      	ldrb	r2, [r3, #16]
 8006ee6:	0752      	lsls	r2, r2, #29
 8006ee8:	bf4c      	ite	mi
 8006eea:	6bdb      	ldrmi	r3, [r3, #60]	; 0x3c
 8006eec:	6b9b      	ldrpl	r3, [r3, #56]	; 0x38
 8006eee:	6018      	str	r0, [r3, #0]
 8006ef0:	4770      	bx	lr
 8006ef2:	bf00      	nop
 8006ef4:	20000060 	.word	0x20000060

08006ef8 <_SetBkColor>:
 8006ef8:	b508      	push	{r3, lr}
 8006efa:	4b06      	ldr	r3, [pc, #24]	; (8006f14 <_SetBkColor+0x1c>)
 8006efc:	681b      	ldr	r3, [r3, #0]
 8006efe:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8006f00:	4281      	cmp	r1, r0
 8006f02:	d006      	beq.n	8006f12 <_SetBkColor+0x1a>
 8006f04:	6358      	str	r0, [r3, #52]	; 0x34
 8006f06:	f7ff ffaf 	bl	8006e68 <LCD_Color2Index>
 8006f0a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8006f0e:	f7ff bfe7 	b.w	8006ee0 <LCD_SetBkColorIndex>
 8006f12:	bd08      	pop	{r3, pc}
 8006f14:	20000060 	.word	0x20000060

08006f18 <LCD_SetBkColor>:
 8006f18:	b508      	push	{r3, lr}
 8006f1a:	4b02      	ldr	r3, [pc, #8]	; (8006f24 <LCD_SetBkColor+0xc>)
 8006f1c:	681b      	ldr	r3, [r3, #0]
 8006f1e:	685b      	ldr	r3, [r3, #4]
 8006f20:	4798      	blx	r3
 8006f22:	bd08      	pop	{r3, pc}
 8006f24:	2000005c 	.word	0x2000005c

08006f28 <LCD_SetColor>:
 8006f28:	b508      	push	{r3, lr}
 8006f2a:	4b02      	ldr	r3, [pc, #8]	; (8006f34 <LCD_SetColor+0xc>)
 8006f2c:	681b      	ldr	r3, [r3, #0]
 8006f2e:	681b      	ldr	r3, [r3, #0]
 8006f30:	4798      	blx	r3
 8006f32:	bd08      	pop	{r3, pc}
 8006f34:	2000005c 	.word	0x2000005c

08006f38 <GUI__memset>:
 8006f38:	b570      	push	{r4, r5, r6, lr}
 8006f3a:	b12a      	cbz	r2, 8006f48 <GUI__memset+0x10>
 8006f3c:	0783      	lsls	r3, r0, #30
 8006f3e:	d003      	beq.n	8006f48 <GUI__memset+0x10>
 8006f40:	f800 1b01 	strb.w	r1, [r0], #1
 8006f44:	3a01      	subs	r2, #1
 8006f46:	e7f8      	b.n	8006f3a <GUI__memset+0x2>
 8006f48:	0893      	lsrs	r3, r2, #2
 8006f4a:	d101      	bne.n	8006f50 <GUI__memset+0x18>
 8006f4c:	4402      	add	r2, r0
 8006f4e:	e017      	b.n	8006f80 <GUI__memset+0x48>
 8006f50:	f04f 3401 	mov.w	r4, #16843009	; 0x1010101
 8006f54:	f002 0203 	and.w	r2, r2, #3
 8006f58:	434c      	muls	r4, r1
 8006f5a:	2b03      	cmp	r3, #3
 8006f5c:	4605      	mov	r5, r0
 8006f5e:	dd06      	ble.n	8006f6e <GUI__memset+0x36>
 8006f60:	6004      	str	r4, [r0, #0]
 8006f62:	6044      	str	r4, [r0, #4]
 8006f64:	6084      	str	r4, [r0, #8]
 8006f66:	60c4      	str	r4, [r0, #12]
 8006f68:	3b04      	subs	r3, #4
 8006f6a:	3010      	adds	r0, #16
 8006f6c:	e7f5      	b.n	8006f5a <GUI__memset+0x22>
 8006f6e:	461e      	mov	r6, r3
 8006f70:	b11b      	cbz	r3, 8006f7a <GUI__memset+0x42>
 8006f72:	f845 4b04 	str.w	r4, [r5], #4
 8006f76:	3b01      	subs	r3, #1
 8006f78:	e7fa      	b.n	8006f70 <GUI__memset+0x38>
 8006f7a:	eb00 0086 	add.w	r0, r0, r6, lsl #2
 8006f7e:	e7e5      	b.n	8006f4c <GUI__memset+0x14>
 8006f80:	4290      	cmp	r0, r2
 8006f82:	d002      	beq.n	8006f8a <GUI__memset+0x52>
 8006f84:	f800 1b01 	strb.w	r1, [r0], #1
 8006f88:	e7fa      	b.n	8006f80 <GUI__memset+0x48>
 8006f8a:	bd70      	pop	{r4, r5, r6, pc}

08006f8c <GUI__ManageCacheEx>:
 8006f8c:	2801      	cmp	r0, #1
 8006f8e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8006f90:	4604      	mov	r4, r0
 8006f92:	460d      	mov	r5, r1
 8006f94:	dc5e      	bgt.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006f96:	2901      	cmp	r1, #1
 8006f98:	d004      	beq.n	8006fa4 <GUI__ManageCacheEx+0x18>
 8006f9a:	2902      	cmp	r1, #2
 8006f9c:	d020      	beq.n	8006fe0 <GUI__ManageCacheEx+0x54>
 8006f9e:	2900      	cmp	r1, #0
 8006fa0:	d158      	bne.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006fa2:	e033      	b.n	800700c <GUI__ManageCacheEx+0x80>
 8006fa4:	4e2d      	ldr	r6, [pc, #180]	; (800705c <GUI__ManageCacheEx+0xd0>)
 8006fa6:	f856 7020 	ldr.w	r7, [r6, r0, lsl #2]
 8006faa:	b9af      	cbnz	r7, 8006fd8 <GUI__ManageCacheEx+0x4c>
 8006fac:	f000 fc20 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006fb0:	9001      	str	r0, [sp, #4]
 8006fb2:	2800      	cmp	r0, #0
 8006fb4:	d04e      	beq.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006fb6:	68c3      	ldr	r3, [r0, #12]
 8006fb8:	210d      	movs	r1, #13
 8006fba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006fbc:	a801      	add	r0, sp, #4
 8006fbe:	4798      	blx	r3
 8006fc0:	4603      	mov	r3, r0
 8006fc2:	2800      	cmp	r0, #0
 8006fc4:	d046      	beq.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006fc6:	9801      	ldr	r0, [sp, #4]
 8006fc8:	4629      	mov	r1, r5
 8006fca:	4798      	blx	r3
 8006fcc:	f856 3024 	ldr.w	r3, [r6, r4, lsl #2]
 8006fd0:	3301      	adds	r3, #1
 8006fd2:	f846 3024 	str.w	r3, [r6, r4, lsl #2]
 8006fd6:	e017      	b.n	8007008 <GUI__ManageCacheEx+0x7c>
 8006fd8:	3701      	adds	r7, #1
 8006fda:	f846 7020 	str.w	r7, [r6, r0, lsl #2]
 8006fde:	e039      	b.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006fe0:	f000 fc06 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8006fe4:	9001      	str	r0, [sp, #4]
 8006fe6:	2800      	cmp	r0, #0
 8006fe8:	d034      	beq.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006fea:	68c3      	ldr	r3, [r0, #12]
 8006fec:	210d      	movs	r1, #13
 8006fee:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006ff0:	a801      	add	r0, sp, #4
 8006ff2:	4798      	blx	r3
 8006ff4:	4604      	mov	r4, r0
 8006ff6:	2800      	cmp	r0, #0
 8006ff8:	d02c      	beq.n	8007054 <GUI__ManageCacheEx+0xc8>
 8006ffa:	4b19      	ldr	r3, [pc, #100]	; (8007060 <GUI__ManageCacheEx+0xd4>)
 8006ffc:	681b      	ldr	r3, [r3, #0]
 8006ffe:	b103      	cbz	r3, 8007002 <GUI__ManageCacheEx+0x76>
 8007000:	4798      	blx	r3
 8007002:	9801      	ldr	r0, [sp, #4]
 8007004:	2102      	movs	r1, #2
 8007006:	47a0      	blx	r4
 8007008:	2000      	movs	r0, #0
 800700a:	e024      	b.n	8007056 <GUI__ManageCacheEx+0xca>
 800700c:	4d13      	ldr	r5, [pc, #76]	; (800705c <GUI__ManageCacheEx+0xd0>)
 800700e:	f855 3020 	ldr.w	r3, [r5, r0, lsl #2]
 8007012:	2b01      	cmp	r3, #1
 8007014:	d001      	beq.n	800701a <GUI__ManageCacheEx+0x8e>
 8007016:	2001      	movs	r0, #1
 8007018:	e014      	b.n	8007044 <GUI__ManageCacheEx+0xb8>
 800701a:	f000 fbe9 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 800701e:	9001      	str	r0, [sp, #4]
 8007020:	2800      	cmp	r0, #0
 8007022:	d0f8      	beq.n	8007016 <GUI__ManageCacheEx+0x8a>
 8007024:	68c3      	ldr	r3, [r0, #12]
 8007026:	210d      	movs	r1, #13
 8007028:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800702a:	a801      	add	r0, sp, #4
 800702c:	4798      	blx	r3
 800702e:	4606      	mov	r6, r0
 8007030:	2800      	cmp	r0, #0
 8007032:	d0f0      	beq.n	8007016 <GUI__ManageCacheEx+0x8a>
 8007034:	4b0a      	ldr	r3, [pc, #40]	; (8007060 <GUI__ManageCacheEx+0xd4>)
 8007036:	681b      	ldr	r3, [r3, #0]
 8007038:	b103      	cbz	r3, 800703c <GUI__ManageCacheEx+0xb0>
 800703a:	4798      	blx	r3
 800703c:	9801      	ldr	r0, [sp, #4]
 800703e:	2100      	movs	r1, #0
 8007040:	47b0      	blx	r6
 8007042:	2000      	movs	r0, #0
 8007044:	f855 3024 	ldr.w	r3, [r5, r4, lsl #2]
 8007048:	2b00      	cmp	r3, #0
 800704a:	bf18      	it	ne
 800704c:	3b01      	subne	r3, #1
 800704e:	f845 3024 	str.w	r3, [r5, r4, lsl #2]
 8007052:	e000      	b.n	8007056 <GUI__ManageCacheEx+0xca>
 8007054:	2001      	movs	r0, #1
 8007056:	b003      	add	sp, #12
 8007058:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800705a:	bf00      	nop
 800705c:	20001fc4 	.word	0x20001fc4
 8007060:	20001fc0 	.word	0x20001fc0

08007064 <GUI__ManageCache>:
 8007064:	4b02      	ldr	r3, [pc, #8]	; (8007070 <GUI__ManageCache+0xc>)
 8007066:	681b      	ldr	r3, [r3, #0]
 8007068:	4601      	mov	r1, r0
 800706a:	7c58      	ldrb	r0, [r3, #17]
 800706c:	f7ff bf8e 	b.w	8006f8c <GUI__ManageCacheEx>
 8007070:	20000060 	.word	0x20000060

08007074 <GUI__IntersectRects>:
 8007074:	b570      	push	{r4, r5, r6, lr}
 8007076:	f9b2 3000 	ldrsh.w	r3, [r2]
 800707a:	f9b1 4000 	ldrsh.w	r4, [r1]
 800707e:	f9b1 5002 	ldrsh.w	r5, [r1, #2]
 8007082:	f9b1 6004 	ldrsh.w	r6, [r1, #4]
 8007086:	f9b1 1006 	ldrsh.w	r1, [r1, #6]
 800708a:	429c      	cmp	r4, r3
 800708c:	bfb8      	it	lt
 800708e:	461c      	movlt	r4, r3
 8007090:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
 8007094:	429d      	cmp	r5, r3
 8007096:	bfa8      	it	ge
 8007098:	462b      	movge	r3, r5
 800709a:	f9b2 5004 	ldrsh.w	r5, [r2, #4]
 800709e:	f9b2 2006 	ldrsh.w	r2, [r2, #6]
 80070a2:	42ae      	cmp	r6, r5
 80070a4:	bfb8      	it	lt
 80070a6:	4635      	movlt	r5, r6
 80070a8:	b2a4      	uxth	r4, r4
 80070aa:	b2ad      	uxth	r5, r5
 80070ac:	4291      	cmp	r1, r2
 80070ae:	bfb8      	it	lt
 80070b0:	460a      	movlt	r2, r1
 80070b2:	8004      	strh	r4, [r0, #0]
 80070b4:	8085      	strh	r5, [r0, #4]
 80070b6:	b224      	sxth	r4, r4
 80070b8:	b22d      	sxth	r5, r5
 80070ba:	b29b      	uxth	r3, r3
 80070bc:	b292      	uxth	r2, r2
 80070be:	42a5      	cmp	r5, r4
 80070c0:	8043      	strh	r3, [r0, #2]
 80070c2:	80c2      	strh	r2, [r0, #6]
 80070c4:	db06      	blt.n	80070d4 <GUI__IntersectRects+0x60>
 80070c6:	b210      	sxth	r0, r2
 80070c8:	b21b      	sxth	r3, r3
 80070ca:	4298      	cmp	r0, r3
 80070cc:	bfb4      	ite	lt
 80070ce:	2000      	movlt	r0, #0
 80070d0:	2001      	movge	r0, #1
 80070d2:	bd70      	pop	{r4, r5, r6, pc}
 80070d4:	2000      	movs	r0, #0
 80070d6:	bd70      	pop	{r4, r5, r6, pc}

080070d8 <GUI__IntersectRect>:
 80070d8:	880b      	ldrh	r3, [r1, #0]
 80070da:	b510      	push	{r4, lr}
 80070dc:	f9b0 4000 	ldrsh.w	r4, [r0]
 80070e0:	b21a      	sxth	r2, r3
 80070e2:	4294      	cmp	r4, r2
 80070e4:	bfb8      	it	lt
 80070e6:	8003      	strhlt	r3, [r0, #0]
 80070e8:	884b      	ldrh	r3, [r1, #2]
 80070ea:	f9b0 4002 	ldrsh.w	r4, [r0, #2]
 80070ee:	b21a      	sxth	r2, r3
 80070f0:	4294      	cmp	r4, r2
 80070f2:	bfb8      	it	lt
 80070f4:	8043      	strhlt	r3, [r0, #2]
 80070f6:	888b      	ldrh	r3, [r1, #4]
 80070f8:	f9b0 4004 	ldrsh.w	r4, [r0, #4]
 80070fc:	b21a      	sxth	r2, r3
 80070fe:	4294      	cmp	r4, r2
 8007100:	bfc8      	it	gt
 8007102:	8083      	strhgt	r3, [r0, #4]
 8007104:	88cb      	ldrh	r3, [r1, #6]
 8007106:	f9b0 1006 	ldrsh.w	r1, [r0, #6]
 800710a:	b21a      	sxth	r2, r3
 800710c:	4291      	cmp	r1, r2
 800710e:	bfc8      	it	gt
 8007110:	80c3      	strhgt	r3, [r0, #6]
 8007112:	bd10      	pop	{r4, pc}

08007114 <GUI__MixColors>:
 8007114:	f001 437f 	and.w	r3, r1, #4278190080	; 0xff000000
 8007118:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 800711c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800711e:	d027      	beq.n	8007170 <GUI__MixColors+0x5c>
 8007120:	43d3      	mvns	r3, r2
 8007122:	b2db      	uxtb	r3, r3
 8007124:	b2cd      	uxtb	r5, r1
 8007126:	b2c6      	uxtb	r6, r0
 8007128:	435d      	muls	r5, r3
 800712a:	fb02 5506 	mla	r5, r2, r6, r5
 800712e:	f401 467f 	and.w	r6, r1, #65280	; 0xff00
 8007132:	f400 447f 	and.w	r4, r0, #65280	; 0xff00
 8007136:	435e      	muls	r6, r3
 8007138:	fb02 6604 	mla	r6, r2, r4, r6
 800713c:	f401 047f 	and.w	r4, r1, #16711680	; 0xff0000
 8007140:	f400 077f 	and.w	r7, r0, #16711680	; 0xff0000
 8007144:	435c      	muls	r4, r3
 8007146:	0e09      	lsrs	r1, r1, #24
 8007148:	0e00      	lsrs	r0, r0, #24
 800714a:	fb02 4407 	mla	r4, r2, r7, r4
 800714e:	434b      	muls	r3, r1
 8007150:	0a36      	lsrs	r6, r6, #8
 8007152:	fb02 3200 	mla	r2, r2, r0, r3
 8007156:	0a24      	lsrs	r4, r4, #8
 8007158:	f3c5 2307 	ubfx	r3, r5, #8, #8
 800715c:	f406 407f 	and.w	r0, r6, #65280	; 0xff00
 8007160:	4318      	orrs	r0, r3
 8007162:	0412      	lsls	r2, r2, #16
 8007164:	f404 037f 	and.w	r3, r4, #16711680	; 0xff0000
 8007168:	4318      	orrs	r0, r3
 800716a:	f002 427f 	and.w	r2, r2, #4278190080	; 0xff000000
 800716e:	4310      	orrs	r0, r2
 8007170:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08007174 <_OnExit>:
 8007174:	b570      	push	{r4, r5, r6, lr}
 8007176:	4c0a      	ldr	r4, [pc, #40]	; (80071a0 <_OnExit+0x2c>)
 8007178:	4d0a      	ldr	r5, [pc, #40]	; (80071a4 <_OnExit+0x30>)
 800717a:	6820      	ldr	r0, [r4, #0]
 800717c:	4e0a      	ldr	r6, [pc, #40]	; (80071a8 <_OnExit+0x34>)
 800717e:	f001 f857 	bl	8008230 <GUI_ALLOC_FreeFixedBlock>
 8007182:	6828      	ldr	r0, [r5, #0]
 8007184:	f001 f854 	bl	8008230 <GUI_ALLOC_FreeFixedBlock>
 8007188:	6830      	ldr	r0, [r6, #0]
 800718a:	f001 f851 	bl	8008230 <GUI_ALLOC_FreeFixedBlock>
 800718e:	4a07      	ldr	r2, [pc, #28]	; (80071ac <_OnExit+0x38>)
 8007190:	2300      	movs	r3, #0
 8007192:	6013      	str	r3, [r2, #0]
 8007194:	4a06      	ldr	r2, [pc, #24]	; (80071b0 <_OnExit+0x3c>)
 8007196:	6033      	str	r3, [r6, #0]
 8007198:	602b      	str	r3, [r5, #0]
 800719a:	6023      	str	r3, [r4, #0]
 800719c:	6013      	str	r3, [r2, #0]
 800719e:	bd70      	pop	{r4, r5, r6, pc}
 80071a0:	20001fd0 	.word	0x20001fd0
 80071a4:	20001fcc 	.word	0x20001fcc
 80071a8:	20001fd4 	.word	0x20001fd4
 80071ac:	20001fd8 	.word	0x20001fd8
 80071b0:	20001fe8 	.word	0x20001fe8

080071b4 <GUI__GetAlphaBuffer>:
 80071b4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80071b8:	461c      	mov	r4, r3
 80071ba:	4b28      	ldr	r3, [pc, #160]	; (800725c <GUI__GetAlphaBuffer+0xa8>)
 80071bc:	4617      	mov	r7, r2
 80071be:	681a      	ldr	r2, [r3, #0]
 80071c0:	4606      	mov	r6, r0
 80071c2:	4688      	mov	r8, r1
 80071c4:	b932      	cbnz	r2, 80071d4 <GUI__GetAlphaBuffer+0x20>
 80071c6:	2201      	movs	r2, #1
 80071c8:	4825      	ldr	r0, [pc, #148]	; (8007260 <GUI__GetAlphaBuffer+0xac>)
 80071ca:	601a      	str	r2, [r3, #0]
 80071cc:	4b25      	ldr	r3, [pc, #148]	; (8007264 <GUI__GetAlphaBuffer+0xb0>)
 80071ce:	6003      	str	r3, [r0, #0]
 80071d0:	f000 fc34 	bl	8007a3c <GUI__RegisterExit>
 80071d4:	4d24      	ldr	r5, [pc, #144]	; (8007268 <GUI__GetAlphaBuffer+0xb4>)
 80071d6:	682b      	ldr	r3, [r5, #0]
 80071d8:	b933      	cbnz	r3, 80071e8 <GUI__GetAlphaBuffer+0x34>
 80071da:	4b24      	ldr	r3, [pc, #144]	; (800726c <GUI__GetAlphaBuffer+0xb8>)
 80071dc:	681b      	ldr	r3, [r3, #0]
 80071de:	602b      	str	r3, [r5, #0]
 80071e0:	b913      	cbnz	r3, 80071e8 <GUI__GetAlphaBuffer+0x34>
 80071e2:	f7ff fc3d 	bl	8006a60 <LCD_GetVXSizeMax>
 80071e6:	6028      	str	r0, [r5, #0]
 80071e8:	b10c      	cbz	r4, 80071ee <GUI__GetAlphaBuffer+0x3a>
 80071ea:	682b      	ldr	r3, [r5, #0]
 80071ec:	6023      	str	r3, [r4, #0]
 80071ee:	b196      	cbz	r6, 8007216 <GUI__GetAlphaBuffer+0x62>
 80071f0:	4b1f      	ldr	r3, [pc, #124]	; (8007270 <GUI__GetAlphaBuffer+0xbc>)
 80071f2:	681a      	ldr	r2, [r3, #0]
 80071f4:	4699      	mov	r9, r3
 80071f6:	2400      	movs	r4, #0
 80071f8:	b94a      	cbnz	r2, 800720e <GUI__GetAlphaBuffer+0x5a>
 80071fa:	6828      	ldr	r0, [r5, #0]
 80071fc:	0080      	lsls	r0, r0, #2
 80071fe:	f001 f977 	bl	80084f0 <GUI_ALLOC_GetFixedBlock>
 8007202:	f1d0 0401 	rsbs	r4, r0, #1
 8007206:	f8c9 0000 	str.w	r0, [r9]
 800720a:	bf38      	it	cc
 800720c:	2400      	movcc	r4, #0
 800720e:	f8d9 3000 	ldr.w	r3, [r9]
 8007212:	6033      	str	r3, [r6, #0]
 8007214:	e000      	b.n	8007218 <GUI__GetAlphaBuffer+0x64>
 8007216:	4634      	mov	r4, r6
 8007218:	f1b8 0f00 	cmp.w	r8, #0
 800721c:	d00d      	beq.n	800723a <GUI__GetAlphaBuffer+0x86>
 800721e:	4e15      	ldr	r6, [pc, #84]	; (8007274 <GUI__GetAlphaBuffer+0xc0>)
 8007220:	6833      	ldr	r3, [r6, #0]
 8007222:	b93b      	cbnz	r3, 8007234 <GUI__GetAlphaBuffer+0x80>
 8007224:	6828      	ldr	r0, [r5, #0]
 8007226:	0080      	lsls	r0, r0, #2
 8007228:	f001 f962 	bl	80084f0 <GUI_ALLOC_GetFixedBlock>
 800722c:	2800      	cmp	r0, #0
 800722e:	6030      	str	r0, [r6, #0]
 8007230:	bf08      	it	eq
 8007232:	2401      	moveq	r4, #1
 8007234:	6833      	ldr	r3, [r6, #0]
 8007236:	f8c8 3000 	str.w	r3, [r8]
 800723a:	b167      	cbz	r7, 8007256 <GUI__GetAlphaBuffer+0xa2>
 800723c:	4e0e      	ldr	r6, [pc, #56]	; (8007278 <GUI__GetAlphaBuffer+0xc4>)
 800723e:	6833      	ldr	r3, [r6, #0]
 8007240:	b93b      	cbnz	r3, 8007252 <GUI__GetAlphaBuffer+0x9e>
 8007242:	6828      	ldr	r0, [r5, #0]
 8007244:	0080      	lsls	r0, r0, #2
 8007246:	f001 f953 	bl	80084f0 <GUI_ALLOC_GetFixedBlock>
 800724a:	2800      	cmp	r0, #0
 800724c:	6030      	str	r0, [r6, #0]
 800724e:	bf08      	it	eq
 8007250:	2401      	moveq	r4, #1
 8007252:	6833      	ldr	r3, [r6, #0]
 8007254:	603b      	str	r3, [r7, #0]
 8007256:	4620      	mov	r0, r4
 8007258:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800725c:	20001fe8 	.word	0x20001fe8
 8007260:	20001fe0 	.word	0x20001fe0
 8007264:	08007175 	.word	0x08007175
 8007268:	20001fd8 	.word	0x20001fd8
 800726c:	20022310 	.word	0x20022310
 8007270:	20001fd0 	.word	0x20001fd0
 8007274:	20001fcc 	.word	0x20001fcc
 8007278:	20001fd4 	.word	0x20001fd4

0800727c <GUI__DoAlphaBlending>:
 800727c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007280:	b093      	sub	sp, #76	; 0x4c
 8007282:	2400      	movs	r4, #0
 8007284:	9e1d      	ldr	r6, [sp, #116]	; 0x74
 8007286:	900b      	str	r0, [sp, #44]	; 0x2c
 8007288:	910c      	str	r1, [sp, #48]	; 0x30
 800728a:	4690      	mov	r8, r2
 800728c:	461f      	mov	r7, r3
 800728e:	6034      	str	r4, [r6, #0]
 8007290:	a80f      	add	r0, sp, #60	; 0x3c
 8007292:	a910      	add	r1, sp, #64	; 0x40
 8007294:	4622      	mov	r2, r4
 8007296:	ab11      	add	r3, sp, #68	; 0x44
 8007298:	f7ff ff8c 	bl	80071b4 <GUI__GetAlphaBuffer>
 800729c:	4605      	mov	r5, r0
 800729e:	2800      	cmp	r0, #0
 80072a0:	f040 80c3 	bne.w	800742a <GUI__DoAlphaBlending+0x1ae>
 80072a4:	4c63      	ldr	r4, [pc, #396]	; (8007434 <GUI__DoAlphaBlending+0x1b8>)
 80072a6:	9a11      	ldr	r2, [sp, #68]	; 0x44
 80072a8:	6823      	ldr	r3, [r4, #0]
 80072aa:	7c58      	ldrb	r0, [r3, #17]
 80072ac:	4b62      	ldr	r3, [pc, #392]	; (8007438 <GUI__DoAlphaBlending+0x1bc>)
 80072ae:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
 80072b2:	9307      	str	r3, [sp, #28]
 80072b4:	4297      	cmp	r7, r2
 80072b6:	bfa8      	it	ge
 80072b8:	4617      	movge	r7, r2
 80072ba:	691a      	ldr	r2, [r3, #16]
 80072bc:	920d      	str	r2, [sp, #52]	; 0x34
 80072be:	970a      	str	r7, [sp, #40]	; 0x28
 80072c0:	f7ff fba8 	bl	8006a14 <GUI_GetBitsPerPixelEx>
 80072c4:	6823      	ldr	r3, [r4, #0]
 80072c6:	9008      	str	r0, [sp, #32]
 80072c8:	7c58      	ldrb	r0, [r3, #17]
 80072ca:	f7ff fbc1 	bl	8006a50 <GUI_GetpfIndex2ColorEx>
 80072ce:	4b5b      	ldr	r3, [pc, #364]	; (800743c <GUI__DoAlphaBlending+0x1c0>)
 80072d0:	9004      	str	r0, [sp, #16]
 80072d2:	4298      	cmp	r0, r3
 80072d4:	d005      	beq.n	80072e2 <GUI__DoAlphaBlending+0x66>
 80072d6:	4b5a      	ldr	r3, [pc, #360]	; (8007440 <GUI__DoAlphaBlending+0x1c4>)
 80072d8:	1ac3      	subs	r3, r0, r3
 80072da:	bf18      	it	ne
 80072dc:	2301      	movne	r3, #1
 80072de:	9306      	str	r3, [sp, #24]
 80072e0:	e000      	b.n	80072e4 <GUI__DoAlphaBlending+0x68>
 80072e2:	9506      	str	r5, [sp, #24]
 80072e4:	2500      	movs	r5, #0
 80072e6:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80072e8:	46ab      	mov	fp, r5
 80072ea:	4643      	mov	r3, r8
 80072ec:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 80072ee:	f853 0b04 	ldr.w	r0, [r3], #4
 80072f2:	9305      	str	r3, [sp, #20]
 80072f4:	4790      	blx	r2
 80072f6:	0e03      	lsrs	r3, r0, #24
 80072f8:	4681      	mov	r9, r0
 80072fa:	9309      	str	r3, [sp, #36]	; 0x24
 80072fc:	f000 8085 	beq.w	800740a <GUI__DoAlphaBlending+0x18e>
 8007300:	f1bb 0f00 	cmp.w	fp, #0
 8007304:	d13f      	bne.n	8007386 <GUI__DoAlphaBlending+0x10a>
 8007306:	4b4b      	ldr	r3, [pc, #300]	; (8007434 <GUI__DoAlphaBlending+0x1b8>)
 8007308:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
 800730a:	681b      	ldr	r3, [r3, #0]
 800730c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 800730e:	f9b3 3008 	ldrsh.w	r3, [r3, #8]
 8007312:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 8007316:	990c      	ldr	r1, [sp, #48]	; 0x30
 8007318:	442f      	add	r7, r5
 800731a:	42bb      	cmp	r3, r7
 800731c:	bfc8      	it	gt
 800731e:	ebc7 0b03 	rsbgt	fp, r7, r3
 8007322:	eb0b 0a05 	add.w	sl, fp, r5
 8007326:	bfc8      	it	gt
 8007328:	461f      	movgt	r7, r3
 800732a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800732c:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 8007330:	4453      	add	r3, sl
 8007332:	4494      	add	ip, r2
 8007334:	9300      	str	r3, [sp, #0]
 8007336:	9b07      	ldr	r3, [sp, #28]
 8007338:	9301      	str	r3, [sp, #4]
 800733a:	f10c 32ff 	add.w	r2, ip, #4294967295
 800733e:	4638      	mov	r0, r7
 8007340:	460b      	mov	r3, r1
 8007342:	f8cd c00c 	str.w	ip, [sp, #12]
 8007346:	f001 fcc3 	bl	8008cd0 <GUI_ReadRectEx>
 800734a:	9a08      	ldr	r2, [sp, #32]
 800734c:	980f      	ldr	r0, [sp, #60]	; 0x3c
 800734e:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8007352:	2a17      	cmp	r2, #23
 8007354:	dc06      	bgt.n	8007364 <GUI__DoAlphaBlending+0xe8>
 8007356:	4450      	add	r0, sl
 8007358:	ebcb 0104 	rsb	r1, fp, r4
 800735c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800735e:	f001 fd4b 	bl	8008df8 <GUI__ExpandPixelIndicesEx>
 8007362:	e001      	b.n	8007368 <GUI__DoAlphaBlending+0xec>
 8007364:	9b06      	ldr	r3, [sp, #24]
 8007366:	b913      	cbnz	r3, 800736e <GUI__DoAlphaBlending+0xf2>
 8007368:	f04f 0b01 	mov.w	fp, #1
 800736c:	e00b      	b.n	8007386 <GUI__DoAlphaBlending+0x10a>
 800736e:	ebc7 070c 	rsb	r7, r7, ip
 8007372:	4482      	add	sl, r0
 8007374:	f8da 0000 	ldr.w	r0, [sl]
 8007378:	9a04      	ldr	r2, [sp, #16]
 800737a:	4790      	blx	r2
 800737c:	3f01      	subs	r7, #1
 800737e:	f84a 0b04 	str.w	r0, [sl], #4
 8007382:	d1f7      	bne.n	8007374 <GUI__DoAlphaBlending+0xf8>
 8007384:	e7f0      	b.n	8007368 <GUI__DoAlphaBlending+0xec>
 8007386:	4b2f      	ldr	r3, [pc, #188]	; (8007444 <GUI__DoAlphaBlending+0x1c8>)
 8007388:	990f      	ldr	r1, [sp, #60]	; 0x3c
 800738a:	f8d3 c000 	ldr.w	ip, [r3]
 800738e:	9f10      	ldr	r7, [sp, #64]	; 0x40
 8007390:	ea4f 0a85 	mov.w	sl, r5, lsl #2
 8007394:	f1bc 0f00 	cmp.w	ip, #0
 8007398:	d024      	beq.n	80073e4 <GUI__DoAlphaBlending+0x168>
 800739a:	eb07 020a 	add.w	r2, r7, sl
 800739e:	4451      	add	r1, sl
 80073a0:	9210      	str	r2, [sp, #64]	; 0x40
 80073a2:	4623      	mov	r3, r4
 80073a4:	910f      	str	r1, [sp, #60]	; 0x3c
 80073a6:	4640      	mov	r0, r8
 80073a8:	47e0      	blx	ip
 80073aa:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 80073ac:	9a10      	ldr	r2, [sp, #64]	; 0x40
 80073ae:	2300      	movs	r3, #0
 80073b0:	f858 1003 	ldr.w	r1, [r8, r3]
 80073b4:	f001 407f 	and.w	r0, r1, #4278190080	; 0xff000000
 80073b8:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
 80073bc:	58e8      	ldr	r0, [r5, r3]
 80073be:	d101      	bne.n	80073c4 <GUI__DoAlphaBlending+0x148>
 80073c0:	50d0      	str	r0, [r2, r3]
 80073c2:	e005      	b.n	80073d0 <GUI__DoAlphaBlending+0x154>
 80073c4:	f000 407f 	and.w	r0, r0, #4278190080	; 0xff000000
 80073c8:	f1b0 4f7f 	cmp.w	r0, #4278190080	; 0xff000000
 80073cc:	bf08      	it	eq
 80073ce:	50d1      	streq	r1, [r2, r3]
 80073d0:	3c01      	subs	r4, #1
 80073d2:	f103 0304 	add.w	r3, r3, #4
 80073d6:	d1eb      	bne.n	80073b0 <GUI__DoAlphaBlending+0x134>
 80073d8:	6833      	ldr	r3, [r6, #0]
 80073da:	9710      	str	r7, [sp, #64]	; 0x40
 80073dc:	f043 0301 	orr.w	r3, r3, #1
 80073e0:	6033      	str	r3, [r6, #0]
 80073e2:	e020      	b.n	8007426 <GUI__DoAlphaBlending+0x1aa>
 80073e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80073e6:	2bff      	cmp	r3, #255	; 0xff
 80073e8:	d104      	bne.n	80073f4 <GUI__DoAlphaBlending+0x178>
 80073ea:	f851 300a 	ldr.w	r3, [r1, sl]
 80073ee:	f847 300a 	str.w	r3, [r7, sl]
 80073f2:	e011      	b.n	8007418 <GUI__DoAlphaBlending+0x19c>
 80073f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80073f6:	f851 100a 	ldr.w	r1, [r1, sl]
 80073fa:	43da      	mvns	r2, r3
 80073fc:	4648      	mov	r0, r9
 80073fe:	b2d2      	uxtb	r2, r2
 8007400:	f7ff fe88 	bl	8007114 <GUI__MixColors>
 8007404:	f847 000a 	str.w	r0, [r7, sl]
 8007408:	e002      	b.n	8007410 <GUI__DoAlphaBlending+0x194>
 800740a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 800740c:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
 8007410:	6833      	ldr	r3, [r6, #0]
 8007412:	f043 0301 	orr.w	r3, r3, #1
 8007416:	6033      	str	r3, [r6, #0]
 8007418:	3c01      	subs	r4, #1
 800741a:	f105 0501 	add.w	r5, r5, #1
 800741e:	d002      	beq.n	8007426 <GUI__DoAlphaBlending+0x1aa>
 8007420:	f8dd 8014 	ldr.w	r8, [sp, #20]
 8007424:	e761      	b.n	80072ea <GUI__DoAlphaBlending+0x6e>
 8007426:	9810      	ldr	r0, [sp, #64]	; 0x40
 8007428:	e000      	b.n	800742c <GUI__DoAlphaBlending+0x1b0>
 800742a:	4620      	mov	r0, r4
 800742c:	b013      	add	sp, #76	; 0x4c
 800742e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007432:	bf00      	nop
 8007434:	20000060 	.word	0x20000060
 8007438:	20022308 	.word	0x20022308
 800743c:	080086bd 	.word	0x080086bd
 8007440:	080086bb 	.word	0x080086bb
 8007444:	20001fdc 	.word	0x20001fdc

08007448 <GUI__AllocAlphaBuffer>:
 8007448:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 800744a:	b108      	cbz	r0, 8007450 <GUI__AllocAlphaBuffer+0x8>
 800744c:	aa03      	add	r2, sp, #12
 800744e:	e000      	b.n	8007452 <GUI__AllocAlphaBuffer+0xa>
 8007450:	4602      	mov	r2, r0
 8007452:	a801      	add	r0, sp, #4
 8007454:	a902      	add	r1, sp, #8
 8007456:	2300      	movs	r3, #0
 8007458:	f7ff feac 	bl	80071b4 <GUI__GetAlphaBuffer>
 800745c:	b005      	add	sp, #20
 800745e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08007464 <GUI_SignalEvent>:
 8007464:	b508      	push	{r3, lr}
 8007466:	4b02      	ldr	r3, [pc, #8]	; (8007470 <GUI_SignalEvent+0xc>)
 8007468:	681b      	ldr	r3, [r3, #0]
 800746a:	b103      	cbz	r3, 800746e <GUI_SignalEvent+0xa>
 800746c:	4798      	blx	r3
 800746e:	bd08      	pop	{r3, pc}
 8007470:	20001fec 	.word	0x20001fec

08007474 <GUI_SetTextMode>:
 8007474:	4b03      	ldr	r3, [pc, #12]	; (8007484 <GUI_SetTextMode+0x10>)
 8007476:	681b      	ldr	r3, [r3, #0]
 8007478:	f9b3 202a 	ldrsh.w	r2, [r3, #42]	; 0x2a
 800747c:	8558      	strh	r0, [r3, #42]	; 0x2a
 800747e:	4610      	mov	r0, r2
 8007480:	4770      	bx	lr
 8007482:	bf00      	nop
 8007484:	20000060 	.word	0x20000060

08007488 <GUI_SetFont>:
 8007488:	4b03      	ldr	r3, [pc, #12]	; (8007498 <GUI_SetFont+0x10>)
 800748a:	681b      	ldr	r3, [r3, #0]
 800748c:	69d9      	ldr	r1, [r3, #28]
 800748e:	b100      	cbz	r0, 8007492 <GUI_SetFont+0xa>
 8007490:	61d8      	str	r0, [r3, #28]
 8007492:	4608      	mov	r0, r1
 8007494:	4770      	bx	lr
 8007496:	bf00      	nop
 8007498:	20000060 	.word	0x20000060

0800749c <GUI_SetBkColor>:
 800749c:	f7ff bd3c 	b.w	8006f18 <LCD_SetBkColor>

080074a0 <GUI_SetColor>:
 80074a0:	f7ff bd42 	b.w	8006f28 <LCD_SetColor>

080074a4 <GUI_GetLayerPosEx>:
 80074a4:	b538      	push	{r3, r4, r5, lr}
 80074a6:	460d      	mov	r5, r1
 80074a8:	4614      	mov	r4, r2
 80074aa:	f7ff fa35 	bl	8006918 <LCD_GetPosEx>
 80074ae:	b110      	cbz	r0, 80074b6 <GUI_GetLayerPosEx+0x12>
 80074b0:	2300      	movs	r3, #0
 80074b2:	602b      	str	r3, [r5, #0]
 80074b4:	6023      	str	r3, [r4, #0]
 80074b6:	bd38      	pop	{r3, r4, r5, pc}

080074b8 <GUI_SelectLayer>:
 80074b8:	b538      	push	{r3, r4, r5, lr}
 80074ba:	4b06      	ldr	r3, [pc, #24]	; (80074d4 <GUI_SelectLayer+0x1c>)
 80074bc:	681b      	ldr	r3, [r3, #0]
 80074be:	2801      	cmp	r0, #1
 80074c0:	4604      	mov	r4, r0
 80074c2:	7c5d      	ldrb	r5, [r3, #17]
 80074c4:	d802      	bhi.n	80074cc <GUI_SelectLayer+0x14>
 80074c6:	7458      	strb	r0, [r3, #17]
 80074c8:	f000 f808 	bl	80074dc <GUI_SelectLCD>
 80074cc:	4b02      	ldr	r3, [pc, #8]	; (80074d8 <GUI_SelectLayer+0x20>)
 80074ce:	4628      	mov	r0, r5
 80074d0:	601c      	str	r4, [r3, #0]
 80074d2:	bd38      	pop	{r3, r4, r5, pc}
 80074d4:	20000060 	.word	0x20000060
 80074d8:	200222b0 	.word	0x200222b0

080074dc <GUI_SelectLCD>:
 80074dc:	b508      	push	{r3, lr}
 80074de:	f001 fae3 	bl	8008aa8 <LCD_SelectLCD>
 80074e2:	f7ff f991 	bl	8006808 <LCD_UpdateColorIndices>
 80074e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80074ea:	f7fd be15 	b.w	8005118 <WM_Activate>

080074ee <GUI_RectsIntersect>:
 80074ee:	f9b0 2002 	ldrsh.w	r2, [r0, #2]
 80074f2:	f9b1 3006 	ldrsh.w	r3, [r1, #6]
 80074f6:	429a      	cmp	r2, r3
 80074f8:	dc14      	bgt.n	8007524 <GUI_RectsIntersect+0x36>
 80074fa:	f9b1 2002 	ldrsh.w	r2, [r1, #2]
 80074fe:	f9b0 3006 	ldrsh.w	r3, [r0, #6]
 8007502:	429a      	cmp	r2, r3
 8007504:	dc0e      	bgt.n	8007524 <GUI_RectsIntersect+0x36>
 8007506:	f9b0 2000 	ldrsh.w	r2, [r0]
 800750a:	f9b1 3004 	ldrsh.w	r3, [r1, #4]
 800750e:	429a      	cmp	r2, r3
 8007510:	dc08      	bgt.n	8007524 <GUI_RectsIntersect+0x36>
 8007512:	f9b0 3004 	ldrsh.w	r3, [r0, #4]
 8007516:	f9b1 2000 	ldrsh.w	r2, [r1]
 800751a:	429a      	cmp	r2, r3
 800751c:	bfcc      	ite	gt
 800751e:	2000      	movgt	r0, #0
 8007520:	2001      	movle	r0, #1
 8007522:	4770      	bx	lr
 8007524:	2000      	movs	r0, #0
 8007526:	4770      	bx	lr

08007528 <GUI_StoreKey>:
 8007528:	4b02      	ldr	r3, [pc, #8]	; (8007534 <GUI_StoreKey+0xc>)
 800752a:	681a      	ldr	r2, [r3, #0]
 800752c:	b902      	cbnz	r2, 8007530 <GUI_StoreKey+0x8>
 800752e:	6018      	str	r0, [r3, #0]
 8007530:	f7ff bf98 	b.w	8007464 <GUI_SignalEvent>
 8007534:	20001ff0 	.word	0x20001ff0

08007538 <GUI_MoveRect>:
 8007538:	b168      	cbz	r0, 8007556 <GUI_MoveRect+0x1e>
 800753a:	8803      	ldrh	r3, [r0, #0]
 800753c:	b289      	uxth	r1, r1
 800753e:	440b      	add	r3, r1
 8007540:	8003      	strh	r3, [r0, #0]
 8007542:	8883      	ldrh	r3, [r0, #4]
 8007544:	4419      	add	r1, r3
 8007546:	8843      	ldrh	r3, [r0, #2]
 8007548:	8081      	strh	r1, [r0, #4]
 800754a:	b292      	uxth	r2, r2
 800754c:	4413      	add	r3, r2
 800754e:	8043      	strh	r3, [r0, #2]
 8007550:	88c3      	ldrh	r3, [r0, #6]
 8007552:	441a      	add	r2, r3
 8007554:	80c2      	strh	r2, [r0, #6]
 8007556:	4770      	bx	lr

08007558 <GUI_MergeRect>:
 8007558:	b510      	push	{r4, lr}
 800755a:	b338      	cbz	r0, 80075ac <GUI_MergeRect+0x54>
 800755c:	b309      	cbz	r1, 80075a2 <GUI_MergeRect+0x4a>
 800755e:	b30a      	cbz	r2, 80075a4 <GUI_MergeRect+0x4c>
 8007560:	f9b1 4000 	ldrsh.w	r4, [r1]
 8007564:	f9b2 3000 	ldrsh.w	r3, [r2]
 8007568:	429c      	cmp	r4, r3
 800756a:	bfb8      	it	lt
 800756c:	4623      	movlt	r3, r4
 800756e:	8003      	strh	r3, [r0, #0]
 8007570:	f9b1 4002 	ldrsh.w	r4, [r1, #2]
 8007574:	f9b2 3002 	ldrsh.w	r3, [r2, #2]
 8007578:	429c      	cmp	r4, r3
 800757a:	bfb8      	it	lt
 800757c:	4623      	movlt	r3, r4
 800757e:	8043      	strh	r3, [r0, #2]
 8007580:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
 8007584:	f9b2 3004 	ldrsh.w	r3, [r2, #4]
 8007588:	f9b1 1006 	ldrsh.w	r1, [r1, #6]
 800758c:	429c      	cmp	r4, r3
 800758e:	bfa8      	it	ge
 8007590:	4623      	movge	r3, r4
 8007592:	8083      	strh	r3, [r0, #4]
 8007594:	f9b2 3006 	ldrsh.w	r3, [r2, #6]
 8007598:	4299      	cmp	r1, r3
 800759a:	bfa8      	it	ge
 800759c:	460b      	movge	r3, r1
 800759e:	80c3      	strh	r3, [r0, #6]
 80075a0:	bd10      	pop	{r4, pc}
 80075a2:	4611      	mov	r1, r2
 80075a4:	680b      	ldr	r3, [r1, #0]
 80075a6:	6003      	str	r3, [r0, #0]
 80075a8:	684b      	ldr	r3, [r1, #4]
 80075aa:	6043      	str	r3, [r0, #4]
 80075ac:	bd10      	pop	{r4, pc}
	...

080075b0 <GUI_MULTIBUF_ConfirmEx>:
 80075b0:	4b08      	ldr	r3, [pc, #32]	; (80075d4 <GUI_MULTIBUF_ConfirmEx+0x24>)
 80075b2:	681b      	ldr	r3, [r3, #0]
 80075b4:	2b00      	cmp	r3, #0
 80075b6:	bf18      	it	ne
 80075b8:	2000      	movne	r0, #0
 80075ba:	4b07      	ldr	r3, [pc, #28]	; (80075d8 <GUI_MULTIBUF_ConfirmEx+0x28>)
 80075bc:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 80075c0:	2a00      	cmp	r2, #0
 80075c2:	db06      	blt.n	80075d2 <GUI_MULTIBUF_ConfirmEx+0x22>
 80075c4:	4a05      	ldr	r2, [pc, #20]	; (80075dc <GUI_MULTIBUF_ConfirmEx+0x2c>)
 80075c6:	f842 1020 	str.w	r1, [r2, r0, lsl #2]
 80075ca:	f04f 32ff 	mov.w	r2, #4294967295
 80075ce:	f843 2020 	str.w	r2, [r3, r0, lsl #2]
 80075d2:	4770      	bx	lr
 80075d4:	20002004 	.word	0x20002004
 80075d8:	20001ffc 	.word	0x20001ffc
 80075dc:	20001ff4 	.word	0x20001ff4

080075e0 <GUI_MULTIBUF_ConfigEx>:
 80075e0:	4b05      	ldr	r3, [pc, #20]	; (80075f8 <GUI_MULTIBUF_ConfigEx+0x18>)
 80075e2:	681b      	ldr	r3, [r3, #0]
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	bf18      	it	ne
 80075e8:	2000      	movne	r0, #0
 80075ea:	4b04      	ldr	r3, [pc, #16]	; (80075fc <GUI_MULTIBUF_ConfigEx+0x1c>)
 80075ec:	2901      	cmp	r1, #1
 80075ee:	bfb8      	it	lt
 80075f0:	2101      	movlt	r1, #1
 80075f2:	5419      	strb	r1, [r3, r0]
 80075f4:	4770      	bx	lr
 80075f6:	bf00      	nop
 80075f8:	20002004 	.word	0x20002004
 80075fc:	200222dc 	.word	0x200222dc

08007600 <GUI_GotoXY>:
 8007600:	4b02      	ldr	r3, [pc, #8]	; (800760c <GUI_GotoXY+0xc>)
 8007602:	681b      	ldr	r3, [r3, #0]
 8007604:	8458      	strh	r0, [r3, #34]	; 0x22
 8007606:	8499      	strh	r1, [r3, #36]	; 0x24
 8007608:	2000      	movs	r0, #0
 800760a:	4770      	bx	lr
 800760c:	20000060 	.word	0x20000060

08007610 <GUI_GetDrawMode>:
 8007610:	4b01      	ldr	r3, [pc, #4]	; (8007618 <GUI_GetDrawMode+0x8>)
 8007612:	681b      	ldr	r3, [r3, #0]
 8007614:	7c18      	ldrb	r0, [r3, #16]
 8007616:	4770      	bx	lr
 8007618:	20000060 	.word	0x20000060

0800761c <GUI_FillRectEx>:
 800761c:	4603      	mov	r3, r0
 800761e:	f9b0 0000 	ldrsh.w	r0, [r0]
 8007622:	f9b3 1002 	ldrsh.w	r1, [r3, #2]
 8007626:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 800762a:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 800762e:	f000 b801 	b.w	8007634 <GUI_FillRect>
	...

08007634 <GUI_FillRect>:
 8007634:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 8007636:	4c0f      	ldr	r4, [pc, #60]	; (8007674 <GUI_FillRect+0x40>)
 8007638:	6824      	ldr	r4, [r4, #0]
 800763a:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 800763c:	6d24      	ldr	r4, [r4, #80]	; 0x50
 800763e:	1947      	adds	r7, r0, r5
 8007640:	190e      	adds	r6, r1, r4
 8007642:	4415      	add	r5, r2
 8007644:	441c      	add	r4, r3
 8007646:	4668      	mov	r0, sp
 8007648:	f8ad 7000 	strh.w	r7, [sp]
 800764c:	f8ad 5004 	strh.w	r5, [sp, #4]
 8007650:	f8ad 6002 	strh.w	r6, [sp, #2]
 8007654:	f8ad 4006 	strh.w	r4, [sp, #6]
 8007658:	f7fd fce0 	bl	800501c <WM__InitIVRSearch>
 800765c:	b140      	cbz	r0, 8007670 <GUI_FillRect+0x3c>
 800765e:	4638      	mov	r0, r7
 8007660:	4631      	mov	r1, r6
 8007662:	462a      	mov	r2, r5
 8007664:	4623      	mov	r3, r4
 8007666:	f7ff fa6f 	bl	8006b48 <LCD_FillRect>
 800766a:	f7fd fc15 	bl	8004e98 <WM__GetNextIVR>
 800766e:	e7f5      	b.n	800765c <GUI_FillRect+0x28>
 8007670:	b003      	add	sp, #12
 8007672:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007674:	20000060 	.word	0x20000060

08007678 <GUI_DispStringHCenterAt>:
 8007678:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800767a:	4b0b      	ldr	r3, [pc, #44]	; (80076a8 <GUI_DispStringHCenterAt+0x30>)
 800767c:	681b      	ldr	r3, [r3, #0]
 800767e:	4605      	mov	r5, r0
 8007680:	f9b3 002c 	ldrsh.w	r0, [r3, #44]	; 0x2c
 8007684:	f040 0002 	orr.w	r0, r0, #2
 8007688:	460f      	mov	r7, r1
 800768a:	4616      	mov	r6, r2
 800768c:	f001 fd7a 	bl	8009184 <GUI_SetTextAlign>
 8007690:	4639      	mov	r1, r7
 8007692:	4604      	mov	r4, r0
 8007694:	4632      	mov	r2, r6
 8007696:	4628      	mov	r0, r5
 8007698:	f000 f808 	bl	80076ac <GUI_DispStringAt>
 800769c:	4620      	mov	r0, r4
 800769e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 80076a2:	f001 bd6f 	b.w	8009184 <GUI_SetTextAlign>
 80076a6:	bf00      	nop
 80076a8:	20000060 	.word	0x20000060

080076ac <GUI_DispStringAt>:
 80076ac:	4b02      	ldr	r3, [pc, #8]	; (80076b8 <GUI_DispStringAt+0xc>)
 80076ae:	681b      	ldr	r3, [r3, #0]
 80076b0:	8459      	strh	r1, [r3, #34]	; 0x22
 80076b2:	849a      	strh	r2, [r3, #36]	; 0x24
 80076b4:	f000 b802 	b.w	80076bc <GUI_DispString>
 80076b8:	20000060 	.word	0x20000060

080076bc <GUI_DispString>:
 80076bc:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80076c0:	4604      	mov	r4, r0
 80076c2:	2800      	cmp	r0, #0
 80076c4:	d079      	beq.n	80077ba <GUI_DispString+0xfe>
 80076c6:	4d3e      	ldr	r5, [pc, #248]	; (80077c0 <GUI_DispString+0x104>)
 80076c8:	f000 fcb0 	bl	800802c <GUI_GetFontDistY>
 80076cc:	682b      	ldr	r3, [r5, #0]
 80076ce:	4680      	mov	r8, r0
 80076d0:	f8b3 9022 	ldrh.w	r9, [r3, #34]	; 0x22
 80076d4:	f000 fc92 	bl	8007ffc <GUI_GetYAdjust>
 80076d8:	682b      	ldr	r3, [r5, #0]
 80076da:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80076dc:	b287      	uxth	r7, r0
 80076de:	1bd2      	subs	r2, r2, r7
 80076e0:	849a      	strh	r2, [r3, #36]	; 0x24
 80076e2:	7823      	ldrb	r3, [r4, #0]
 80076e4:	2b00      	cmp	r3, #0
 80076e6:	d05d      	beq.n	80077a4 <GUI_DispString+0xe8>
 80076e8:	f647 71ff 	movw	r1, #32767	; 0x7fff
 80076ec:	4620      	mov	r0, r4
 80076ee:	f000 fbd3 	bl	8007e98 <GUI__GetLineNumChars>
 80076f2:	4606      	mov	r6, r0
 80076f4:	4631      	mov	r1, r6
 80076f6:	4620      	mov	r0, r4
 80076f8:	f000 fbfc 	bl	8007ef4 <GUI__GetLineDistX>
 80076fc:	682b      	ldr	r3, [r5, #0]
 80076fe:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 8007700:	f002 0203 	and.w	r2, r2, #3
 8007704:	2a01      	cmp	r2, #1
 8007706:	d005      	beq.n	8007714 <GUI_DispString+0x58>
 8007708:	2a02      	cmp	r2, #2
 800770a:	bf14      	ite	ne
 800770c:	2200      	movne	r2, #0
 800770e:	fb90 f2f2 	sdiveq	r2, r0, r2
 8007712:	e000      	b.n	8007716 <GUI_DispString+0x5a>
 8007714:	4602      	mov	r2, r0
 8007716:	8c59      	ldrh	r1, [r3, #34]	; 0x22
 8007718:	1a8a      	subs	r2, r1, r2
 800771a:	b292      	uxth	r2, r2
 800771c:	b291      	uxth	r1, r2
 800771e:	8459      	strh	r1, [r3, #34]	; 0x22
 8007720:	fa1f fa80 	uxth.w	sl, r0
 8007724:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8007726:	f8ad 1000 	strh.w	r1, [sp]
 800772a:	f10a 31ff 	add.w	r1, sl, #4294967295
 800772e:	440a      	add	r2, r1
 8007730:	f8ad 3002 	strh.w	r3, [sp, #2]
 8007734:	fa1f fb88 	uxth.w	fp, r8
 8007738:	3b01      	subs	r3, #1
 800773a:	445b      	add	r3, fp
 800773c:	f8ad 2004 	strh.w	r2, [sp, #4]
 8007740:	4620      	mov	r0, r4
 8007742:	4631      	mov	r1, r6
 8007744:	466a      	mov	r2, sp
 8007746:	f8ad 3006 	strh.w	r3, [sp, #6]
 800774a:	f000 fc03 	bl	8007f54 <GUI__DispLine>
 800774e:	682b      	ldr	r3, [r5, #0]
 8007750:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8007754:	849a      	strh	r2, [r3, #36]	; 0x24
 8007756:	4620      	mov	r0, r4
 8007758:	4631      	mov	r1, r6
 800775a:	f001 fd01 	bl	8009160 <GUI_UC__NumChars2NumBytes>
 800775e:	5c23      	ldrb	r3, [r4, r0]
 8007760:	2b0a      	cmp	r3, #10
 8007762:	eb04 0200 	add.w	r2, r4, r0
 8007766:	d001      	beq.n	800776c <GUI_DispString+0xb0>
 8007768:	2b0d      	cmp	r3, #13
 800776a:	d112      	bne.n	8007792 <GUI_DispString+0xd6>
 800776c:	682b      	ldr	r3, [r5, #0]
 800776e:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
 8007770:	f001 0103 	and.w	r1, r1, #3
 8007774:	3901      	subs	r1, #1
 8007776:	2901      	cmp	r1, #1
 8007778:	bf8a      	itet	hi
 800777a:	8c19      	ldrhhi	r1, [r3, #32]
 800777c:	f8a3 9022 	strhls.w	r9, [r3, #34]	; 0x22
 8007780:	8459      	strhhi	r1, [r3, #34]	; 0x22
 8007782:	7811      	ldrb	r1, [r2, #0]
 8007784:	290a      	cmp	r1, #10
 8007786:	d10b      	bne.n	80077a0 <GUI_DispString+0xe4>
 8007788:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 800778a:	448b      	add	fp, r1
 800778c:	f8a3 b024 	strh.w	fp, [r3, #36]	; 0x24
 8007790:	e006      	b.n	80077a0 <GUI_DispString+0xe4>
 8007792:	4b0b      	ldr	r3, [pc, #44]	; (80077c0 <GUI_DispString+0x104>)
 8007794:	f8bd 0000 	ldrh.w	r0, [sp]
 8007798:	681b      	ldr	r3, [r3, #0]
 800779a:	4482      	add	sl, r0
 800779c:	f8a3 a022 	strh.w	sl, [r3, #34]	; 0x22
 80077a0:	7813      	ldrb	r3, [r2, #0]
 80077a2:	b943      	cbnz	r3, 80077b6 <GUI_DispString+0xfa>
 80077a4:	682b      	ldr	r3, [r5, #0]
 80077a6:	8c9a      	ldrh	r2, [r3, #36]	; 0x24
 80077a8:	4417      	add	r7, r2
 80077aa:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 80077ac:	849f      	strh	r7, [r3, #36]	; 0x24
 80077ae:	f022 0203 	bic.w	r2, r2, #3
 80077b2:	859a      	strh	r2, [r3, #44]	; 0x2c
 80077b4:	e001      	b.n	80077ba <GUI_DispString+0xfe>
 80077b6:	1c54      	adds	r4, r2, #1
 80077b8:	e793      	b.n	80076e2 <GUI_DispString+0x26>
 80077ba:	b003      	add	sp, #12
 80077bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80077c0:	20000060 	.word	0x20000060

080077c4 <_UnlinkDevice>:
 80077c4:	4b09      	ldr	r3, [pc, #36]	; (80077ec <_UnlinkDevice+0x28>)
 80077c6:	6982      	ldr	r2, [r0, #24]
 80077c8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 80077cc:	4281      	cmp	r1, r0
 80077ce:	bf04      	itt	eq
 80077d0:	6801      	ldreq	r1, [r0, #0]
 80077d2:	f843 1022 	streq.w	r1, [r3, r2, lsl #2]
 80077d6:	6843      	ldr	r3, [r0, #4]
 80077d8:	b10b      	cbz	r3, 80077de <_UnlinkDevice+0x1a>
 80077da:	6802      	ldr	r2, [r0, #0]
 80077dc:	601a      	str	r2, [r3, #0]
 80077de:	6802      	ldr	r2, [r0, #0]
 80077e0:	b102      	cbz	r2, 80077e4 <_UnlinkDevice+0x20>
 80077e2:	6053      	str	r3, [r2, #4]
 80077e4:	2300      	movs	r3, #0
 80077e6:	6003      	str	r3, [r0, #0]
 80077e8:	6043      	str	r3, [r0, #4]
 80077ea:	4770      	bx	lr
 80077ec:	20022308 	.word	0x20022308

080077f0 <GUI_DEVICE__GetpDriver>:
 80077f0:	2801      	cmp	r0, #1
 80077f2:	dc09      	bgt.n	8007808 <GUI_DEVICE__GetpDriver+0x18>
 80077f4:	4b05      	ldr	r3, [pc, #20]	; (800780c <GUI_DEVICE__GetpDriver+0x1c>)
 80077f6:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
 80077fa:	b120      	cbz	r0, 8007806 <GUI_DEVICE__GetpDriver+0x16>
 80077fc:	68c3      	ldr	r3, [r0, #12]
 80077fe:	681b      	ldr	r3, [r3, #0]
 8007800:	b11b      	cbz	r3, 800780a <GUI_DEVICE__GetpDriver+0x1a>
 8007802:	6800      	ldr	r0, [r0, #0]
 8007804:	e7f9      	b.n	80077fa <GUI_DEVICE__GetpDriver+0xa>
 8007806:	4770      	bx	lr
 8007808:	2000      	movs	r0, #0
 800780a:	4770      	bx	lr
 800780c:	20022308 	.word	0x20022308

08007810 <GUI_DEVICE_Delete>:
 8007810:	f000 bd0e 	b.w	8008230 <GUI_ALLOC_FreeFixedBlock>

08007814 <GUI_DEVICE_Create>:
 8007814:	2b01      	cmp	r3, #1
 8007816:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007818:	4606      	mov	r6, r0
 800781a:	460d      	mov	r5, r1
 800781c:	4617      	mov	r7, r2
 800781e:	461c      	mov	r4, r3
 8007820:	dd01      	ble.n	8007826 <GUI_DEVICE_Create+0x12>
 8007822:	2000      	movs	r0, #0
 8007824:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007826:	201c      	movs	r0, #28
 8007828:	f000 fe62 	bl	80084f0 <GUI_ALLOC_GetFixedBlock>
 800782c:	2800      	cmp	r0, #0
 800782e:	d0f8      	beq.n	8007822 <GUI_DEVICE_Create+0xe>
 8007830:	b10d      	cbz	r5, 8007836 <GUI_DEVICE_Create+0x22>
 8007832:	6105      	str	r5, [r0, #16]
 8007834:	e009      	b.n	800784a <GUI_DEVICE_Create+0x36>
 8007836:	4b09      	ldr	r3, [pc, #36]	; (800785c <GUI_DEVICE_Create+0x48>)
 8007838:	f853 1024 	ldr.w	r1, [r3, r4, lsl #2]
 800783c:	b129      	cbz	r1, 800784a <GUI_DEVICE_Create+0x36>
 800783e:	680b      	ldr	r3, [r1, #0]
 8007840:	b10b      	cbz	r3, 8007846 <GUI_DEVICE_Create+0x32>
 8007842:	4619      	mov	r1, r3
 8007844:	e7fb      	b.n	800783e <GUI_DEVICE_Create+0x2a>
 8007846:	690b      	ldr	r3, [r1, #16]
 8007848:	6103      	str	r3, [r0, #16]
 800784a:	2300      	movs	r3, #0
 800784c:	6083      	str	r3, [r0, #8]
 800784e:	6184      	str	r4, [r0, #24]
 8007850:	8287      	strh	r7, [r0, #20]
 8007852:	60c6      	str	r6, [r0, #12]
 8007854:	6003      	str	r3, [r0, #0]
 8007856:	6043      	str	r3, [r0, #4]
 8007858:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800785a:	bf00      	nop
 800785c:	20022308 	.word	0x20022308

08007860 <GUI_DEVICE_Unlink>:
 8007860:	f7ff bfb0 	b.w	80077c4 <_UnlinkDevice>

08007864 <GUI_DEVICE_Link>:
 8007864:	b570      	push	{r4, r5, r6, lr}
 8007866:	b338      	cbz	r0, 80078b8 <GUI_DEVICE_Link+0x54>
 8007868:	6982      	ldr	r2, [r0, #24]
 800786a:	2a01      	cmp	r2, #1
 800786c:	dc24      	bgt.n	80078b8 <GUI_DEVICE_Link+0x54>
 800786e:	4919      	ldr	r1, [pc, #100]	; (80078d4 <GUI_DEVICE_Link+0x70>)
 8007870:	f851 3022 	ldr.w	r3, [r1, r2, lsl #2]
 8007874:	460d      	mov	r5, r1
 8007876:	b913      	cbnz	r3, 800787e <GUI_DEVICE_Link+0x1a>
 8007878:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
 800787c:	e01a      	b.n	80078b4 <GUI_DEVICE_Link+0x50>
 800787e:	6859      	ldr	r1, [r3, #4]
 8007880:	b109      	cbz	r1, 8007886 <GUI_DEVICE_Link+0x22>
 8007882:	460b      	mov	r3, r1
 8007884:	e7fb      	b.n	800787e <GUI_DEVICE_Link+0x1a>
 8007886:	68c1      	ldr	r1, [r0, #12]
 8007888:	680e      	ldr	r6, [r1, #0]
 800788a:	68d9      	ldr	r1, [r3, #12]
 800788c:	680c      	ldr	r4, [r1, #0]
 800788e:	42b4      	cmp	r4, r6
 8007890:	dd03      	ble.n	800789a <GUI_DEVICE_Link+0x36>
 8007892:	681b      	ldr	r3, [r3, #0]
 8007894:	2b00      	cmp	r3, #0
 8007896:	d1f8      	bne.n	800788a <GUI_DEVICE_Link+0x26>
 8007898:	e00e      	b.n	80078b8 <GUI_DEVICE_Link+0x54>
 800789a:	d102      	bne.n	80078a2 <GUI_DEVICE_Link+0x3e>
 800789c:	8a81      	ldrh	r1, [r0, #20]
 800789e:	2901      	cmp	r1, #1
 80078a0:	d011      	beq.n	80078c6 <GUI_DEVICE_Link+0x62>
 80078a2:	6859      	ldr	r1, [r3, #4]
 80078a4:	b199      	cbz	r1, 80078ce <GUI_DEVICE_Link+0x6a>
 80078a6:	6008      	str	r0, [r1, #0]
 80078a8:	6041      	str	r1, [r0, #4]
 80078aa:	6058      	str	r0, [r3, #4]
 80078ac:	4298      	cmp	r0, r3
 80078ae:	bf08      	it	eq
 80078b0:	2300      	moveq	r3, #0
 80078b2:	6003      	str	r3, [r0, #0]
 80078b4:	2000      	movs	r0, #0
 80078b6:	bd70      	pop	{r4, r5, r6, pc}
 80078b8:	2001      	movs	r0, #1
 80078ba:	bd70      	pop	{r4, r5, r6, pc}
 80078bc:	68cb      	ldr	r3, [r1, #12]
 80078be:	681b      	ldr	r3, [r3, #0]
 80078c0:	42a3      	cmp	r3, r4
 80078c2:	460b      	mov	r3, r1
 80078c4:	dbed      	blt.n	80078a2 <GUI_DEVICE_Link+0x3e>
 80078c6:	6819      	ldr	r1, [r3, #0]
 80078c8:	2900      	cmp	r1, #0
 80078ca:	d1f7      	bne.n	80078bc <GUI_DEVICE_Link+0x58>
 80078cc:	e7e9      	b.n	80078a2 <GUI_DEVICE_Link+0x3e>
 80078ce:	f845 0022 	str.w	r0, [r5, r2, lsl #2]
 80078d2:	e7ea      	b.n	80078aa <GUI_DEVICE_Link+0x46>
 80078d4:	20022308 	.word	0x20022308

080078d8 <GUI_DEVICE_CreateAndLink>:
 80078d8:	b538      	push	{r3, r4, r5, lr}
 80078da:	461d      	mov	r5, r3
 80078dc:	f7ff ff9a 	bl	8007814 <GUI_DEVICE_Create>
 80078e0:	4604      	mov	r4, r0
 80078e2:	b148      	cbz	r0, 80078f8 <GUI_DEVICE_CreateAndLink+0x20>
 80078e4:	f7ff ffbe 	bl	8007864 <GUI_DEVICE_Link>
 80078e8:	68e3      	ldr	r3, [r4, #12]
 80078ea:	681b      	ldr	r3, [r3, #0]
 80078ec:	b923      	cbnz	r3, 80078f8 <GUI_DEVICE_CreateAndLink+0x20>
 80078ee:	4b03      	ldr	r3, [pc, #12]	; (80078fc <GUI_DEVICE_CreateAndLink+0x24>)
 80078f0:	3516      	adds	r5, #22
 80078f2:	681b      	ldr	r3, [r3, #0]
 80078f4:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
 80078f8:	4620      	mov	r0, r4
 80078fa:	bd38      	pop	{r3, r4, r5, pc}
 80078fc:	20000060 	.word	0x20000060

08007900 <_OnExit>:
 8007900:	b510      	push	{r4, lr}
 8007902:	4b07      	ldr	r3, [pc, #28]	; (8007920 <_OnExit+0x20>)
 8007904:	4807      	ldr	r0, [pc, #28]	; (8007924 <_OnExit+0x24>)
 8007906:	2400      	movs	r4, #0
 8007908:	4621      	mov	r1, r4
 800790a:	2270      	movs	r2, #112	; 0x70
 800790c:	601c      	str	r4, [r3, #0]
 800790e:	f7ff fb13 	bl	8006f38 <GUI__memset>
 8007912:	4621      	mov	r1, r4
 8007914:	4804      	ldr	r0, [pc, #16]	; (8007928 <_OnExit+0x28>)
 8007916:	2208      	movs	r2, #8
 8007918:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800791c:	f7ff bb0c 	b.w	8006f38 <GUI__memset>
 8007920:	20002084 	.word	0x20002084
 8007924:	2000200c 	.word	0x2000200c
 8007928:	20022308 	.word	0x20022308

0800792c <_InitContext>:
 800792c:	b538      	push	{r3, r4, r5, lr}
 800792e:	4d19      	ldr	r5, [pc, #100]	; (8007994 <_InitContext+0x68>)
 8007930:	682b      	ldr	r3, [r5, #0]
 8007932:	1d1a      	adds	r2, r3, #4
 8007934:	63da      	str	r2, [r3, #60]	; 0x3c
 8007936:	f103 0208 	add.w	r2, r3, #8
 800793a:	639b      	str	r3, [r3, #56]	; 0x38
 800793c:	641b      	str	r3, [r3, #64]	; 0x40
 800793e:	6142      	str	r2, [r0, #20]
 8007940:	7c5a      	ldrb	r2, [r3, #17]
 8007942:	4b15      	ldr	r3, [pc, #84]	; (8007998 <_InitContext+0x6c>)
 8007944:	4604      	mov	r4, r0
 8007946:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 800794a:	68c3      	ldr	r3, [r0, #12]
 800794c:	f104 0108 	add.w	r1, r4, #8
 8007950:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8007952:	4798      	blx	r3
 8007954:	4b11      	ldr	r3, [pc, #68]	; (800799c <_InitContext+0x70>)
 8007956:	6663      	str	r3, [r4, #100]	; 0x64
 8007958:	4b11      	ldr	r3, [pc, #68]	; (80079a0 <_InitContext+0x74>)
 800795a:	681b      	ldr	r3, [r3, #0]
 800795c:	61e3      	str	r3, [r4, #28]
 800795e:	682b      	ldr	r3, [r5, #0]
 8007960:	3308      	adds	r3, #8
 8007962:	6163      	str	r3, [r4, #20]
 8007964:	2301      	movs	r3, #1
 8007966:	7623      	strb	r3, [r4, #24]
 8007968:	f000 ff42 	bl	80087f0 <WM_GetDesktopWindow>
 800796c:	2303      	movs	r3, #3
 800796e:	f884 3068 	strb.w	r3, [r4, #104]	; 0x68
 8007972:	f06f 4370 	mvn.w	r3, #4026531840	; 0xf0000000
 8007976:	6323      	str	r3, [r4, #48]	; 0x30
 8007978:	6363      	str	r3, [r4, #52]	; 0x34
 800797a:	64a0      	str	r0, [r4, #72]	; 0x48
 800797c:	2000      	movs	r0, #0
 800797e:	f7ff facb 	bl	8006f18 <LCD_SetBkColor>
 8007982:	f06f 407f 	mvn.w	r0, #4278190080	; 0xff000000
 8007986:	f7ff facf 	bl	8006f28 <LCD_SetColor>
 800798a:	4b06      	ldr	r3, [pc, #24]	; (80079a4 <_InitContext+0x78>)
 800798c:	4a06      	ldr	r2, [pc, #24]	; (80079a8 <_InitContext+0x7c>)
 800798e:	601a      	str	r2, [r3, #0]
 8007990:	bd38      	pop	{r3, r4, r5, pc}
 8007992:	bf00      	nop
 8007994:	20000060 	.word	0x20000060
 8007998:	20022308 	.word	0x20022308
 800799c:	0800b478 	.word	0x0800b478
 80079a0:	20000064 	.word	0x20000064
 80079a4:	20022300 	.word	0x20022300
 80079a8:	0800b498 	.word	0x0800b498

080079ac <GUI_SetDefaultFont>:
 80079ac:	4b01      	ldr	r3, [pc, #4]	; (80079b4 <GUI_SetDefaultFont+0x8>)
 80079ae:	6018      	str	r0, [r3, #0]
 80079b0:	4770      	bx	lr
 80079b2:	bf00      	nop
 80079b4:	20000064 	.word	0x20000064

080079b8 <GUI_ClearRect>:
 80079b8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80079bc:	4607      	mov	r7, r0
 80079be:	2004      	movs	r0, #4
 80079c0:	469a      	mov	sl, r3
 80079c2:	460e      	mov	r6, r1
 80079c4:	4691      	mov	r9, r2
 80079c6:	f7ff f863 	bl	8006a90 <LCD_SetDrawMode>
 80079ca:	4b13      	ldr	r3, [pc, #76]	; (8007a18 <GUI_ClearRect+0x60>)
 80079cc:	681c      	ldr	r4, [r3, #0]
 80079ce:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 80079d0:	6d24      	ldr	r4, [r4, #80]	; 0x50
 80079d2:	442f      	add	r7, r5
 80079d4:	4426      	add	r6, r4
 80079d6:	4680      	mov	r8, r0
 80079d8:	444d      	add	r5, r9
 80079da:	4454      	add	r4, sl
 80079dc:	4668      	mov	r0, sp
 80079de:	f8ad 7000 	strh.w	r7, [sp]
 80079e2:	f8ad 5004 	strh.w	r5, [sp, #4]
 80079e6:	f8ad 6002 	strh.w	r6, [sp, #2]
 80079ea:	f8ad 4006 	strh.w	r4, [sp, #6]
 80079ee:	f7fd fb15 	bl	800501c <WM__InitIVRSearch>
 80079f2:	b928      	cbnz	r0, 8007a00 <GUI_ClearRect+0x48>
 80079f4:	4640      	mov	r0, r8
 80079f6:	f7ff f84b 	bl	8006a90 <LCD_SetDrawMode>
 80079fa:	b002      	add	sp, #8
 80079fc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8007a00:	4638      	mov	r0, r7
 8007a02:	4631      	mov	r1, r6
 8007a04:	462a      	mov	r2, r5
 8007a06:	4623      	mov	r3, r4
 8007a08:	f7ff f89e 	bl	8006b48 <LCD_FillRect>
 8007a0c:	f7fd fa44 	bl	8004e98 <WM__GetNextIVR>
 8007a10:	2800      	cmp	r0, #0
 8007a12:	d1f5      	bne.n	8007a00 <GUI_ClearRect+0x48>
 8007a14:	e7ee      	b.n	80079f4 <GUI_ClearRect+0x3c>
 8007a16:	bf00      	nop
 8007a18:	20000060 	.word	0x20000060

08007a1c <GUI_Clear>:
 8007a1c:	b510      	push	{r4, lr}
 8007a1e:	2000      	movs	r0, #0
 8007a20:	4601      	mov	r1, r0
 8007a22:	f7ff fded 	bl	8007600 <GUI_GotoXY>
 8007a26:	4804      	ldr	r0, [pc, #16]	; (8007a38 <GUI_Clear+0x1c>)
 8007a28:	f643 72ff 	movw	r2, #16383	; 0x3fff
 8007a2c:	4601      	mov	r1, r0
 8007a2e:	4613      	mov	r3, r2
 8007a30:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8007a34:	f7ff bfc0 	b.w	80079b8 <GUI_ClearRect>
 8007a38:	ffffc001 	.word	0xffffc001

08007a3c <GUI__RegisterExit>:
 8007a3c:	b480      	push	{r7}
 8007a3e:	b083      	sub	sp, #12
 8007a40:	af00      	add	r7, sp, #0
 8007a42:	6078      	str	r0, [r7, #4]
 8007a44:	4b05      	ldr	r3, [pc, #20]	; (8007a5c <GUI__RegisterExit+0x20>)
 8007a46:	681a      	ldr	r2, [r3, #0]
 8007a48:	687b      	ldr	r3, [r7, #4]
 8007a4a:	605a      	str	r2, [r3, #4]
 8007a4c:	4b03      	ldr	r3, [pc, #12]	; (8007a5c <GUI__RegisterExit+0x20>)
 8007a4e:	687a      	ldr	r2, [r7, #4]
 8007a50:	601a      	str	r2, [r3, #0]
 8007a52:	370c      	adds	r7, #12
 8007a54:	46bd      	mov	sp, r7
 8007a56:	f85d 7b04 	ldr.w	r7, [sp], #4
 8007a5a:	4770      	bx	lr
 8007a5c:	20002008 	.word	0x20002008

08007a60 <GUI__Config>:
 8007a60:	b508      	push	{r3, lr}
 8007a62:	4b08      	ldr	r3, [pc, #32]	; (8007a84 <GUI__Config+0x24>)
 8007a64:	681a      	ldr	r2, [r3, #0]
 8007a66:	b962      	cbnz	r2, 8007a82 <GUI__Config+0x22>
 8007a68:	2201      	movs	r2, #1
 8007a6a:	601a      	str	r2, [r3, #0]
 8007a6c:	f7fc fac4 	bl	8003ff8 <GUI_X_Config>
 8007a70:	f7fc fc9e 	bl	80043b0 <LCD_X_Config>
 8007a74:	4804      	ldr	r0, [pc, #16]	; (8007a88 <GUI__Config+0x28>)
 8007a76:	4b05      	ldr	r3, [pc, #20]	; (8007a8c <GUI__Config+0x2c>)
 8007a78:	6003      	str	r3, [r0, #0]
 8007a7a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8007a7e:	f7ff bfdd 	b.w	8007a3c <GUI__RegisterExit>
 8007a82:	bd08      	pop	{r3, pc}
 8007a84:	20002084 	.word	0x20002084
 8007a88:	2000207c 	.word	0x2000207c
 8007a8c:	08007901 	.word	0x08007901

08007a90 <GUI_Init>:
 8007a90:	b580      	push	{r7, lr}
 8007a92:	b082      	sub	sp, #8
 8007a94:	af00      	add	r7, sp, #0
 8007a96:	4b15      	ldr	r3, [pc, #84]	; (8007aec <GUI_Init+0x5c>)
 8007a98:	4a14      	ldr	r2, [pc, #80]	; (8007aec <GUI_Init+0x5c>)
 8007a9a:	6812      	ldr	r2, [r2, #0]
 8007a9c:	f022 0201 	bic.w	r2, r2, #1
 8007aa0:	601a      	str	r2, [r3, #0]
 8007aa2:	4b13      	ldr	r3, [pc, #76]	; (8007af0 <GUI_Init+0x60>)
 8007aa4:	2201      	movs	r2, #1
 8007aa6:	601a      	str	r2, [r3, #0]
 8007aa8:	4b12      	ldr	r3, [pc, #72]	; (8007af4 <GUI_Init+0x64>)
 8007aaa:	4a13      	ldr	r2, [pc, #76]	; (8007af8 <GUI_Init+0x68>)
 8007aac:	601a      	str	r2, [r3, #0]
 8007aae:	4b11      	ldr	r3, [pc, #68]	; (8007af4 <GUI_Init+0x64>)
 8007ab0:	681a      	ldr	r2, [r3, #0]
 8007ab2:	4b12      	ldr	r3, [pc, #72]	; (8007afc <GUI_Init+0x6c>)
 8007ab4:	429a      	cmp	r2, r3
 8007ab6:	d000      	beq.n	8007aba <GUI_Init+0x2a>
 8007ab8:	e7fe      	b.n	8007ab8 <GUI_Init+0x28>
 8007aba:	f7ff ffd1 	bl	8007a60 <GUI__Config>
 8007abe:	4b10      	ldr	r3, [pc, #64]	; (8007b00 <GUI_Init+0x70>)
 8007ac0:	222e      	movs	r2, #46	; 0x2e
 8007ac2:	701a      	strb	r2, [r3, #0]
 8007ac4:	f7fc fddc 	bl	8004680 <GUI_X_Init>
 8007ac8:	480e      	ldr	r0, [pc, #56]	; (8007b04 <GUI_Init+0x74>)
 8007aca:	f7ff ff2f 	bl	800792c <_InitContext>
 8007ace:	f7ff f981 	bl	8006dd4 <emWin_LCD_Init>
 8007ad2:	6078      	str	r0, [r7, #4]
 8007ad4:	2000      	movs	r0, #0
 8007ad6:	2100      	movs	r1, #0
 8007ad8:	f001 fb5e 	bl	8009198 <GUI_SetOrg>
 8007adc:	f7fd fb7c 	bl	80051d8 <WM_Init>
 8007ae0:	687b      	ldr	r3, [r7, #4]
 8007ae2:	4618      	mov	r0, r3
 8007ae4:	3708      	adds	r7, #8
 8007ae6:	46bd      	mov	sp, r7
 8007ae8:	bd80      	pop	{r7, pc}
 8007aea:	bf00      	nop
 8007aec:	e0002000 	.word	0xe0002000
 8007af0:	40023008 	.word	0x40023008
 8007af4:	40023000 	.word	0x40023000
 8007af8:	f407a5c2 	.word	0xf407a5c2
 8007afc:	b5e8b5cd 	.word	0xb5e8b5cd
 8007b00:	200222de 	.word	0x200222de
 8007b04:	2000200c 	.word	0x2000200c

08007b08 <GUI_ClearRectEx>:
 8007b08:	4603      	mov	r3, r0
 8007b0a:	f9b0 0000 	ldrsh.w	r0, [r0]
 8007b0e:	f9b3 1002 	ldrsh.w	r1, [r3, #2]
 8007b12:	f9b3 2004 	ldrsh.w	r2, [r3, #4]
 8007b16:	f9b3 3006 	ldrsh.w	r3, [r3, #6]
 8007b1a:	f7ff bf4d 	b.w	80079b8 <GUI_ClearRect>

08007b1e <GUIPROP__FindChar>:
 8007b1e:	b138      	cbz	r0, 8007b30 <GUIPROP__FindChar+0x12>
 8007b20:	8803      	ldrh	r3, [r0, #0]
 8007b22:	428b      	cmp	r3, r1
 8007b24:	d802      	bhi.n	8007b2c <GUIPROP__FindChar+0xe>
 8007b26:	8843      	ldrh	r3, [r0, #2]
 8007b28:	428b      	cmp	r3, r1
 8007b2a:	d201      	bcs.n	8007b30 <GUIPROP__FindChar+0x12>
 8007b2c:	6880      	ldr	r0, [r0, #8]
 8007b2e:	e7f6      	b.n	8007b1e <GUIPROP__FindChar>
 8007b30:	4770      	bx	lr
	...

08007b34 <GUIPROP_DispChar>:
 8007b34:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007b38:	4c38      	ldr	r4, [pc, #224]	; (8007c1c <GUIPROP_DispChar+0xe8>)
 8007b3a:	6823      	ldr	r3, [r4, #0]
 8007b3c:	f9b3 902a 	ldrsh.w	r9, [r3, #42]	; 0x2a
 8007b40:	69db      	ldr	r3, [r3, #28]
 8007b42:	4605      	mov	r5, r0
 8007b44:	b089      	sub	sp, #36	; 0x24
 8007b46:	69d8      	ldr	r0, [r3, #28]
 8007b48:	4629      	mov	r1, r5
 8007b4a:	f7ff ffe8 	bl	8007b1e <GUIPROP__FindChar>
 8007b4e:	2800      	cmp	r0, #0
 8007b50:	d061      	beq.n	8007c16 <GUIPROP_DispChar+0xe2>
 8007b52:	f8b0 8000 	ldrh.w	r8, [r0]
 8007b56:	6847      	ldr	r7, [r0, #4]
 8007b58:	ebc8 0805 	rsb	r8, r8, r5
 8007b5c:	eb07 06c8 	add.w	r6, r7, r8, lsl #3
 8007b60:	4648      	mov	r0, r9
 8007b62:	f896 b002 	ldrb.w	fp, [r6, #2]
 8007b66:	f7fe ff93 	bl	8006a90 <LCD_SetDrawMode>
 8007b6a:	6825      	ldr	r5, [r4, #0]
 8007b6c:	f817 2038 	ldrb.w	r2, [r7, r8, lsl #3]
 8007b70:	f8d5 e01c 	ldr.w	lr, [r5, #28]
 8007b74:	f9b5 1024 	ldrsh.w	r1, [r5, #36]	; 0x24
 8007b78:	f89e c01a 	ldrb.w	ip, [lr, #26]
 8007b7c:	f89e 3018 	ldrb.w	r3, [lr, #24]
 8007b80:	9306      	str	r3, [sp, #24]
 8007b82:	4682      	mov	sl, r0
 8007b84:	f9b5 0022 	ldrsh.w	r0, [r5, #34]	; 0x22
 8007b88:	f8cd c000 	str.w	ip, [sp]
 8007b8c:	f89e e01b 	ldrb.w	lr, [lr, #27]
 8007b90:	f8cd e004 	str.w	lr, [sp, #4]
 8007b94:	f04f 0e01 	mov.w	lr, #1
 8007b98:	f8cd b00c 	str.w	fp, [sp, #12]
 8007b9c:	f8cd e008 	str.w	lr, [sp, #8]
 8007ba0:	6873      	ldr	r3, [r6, #4]
 8007ba2:	9304      	str	r3, [sp, #16]
 8007ba4:	6bad      	ldr	r5, [r5, #56]	; 0x38
 8007ba6:	9b06      	ldr	r3, [sp, #24]
 8007ba8:	9505      	str	r5, [sp, #20]
 8007baa:	f7fe fff9 	bl	8006ba0 <LCD_DrawBitmap>
 8007bae:	6823      	ldr	r3, [r4, #0]
 8007bb0:	69da      	ldr	r2, [r3, #28]
 8007bb2:	f892 b019 	ldrb.w	fp, [r2, #25]
 8007bb6:	7e11      	ldrb	r1, [r2, #24]
 8007bb8:	458b      	cmp	fp, r1
 8007bba:	d920      	bls.n	8007bfe <GUIPROP_DispChar+0xca>
 8007bbc:	f1b9 0f02 	cmp.w	r9, #2
 8007bc0:	7ed5      	ldrb	r5, [r2, #27]
 8007bc2:	d01c      	beq.n	8007bfe <GUIPROP_DispChar+0xca>
 8007bc4:	9107      	str	r1, [sp, #28]
 8007bc6:	f001 fb08 	bl	80091da <GUI_GetColor>
 8007bca:	4681      	mov	r9, r0
 8007bcc:	f001 fafe 	bl	80091cc <GUI_GetBkColor>
 8007bd0:	f7ff fc66 	bl	80074a0 <GUI_SetColor>
 8007bd4:	6824      	ldr	r4, [r4, #0]
 8007bd6:	f817 7038 	ldrb.w	r7, [r7, r8, lsl #3]
 8007bda:	69e2      	ldr	r2, [r4, #28]
 8007bdc:	f9b4 3024 	ldrsh.w	r3, [r4, #36]	; 0x24
 8007be0:	f9b4 0022 	ldrsh.w	r0, [r4, #34]	; 0x22
 8007be4:	7ed2      	ldrb	r2, [r2, #27]
 8007be6:	9907      	ldr	r1, [sp, #28]
 8007be8:	fb07 0202 	mla	r2, r7, r2, r0
 8007bec:	fb01 3105 	mla	r1, r1, r5, r3
 8007bf0:	fb0b 3305 	mla	r3, fp, r5, r3
 8007bf4:	f7fe ffa8 	bl	8006b48 <LCD_FillRect>
 8007bf8:	4648      	mov	r0, r9
 8007bfa:	f7ff fc51 	bl	80074a0 <GUI_SetColor>
 8007bfe:	4650      	mov	r0, sl
 8007c00:	f7fe ff46 	bl	8006a90 <LCD_SetDrawMode>
 8007c04:	4b05      	ldr	r3, [pc, #20]	; (8007c1c <GUIPROP_DispChar+0xe8>)
 8007c06:	681b      	ldr	r3, [r3, #0]
 8007c08:	69da      	ldr	r2, [r3, #28]
 8007c0a:	8c59      	ldrh	r1, [r3, #34]	; 0x22
 8007c0c:	7e90      	ldrb	r0, [r2, #26]
 8007c0e:	7872      	ldrb	r2, [r6, #1]
 8007c10:	fb00 1202 	mla	r2, r0, r2, r1
 8007c14:	845a      	strh	r2, [r3, #34]	; 0x22
 8007c16:	b009      	add	sp, #36	; 0x24
 8007c18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007c1c:	20000060 	.word	0x20000060

08007c20 <GUIPROP_GetCharDistX>:
 8007c20:	4b0d      	ldr	r3, [pc, #52]	; (8007c58 <GUIPROP_GetCharDistX+0x38>)
 8007c22:	b570      	push	{r4, r5, r6, lr}
 8007c24:	681b      	ldr	r3, [r3, #0]
 8007c26:	69dd      	ldr	r5, [r3, #28]
 8007c28:	4606      	mov	r6, r0
 8007c2a:	460c      	mov	r4, r1
 8007c2c:	69e8      	ldr	r0, [r5, #28]
 8007c2e:	4631      	mov	r1, r6
 8007c30:	f7ff ff75 	bl	8007b1e <GUIPROP__FindChar>
 8007c34:	b170      	cbz	r0, 8007c54 <GUIPROP_GetCharDistX+0x34>
 8007c36:	8803      	ldrh	r3, [r0, #0]
 8007c38:	6842      	ldr	r2, [r0, #4]
 8007c3a:	1af6      	subs	r6, r6, r3
 8007c3c:	eb02 03c6 	add.w	r3, r2, r6, lsl #3
 8007c40:	7858      	ldrb	r0, [r3, #1]
 8007c42:	7eab      	ldrb	r3, [r5, #26]
 8007c44:	fb10 f003 	smulbb	r0, r0, r3
 8007c48:	b124      	cbz	r4, 8007c54 <GUIPROP_GetCharDistX+0x34>
 8007c4a:	f812 2036 	ldrb.w	r2, [r2, r6, lsl #3]
 8007c4e:	fb12 f303 	smulbb	r3, r2, r3
 8007c52:	6023      	str	r3, [r4, #0]
 8007c54:	bd70      	pop	{r4, r5, r6, pc}
 8007c56:	bf00      	nop
 8007c58:	20000060 	.word	0x20000060

08007c5c <GUIPROP_GetFontInfo>:
 8007c5c:	2301      	movs	r3, #1
 8007c5e:	800b      	strh	r3, [r1, #0]
 8007c60:	4770      	bx	lr

08007c62 <GUIPROP_IsInFont>:
 8007c62:	b508      	push	{r3, lr}
 8007c64:	69c0      	ldr	r0, [r0, #28]
 8007c66:	f7ff ff5a 	bl	8007b1e <GUIPROP__FindChar>
 8007c6a:	3000      	adds	r0, #0
 8007c6c:	bf18      	it	ne
 8007c6e:	2001      	movne	r0, #1
 8007c70:	bd08      	pop	{r3, pc}
	...

08007c74 <GUIMONO_DispChar>:
 8007c74:	4b52      	ldr	r3, [pc, #328]	; (8007dc0 <GUIMONO_DispChar+0x14c>)
 8007c76:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007c7a:	681b      	ldr	r3, [r3, #0]
 8007c7c:	69d9      	ldr	r1, [r3, #28]
 8007c7e:	8c5f      	ldrh	r7, [r3, #34]	; 0x22
 8007c80:	69cc      	ldr	r4, [r1, #28]
 8007c82:	8c9d      	ldrh	r5, [r3, #36]	; 0x24
 8007c84:	89a2      	ldrh	r2, [r4, #12]
 8007c86:	4290      	cmp	r0, r2
 8007c88:	b08b      	sub	sp, #44	; 0x2c
 8007c8a:	d308      	bcc.n	8007c9e <GUIMONO_DispChar+0x2a>
 8007c8c:	89e6      	ldrh	r6, [r4, #14]
 8007c8e:	4286      	cmp	r6, r0
 8007c90:	d305      	bcc.n	8007c9e <GUIMONO_DispChar+0x2a>
 8007c92:	f8d4 9000 	ldr.w	r9, [r4]
 8007c96:	1a82      	subs	r2, r0, r2
 8007c98:	f04f 3bff 	mov.w	fp, #4294967295
 8007c9c:	e015      	b.n	8007cca <GUIMONO_DispChar+0x56>
 8007c9e:	68a2      	ldr	r2, [r4, #8]
 8007ca0:	f8d4 9004 	ldr.w	r9, [r4, #4]
 8007ca4:	2a00      	cmp	r2, #0
 8007ca6:	f000 8081 	beq.w	8007dac <GUIMONO_DispChar+0x138>
 8007caa:	8816      	ldrh	r6, [r2, #0]
 8007cac:	42b0      	cmp	r0, r6
 8007cae:	d37d      	bcc.n	8007dac <GUIMONO_DispChar+0x138>
 8007cb0:	f8b2 c002 	ldrh.w	ip, [r2, #2]
 8007cb4:	4584      	cmp	ip, r0
 8007cb6:	d379      	bcc.n	8007dac <GUIMONO_DispChar+0x138>
 8007cb8:	6852      	ldr	r2, [r2, #4]
 8007cba:	1b80      	subs	r0, r0, r6
 8007cbc:	b280      	uxth	r0, r0
 8007cbe:	eb02 0680 	add.w	r6, r2, r0, lsl #2
 8007cc2:	f932 2020 	ldrsh.w	r2, [r2, r0, lsl #2]
 8007cc6:	f9b6 b002 	ldrsh.w	fp, [r6, #2]
 8007cca:	1c50      	adds	r0, r2, #1
 8007ccc:	d06e      	beq.n	8007dac <GUIMONO_DispChar+0x138>
 8007cce:	f891 8018 	ldrb.w	r8, [r1, #24]
 8007cd2:	7ca1      	ldrb	r1, [r4, #18]
 8007cd4:	f8b3 a02a 	ldrh.w	sl, [r3, #42]	; 0x2a
 8007cd8:	7c26      	ldrb	r6, [r4, #16]
 8007cda:	9206      	str	r2, [sp, #24]
 8007cdc:	fb18 f101 	smulbb	r1, r8, r1
 8007ce0:	9107      	str	r1, [sp, #28]
 8007ce2:	fa0f f18a 	sxth.w	r1, sl
 8007ce6:	4608      	mov	r0, r1
 8007ce8:	9108      	str	r1, [sp, #32]
 8007cea:	f7fe fed1 	bl	8006a90 <LCD_SetDrawMode>
 8007cee:	4934      	ldr	r1, [pc, #208]	; (8007dc0 <GUIMONO_DispChar+0x14c>)
 8007cf0:	9009      	str	r0, [sp, #36]	; 0x24
 8007cf2:	680b      	ldr	r3, [r1, #0]
 8007cf4:	9a06      	ldr	r2, [sp, #24]
 8007cf6:	69d9      	ldr	r1, [r3, #28]
 8007cf8:	7e88      	ldrb	r0, [r1, #26]
 8007cfa:	9000      	str	r0, [sp, #0]
 8007cfc:	7ec9      	ldrb	r1, [r1, #27]
 8007cfe:	9101      	str	r1, [sp, #4]
 8007d00:	2101      	movs	r1, #1
 8007d02:	9102      	str	r1, [sp, #8]
 8007d04:	7ca1      	ldrb	r1, [r4, #18]
 8007d06:	9103      	str	r1, [sp, #12]
 8007d08:	9907      	ldr	r1, [sp, #28]
 8007d0a:	fb01 9202 	mla	r2, r1, r2, r9
 8007d0e:	9204      	str	r2, [sp, #16]
 8007d10:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d12:	9305      	str	r3, [sp, #20]
 8007d14:	b23f      	sxth	r7, r7
 8007d16:	b22d      	sxth	r5, r5
 8007d18:	4638      	mov	r0, r7
 8007d1a:	4629      	mov	r1, r5
 8007d1c:	4632      	mov	r2, r6
 8007d1e:	4643      	mov	r3, r8
 8007d20:	f7fe ff3e 	bl	8006ba0 <LCD_DrawBitmap>
 8007d24:	f1bb 3fff 	cmp.w	fp, #4294967295
 8007d28:	d01b      	beq.n	8007d62 <GUIMONO_DispChar+0xee>
 8007d2a:	f04a 0002 	orr.w	r0, sl, #2
 8007d2e:	b200      	sxth	r0, r0
 8007d30:	f7fe feae 	bl	8006a90 <LCD_SetDrawMode>
 8007d34:	4a22      	ldr	r2, [pc, #136]	; (8007dc0 <GUIMONO_DispChar+0x14c>)
 8007d36:	6813      	ldr	r3, [r2, #0]
 8007d38:	69da      	ldr	r2, [r3, #28]
 8007d3a:	7e91      	ldrb	r1, [r2, #26]
 8007d3c:	9100      	str	r1, [sp, #0]
 8007d3e:	7ed2      	ldrb	r2, [r2, #27]
 8007d40:	9201      	str	r2, [sp, #4]
 8007d42:	2101      	movs	r1, #1
 8007d44:	9102      	str	r1, [sp, #8]
 8007d46:	9907      	ldr	r1, [sp, #28]
 8007d48:	7ca2      	ldrb	r2, [r4, #18]
 8007d4a:	9203      	str	r2, [sp, #12]
 8007d4c:	fb01 920b 	mla	r2, r1, fp, r9
 8007d50:	9204      	str	r2, [sp, #16]
 8007d52:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8007d54:	9305      	str	r3, [sp, #20]
 8007d56:	4638      	mov	r0, r7
 8007d58:	4629      	mov	r1, r5
 8007d5a:	4632      	mov	r2, r6
 8007d5c:	4643      	mov	r3, r8
 8007d5e:	f7fe ff1f 	bl	8006ba0 <LCD_DrawBitmap>
 8007d62:	f8df 805c 	ldr.w	r8, [pc, #92]	; 8007dc0 <GUIMONO_DispChar+0x14c>
 8007d66:	f8d8 3000 	ldr.w	r3, [r8]
 8007d6a:	69db      	ldr	r3, [r3, #28]
 8007d6c:	7e5a      	ldrb	r2, [r3, #25]
 8007d6e:	7e1b      	ldrb	r3, [r3, #24]
 8007d70:	429a      	cmp	r2, r3
 8007d72:	d917      	bls.n	8007da4 <GUIMONO_DispChar+0x130>
 8007d74:	9a08      	ldr	r2, [sp, #32]
 8007d76:	2a02      	cmp	r2, #2
 8007d78:	d014      	beq.n	8007da4 <GUIMONO_DispChar+0x130>
 8007d7a:	f08a 0004 	eor.w	r0, sl, #4
 8007d7e:	b200      	sxth	r0, r0
 8007d80:	f7fe fe86 	bl	8006a90 <LCD_SetDrawMode>
 8007d84:	f8d8 3000 	ldr.w	r3, [r8]
 8007d88:	69db      	ldr	r3, [r3, #28]
 8007d8a:	f893 e018 	ldrb.w	lr, [r3, #24]
 8007d8e:	7ed9      	ldrb	r1, [r3, #27]
 8007d90:	7e9a      	ldrb	r2, [r3, #26]
 8007d92:	7e5b      	ldrb	r3, [r3, #25]
 8007d94:	4638      	mov	r0, r7
 8007d96:	fb0e 5101 	mla	r1, lr, r1, r5
 8007d9a:	fb06 7202 	mla	r2, r6, r2, r7
 8007d9e:	442b      	add	r3, r5
 8007da0:	f7fe fed2 	bl	8006b48 <LCD_FillRect>
 8007da4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8007da6:	b2d8      	uxtb	r0, r3
 8007da8:	f7fe fe72 	bl	8006a90 <LCD_SetDrawMode>
 8007dac:	4b04      	ldr	r3, [pc, #16]	; (8007dc0 <GUIMONO_DispChar+0x14c>)
 8007dae:	7c61      	ldrb	r1, [r4, #17]
 8007db0:	681b      	ldr	r3, [r3, #0]
 8007db2:	8c5a      	ldrh	r2, [r3, #34]	; 0x22
 8007db4:	440a      	add	r2, r1
 8007db6:	845a      	strh	r2, [r3, #34]	; 0x22
 8007db8:	b00b      	add	sp, #44	; 0x2c
 8007dba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007dbe:	bf00      	nop
 8007dc0:	20000060 	.word	0x20000060

08007dc4 <GUIMONO_GetCharDistX>:
 8007dc4:	4b04      	ldr	r3, [pc, #16]	; (8007dd8 <GUIMONO_GetCharDistX+0x14>)
 8007dc6:	681b      	ldr	r3, [r3, #0]
 8007dc8:	69db      	ldr	r3, [r3, #28]
 8007dca:	69db      	ldr	r3, [r3, #28]
 8007dcc:	b109      	cbz	r1, 8007dd2 <GUIMONO_GetCharDistX+0xe>
 8007dce:	7c1a      	ldrb	r2, [r3, #16]
 8007dd0:	600a      	str	r2, [r1, #0]
 8007dd2:	7c58      	ldrb	r0, [r3, #17]
 8007dd4:	4770      	bx	lr
 8007dd6:	bf00      	nop
 8007dd8:	20000060 	.word	0x20000060

08007ddc <GUIMONO_GetFontInfo>:
 8007ddc:	2302      	movs	r3, #2
 8007dde:	800b      	strh	r3, [r1, #0]
 8007de0:	4770      	bx	lr

08007de2 <GUIMONO_IsInFont>:
 8007de2:	69c3      	ldr	r3, [r0, #28]
 8007de4:	899a      	ldrh	r2, [r3, #12]
 8007de6:	428a      	cmp	r2, r1
 8007de8:	d802      	bhi.n	8007df0 <GUIMONO_IsInFont+0xe>
 8007dea:	89da      	ldrh	r2, [r3, #14]
 8007dec:	428a      	cmp	r2, r1
 8007dee:	d20f      	bcs.n	8007e10 <GUIMONO_IsInFont+0x2e>
 8007df0:	6898      	ldr	r0, [r3, #8]
 8007df2:	b180      	cbz	r0, 8007e16 <GUIMONO_IsInFont+0x34>
 8007df4:	8803      	ldrh	r3, [r0, #0]
 8007df6:	4299      	cmp	r1, r3
 8007df8:	d30c      	bcc.n	8007e14 <GUIMONO_IsInFont+0x32>
 8007dfa:	8842      	ldrh	r2, [r0, #2]
 8007dfc:	428a      	cmp	r2, r1
 8007dfe:	d309      	bcc.n	8007e14 <GUIMONO_IsInFont+0x32>
 8007e00:	1ac9      	subs	r1, r1, r3
 8007e02:	6842      	ldr	r2, [r0, #4]
 8007e04:	f832 0021 	ldrh.w	r0, [r2, r1, lsl #2]
 8007e08:	43c0      	mvns	r0, r0
 8007e0a:	f3c0 30c0 	ubfx	r0, r0, #15, #1
 8007e0e:	4770      	bx	lr
 8007e10:	2001      	movs	r0, #1
 8007e12:	4770      	bx	lr
 8007e14:	2000      	movs	r0, #0
 8007e16:	4770      	bx	lr

08007e18 <_Log2VisBuffered>:
 8007e18:	4770      	bx	lr
	...

08007e1c <_DispLine>:
 8007e1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007e1e:	4615      	mov	r5, r2
 8007e20:	ab02      	add	r3, sp, #8
 8007e22:	4a1a      	ldr	r2, [pc, #104]	; (8007e8c <_DispLine+0x70>)
 8007e24:	f843 1d08 	str.w	r1, [r3, #-8]!
 8007e28:	9001      	str	r0, [sp, #4]
 8007e2a:	6812      	ldr	r2, [r2, #0]
 8007e2c:	4c18      	ldr	r4, [pc, #96]	; (8007e90 <_DispLine+0x74>)
 8007e2e:	4669      	mov	r1, sp
 8007e30:	4790      	blx	r2
 8007e32:	6823      	ldr	r3, [r4, #0]
 8007e34:	9001      	str	r0, [sp, #4]
 8007e36:	6958      	ldr	r0, [r3, #20]
 8007e38:	b958      	cbnz	r0, 8007e52 <_DispLine+0x36>
 8007e3a:	2001      	movs	r0, #1
 8007e3c:	f7ff f912 	bl	8007064 <GUI__ManageCache>
 8007e40:	6823      	ldr	r3, [r4, #0]
 8007e42:	69db      	ldr	r3, [r3, #28]
 8007e44:	695b      	ldr	r3, [r3, #20]
 8007e46:	b1bb      	cbz	r3, 8007e78 <_DispLine+0x5c>
 8007e48:	689b      	ldr	r3, [r3, #8]
 8007e4a:	9801      	ldr	r0, [sp, #4]
 8007e4c:	9900      	ldr	r1, [sp, #0]
 8007e4e:	4798      	blx	r3
 8007e50:	e017      	b.n	8007e82 <_DispLine+0x66>
 8007e52:	4629      	mov	r1, r5
 8007e54:	f7ff fb4b 	bl	80074ee <GUI_RectsIntersect>
 8007e58:	2800      	cmp	r0, #0
 8007e5a:	d1ee      	bne.n	8007e3a <_DispLine+0x1e>
 8007e5c:	e014      	b.n	8007e88 <_DispLine+0x6c>
 8007e5e:	a801      	add	r0, sp, #4
 8007e60:	f001 f96a 	bl	8009138 <GUI_UC__GetCharCodeInc>
 8007e64:	6823      	ldr	r3, [r4, #0]
 8007e66:	69db      	ldr	r3, [r3, #28]
 8007e68:	681b      	ldr	r3, [r3, #0]
 8007e6a:	4605      	mov	r5, r0
 8007e6c:	4798      	blx	r3
 8007e6e:	4b09      	ldr	r3, [pc, #36]	; (8007e94 <_DispLine+0x78>)
 8007e70:	681b      	ldr	r3, [r3, #0]
 8007e72:	b10b      	cbz	r3, 8007e78 <_DispLine+0x5c>
 8007e74:	4628      	mov	r0, r5
 8007e76:	4798      	blx	r3
 8007e78:	9b00      	ldr	r3, [sp, #0]
 8007e7a:	3b01      	subs	r3, #1
 8007e7c:	2b00      	cmp	r3, #0
 8007e7e:	9300      	str	r3, [sp, #0]
 8007e80:	daed      	bge.n	8007e5e <_DispLine+0x42>
 8007e82:	2000      	movs	r0, #0
 8007e84:	f7ff f8ee 	bl	8007064 <GUI__ManageCache>
 8007e88:	b003      	add	sp, #12
 8007e8a:	bd30      	pop	{r4, r5, pc}
 8007e8c:	20000068 	.word	0x20000068
 8007e90:	20000060 	.word	0x20000060
 8007e94:	200222f8 	.word	0x200222f8

08007e98 <GUI__GetLineNumChars>:
 8007e98:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007e9a:	460d      	mov	r5, r1
 8007e9c:	9001      	str	r0, [sp, #4]
 8007e9e:	4604      	mov	r4, r0
 8007ea0:	b198      	cbz	r0, 8007eca <GUI__GetLineNumChars+0x32>
 8007ea2:	4b0b      	ldr	r3, [pc, #44]	; (8007ed0 <GUI__GetLineNumChars+0x38>)
 8007ea4:	681b      	ldr	r3, [r3, #0]
 8007ea6:	69db      	ldr	r3, [r3, #28]
 8007ea8:	695b      	ldr	r3, [r3, #20]
 8007eaa:	b10b      	cbz	r3, 8007eb0 <GUI__GetLineNumChars+0x18>
 8007eac:	685b      	ldr	r3, [r3, #4]
 8007eae:	b90b      	cbnz	r3, 8007eb4 <GUI__GetLineNumChars+0x1c>
 8007eb0:	2400      	movs	r4, #0
 8007eb2:	e008      	b.n	8007ec6 <GUI__GetLineNumChars+0x2e>
 8007eb4:	4798      	blx	r3
 8007eb6:	e009      	b.n	8007ecc <GUI__GetLineNumChars+0x34>
 8007eb8:	a801      	add	r0, sp, #4
 8007eba:	f001 f93d 	bl	8009138 <GUI_UC__GetCharCodeInc>
 8007ebe:	b120      	cbz	r0, 8007eca <GUI__GetLineNumChars+0x32>
 8007ec0:	280a      	cmp	r0, #10
 8007ec2:	d002      	beq.n	8007eca <GUI__GetLineNumChars+0x32>
 8007ec4:	3401      	adds	r4, #1
 8007ec6:	42ac      	cmp	r4, r5
 8007ec8:	dbf6      	blt.n	8007eb8 <GUI__GetLineNumChars+0x20>
 8007eca:	4620      	mov	r0, r4
 8007ecc:	b003      	add	sp, #12
 8007ece:	bd30      	pop	{r4, r5, pc}
 8007ed0:	20000060 	.word	0x20000060

08007ed4 <GUI__GetOverlap>:
 8007ed4:	b513      	push	{r0, r1, r4, lr}
 8007ed6:	a902      	add	r1, sp, #8
 8007ed8:	2400      	movs	r4, #0
 8007eda:	f841 4d04 	str.w	r4, [r1, #-4]!
 8007ede:	f000 f8b7 	bl	8008050 <GUI_GetCharDistXEx>
 8007ee2:	9b01      	ldr	r3, [sp, #4]
 8007ee4:	4283      	cmp	r3, r0
 8007ee6:	bfcc      	ite	gt
 8007ee8:	ebc0 0003 	rsbgt	r0, r0, r3
 8007eec:	4620      	movle	r0, r4
 8007eee:	b002      	add	sp, #8
 8007ef0:	bd10      	pop	{r4, pc}
	...

08007ef4 <GUI__GetLineDistX>:
 8007ef4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8007ef6:	4a15      	ldr	r2, [pc, #84]	; (8007f4c <GUI__GetLineDistX+0x58>)
 8007ef8:	9001      	str	r0, [sp, #4]
 8007efa:	ab02      	add	r3, sp, #8
 8007efc:	6812      	ldr	r2, [r2, #0]
 8007efe:	f843 1d08 	str.w	r1, [r3, #-8]!
 8007f02:	4669      	mov	r1, sp
 8007f04:	4790      	blx	r2
 8007f06:	9001      	str	r0, [sp, #4]
 8007f08:	b1f0      	cbz	r0, 8007f48 <GUI__GetLineDistX+0x54>
 8007f0a:	4b11      	ldr	r3, [pc, #68]	; (8007f50 <GUI__GetLineDistX+0x5c>)
 8007f0c:	681b      	ldr	r3, [r3, #0]
 8007f0e:	69db      	ldr	r3, [r3, #28]
 8007f10:	695b      	ldr	r3, [r3, #20]
 8007f12:	b10b      	cbz	r3, 8007f18 <GUI__GetLineDistX+0x24>
 8007f14:	681b      	ldr	r3, [r3, #0]
 8007f16:	b913      	cbnz	r3, 8007f1e <GUI__GetLineDistX+0x2a>
 8007f18:	2500      	movs	r5, #0
 8007f1a:	462c      	mov	r4, r5
 8007f1c:	e002      	b.n	8007f24 <GUI__GetLineDistX+0x30>
 8007f1e:	9900      	ldr	r1, [sp, #0]
 8007f20:	4798      	blx	r3
 8007f22:	e011      	b.n	8007f48 <GUI__GetLineDistX+0x54>
 8007f24:	9b00      	ldr	r3, [sp, #0]
 8007f26:	3b01      	subs	r3, #1
 8007f28:	2b00      	cmp	r3, #0
 8007f2a:	9300      	str	r3, [sp, #0]
 8007f2c:	db07      	blt.n	8007f3e <GUI__GetLineDistX+0x4a>
 8007f2e:	a801      	add	r0, sp, #4
 8007f30:	f001 f902 	bl	8009138 <GUI_UC__GetCharCodeInc>
 8007f34:	4605      	mov	r5, r0
 8007f36:	f000 f881 	bl	800803c <GUI_GetCharDistX>
 8007f3a:	4404      	add	r4, r0
 8007f3c:	e7f2      	b.n	8007f24 <GUI__GetLineDistX+0x30>
 8007f3e:	4628      	mov	r0, r5
 8007f40:	f7ff ffc8 	bl	8007ed4 <GUI__GetOverlap>
 8007f44:	4420      	add	r0, r4
 8007f46:	e7ff      	b.n	8007f48 <GUI__GetLineDistX+0x54>
 8007f48:	b003      	add	sp, #12
 8007f4a:	bd30      	pop	{r4, r5, pc}
 8007f4c:	20000068 	.word	0x20000068
 8007f50:	20000060 	.word	0x20000060

08007f54 <GUI__DispLine>:
 8007f54:	4b27      	ldr	r3, [pc, #156]	; (8007ff4 <GUI__DispLine+0xa0>)
 8007f56:	681b      	ldr	r3, [r3, #0]
 8007f58:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8007f5a:	4605      	mov	r5, r0
 8007f5c:	460c      	mov	r4, r1
 8007f5e:	b163      	cbz	r3, 8007f7a <GUI__DispLine+0x26>
 8007f60:	2000      	movs	r0, #0
 8007f62:	f7fd f85b 	bl	800501c <WM__InitIVRSearch>
 8007f66:	2800      	cmp	r0, #0
 8007f68:	d041      	beq.n	8007fee <GUI__DispLine+0x9a>
 8007f6a:	4628      	mov	r0, r5
 8007f6c:	4621      	mov	r1, r4
 8007f6e:	466a      	mov	r2, sp
 8007f70:	f7ff ff54 	bl	8007e1c <_DispLine>
 8007f74:	f7fc ff90 	bl	8004e98 <WM__GetNextIVR>
 8007f78:	e7f5      	b.n	8007f66 <GUI__DispLine+0x12>
 8007f7a:	6810      	ldr	r0, [r2, #0]
 8007f7c:	6851      	ldr	r1, [r2, #4]
 8007f7e:	4e1e      	ldr	r6, [pc, #120]	; (8007ff8 <GUI__DispLine+0xa4>)
 8007f80:	466b      	mov	r3, sp
 8007f82:	c303      	stmia	r3!, {r0, r1}
 8007f84:	6833      	ldr	r3, [r6, #0]
 8007f86:	f8bd 1000 	ldrh.w	r1, [sp]
 8007f8a:	f8b3 204c 	ldrh.w	r2, [r3, #76]	; 0x4c
 8007f8e:	f8b3 3050 	ldrh.w	r3, [r3, #80]	; 0x50
 8007f92:	4411      	add	r1, r2
 8007f94:	f8ad 1000 	strh.w	r1, [sp]
 8007f98:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 8007f9c:	4419      	add	r1, r3
 8007f9e:	f8ad 1002 	strh.w	r1, [sp, #2]
 8007fa2:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 8007fa6:	440a      	add	r2, r1
 8007fa8:	f8ad 2004 	strh.w	r2, [sp, #4]
 8007fac:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 8007fb0:	4668      	mov	r0, sp
 8007fb2:	4413      	add	r3, r2
 8007fb4:	f8ad 3006 	strh.w	r3, [sp, #6]
 8007fb8:	f7fd f830 	bl	800501c <WM__InitIVRSearch>
 8007fbc:	6833      	ldr	r3, [r6, #0]
 8007fbe:	b940      	cbnz	r0, 8007fd2 <GUI__DispLine+0x7e>
 8007fc0:	8c59      	ldrh	r1, [r3, #34]	; 0x22
 8007fc2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8007fc4:	1a8a      	subs	r2, r1, r2
 8007fc6:	845a      	strh	r2, [r3, #34]	; 0x22
 8007fc8:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 8007fca:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007fcc:	1a8a      	subs	r2, r1, r2
 8007fce:	849a      	strh	r2, [r3, #36]	; 0x24
 8007fd0:	e00d      	b.n	8007fee <GUI__DispLine+0x9a>
 8007fd2:	f8bd 2000 	ldrh.w	r2, [sp]
 8007fd6:	845a      	strh	r2, [r3, #34]	; 0x22
 8007fd8:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 8007fdc:	849a      	strh	r2, [r3, #36]	; 0x24
 8007fde:	4628      	mov	r0, r5
 8007fe0:	4621      	mov	r1, r4
 8007fe2:	466a      	mov	r2, sp
 8007fe4:	f7ff ff1a 	bl	8007e1c <_DispLine>
 8007fe8:	f7fc ff56 	bl	8004e98 <WM__GetNextIVR>
 8007fec:	e7e6      	b.n	8007fbc <GUI__DispLine+0x68>
 8007fee:	b002      	add	sp, #8
 8007ff0:	bd70      	pop	{r4, r5, r6, pc}
 8007ff2:	bf00      	nop
 8007ff4:	200222e0 	.word	0x200222e0
 8007ff8:	20000060 	.word	0x20000060

08007ffc <GUI_GetYAdjust>:
 8007ffc:	4b0a      	ldr	r3, [pc, #40]	; (8008028 <GUI_GetYAdjust+0x2c>)
 8007ffe:	681b      	ldr	r3, [r3, #0]
 8008000:	8d9a      	ldrh	r2, [r3, #44]	; 0x2c
 8008002:	f002 020c 	and.w	r2, r2, #12
 8008006:	2a08      	cmp	r2, #8
 8008008:	d007      	beq.n	800801a <GUI_GetYAdjust+0x1e>
 800800a:	2a0c      	cmp	r2, #12
 800800c:	d005      	beq.n	800801a <GUI_GetYAdjust+0x1e>
 800800e:	2a04      	cmp	r2, #4
 8008010:	d107      	bne.n	8008022 <GUI_GetYAdjust+0x26>
 8008012:	69db      	ldr	r3, [r3, #28]
 8008014:	7e18      	ldrb	r0, [r3, #24]
 8008016:	3801      	subs	r0, #1
 8008018:	4770      	bx	lr
 800801a:	69db      	ldr	r3, [r3, #28]
 800801c:	7e18      	ldrb	r0, [r3, #24]
 800801e:	0840      	lsrs	r0, r0, #1
 8008020:	4770      	bx	lr
 8008022:	2000      	movs	r0, #0
 8008024:	4770      	bx	lr
 8008026:	bf00      	nop
 8008028:	20000060 	.word	0x20000060

0800802c <GUI_GetFontDistY>:
 800802c:	4b02      	ldr	r3, [pc, #8]	; (8008038 <GUI_GetFontDistY+0xc>)
 800802e:	681b      	ldr	r3, [r3, #0]
 8008030:	69db      	ldr	r3, [r3, #28]
 8008032:	7e58      	ldrb	r0, [r3, #25]
 8008034:	4770      	bx	lr
 8008036:	bf00      	nop
 8008038:	20000060 	.word	0x20000060

0800803c <GUI_GetCharDistX>:
 800803c:	b508      	push	{r3, lr}
 800803e:	4b03      	ldr	r3, [pc, #12]	; (800804c <GUI_GetCharDistX+0x10>)
 8008040:	681b      	ldr	r3, [r3, #0]
 8008042:	69db      	ldr	r3, [r3, #28]
 8008044:	2100      	movs	r1, #0
 8008046:	685b      	ldr	r3, [r3, #4]
 8008048:	4798      	blx	r3
 800804a:	bd08      	pop	{r3, pc}
 800804c:	20000060 	.word	0x20000060

08008050 <GUI_GetCharDistXEx>:
 8008050:	b508      	push	{r3, lr}
 8008052:	4b03      	ldr	r3, [pc, #12]	; (8008060 <GUI_GetCharDistXEx+0x10>)
 8008054:	681b      	ldr	r3, [r3, #0]
 8008056:	69db      	ldr	r3, [r3, #28]
 8008058:	685b      	ldr	r3, [r3, #4]
 800805a:	4798      	blx	r3
 800805c:	bd08      	pop	{r3, pc}
 800805e:	bf00      	nop
 8008060:	20000060 	.word	0x20000060

08008064 <_PushFreeBlock>:
 8008064:	4b07      	ldr	r3, [pc, #28]	; (8008084 <_PushFreeBlock+0x20>)
 8008066:	685a      	ldr	r2, [r3, #4]
 8008068:	6a59      	ldr	r1, [r3, #36]	; 0x24
 800806a:	3201      	adds	r2, #1
 800806c:	b510      	push	{r4, lr}
 800806e:	605a      	str	r2, [r3, #4]
 8008070:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8008072:	eb02 04c0 	add.w	r4, r2, r0, lsl #3
 8008076:	6061      	str	r1, [r4, #4]
 8008078:	2100      	movs	r1, #0
 800807a:	f802 1030 	strb.w	r1, [r2, r0, lsl #3]
 800807e:	6258      	str	r0, [r3, #36]	; 0x24
 8008080:	bd10      	pop	{r4, pc}
 8008082:	bf00      	nop
 8008084:	20022318 	.word	0x20022318

08008088 <_OnExit>:
 8008088:	b538      	push	{r3, r4, r5, lr}
 800808a:	4d0b      	ldr	r5, [pc, #44]	; (80080b8 <_OnExit+0x30>)
 800808c:	2400      	movs	r4, #0
 800808e:	f105 0040 	add.w	r0, r5, #64	; 0x40
 8008092:	4621      	mov	r1, r4
 8008094:	2280      	movs	r2, #128	; 0x80
 8008096:	f885 4028 	strb.w	r4, [r5, #40]	; 0x28
 800809a:	f7fe ff4d 	bl	8006f38 <GUI__memset>
 800809e:	4628      	mov	r0, r5
 80080a0:	4621      	mov	r1, r4
 80080a2:	22c0      	movs	r2, #192	; 0xc0
 80080a4:	f7fe ff48 	bl	8006f38 <GUI__memset>
 80080a8:	4621      	mov	r1, r4
 80080aa:	4804      	ldr	r0, [pc, #16]	; (80080bc <_OnExit+0x34>)
 80080ac:	220c      	movs	r2, #12
 80080ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80080b2:	f7fe bf41 	b.w	8006f38 <GUI__memset>
 80080b6:	bf00      	nop
 80080b8:	20022318 	.word	0x20022318
 80080bc:	20002088 	.word	0x20002088

080080c0 <_RemoveFreeBlock>:
 80080c0:	b510      	push	{r4, lr}
 80080c2:	6842      	ldr	r2, [r0, #4]
 80080c4:	230f      	movs	r3, #15
 80080c6:	490b      	ldr	r1, [pc, #44]	; (80080f4 <_RemoveFreeBlock+0x34>)
 80080c8:	eb01 04c3 	add.w	r4, r1, r3, lsl #3
 80080cc:	6c24      	ldr	r4, [r4, #64]	; 0x40
 80080ce:	42a2      	cmp	r2, r4
 80080d0:	d202      	bcs.n	80080d8 <_RemoveFreeBlock+0x18>
 80080d2:	f113 33ff 	adds.w	r3, r3, #4294967295
 80080d6:	d2f6      	bcs.n	80080c6 <_RemoveFreeBlock+0x6>
 80080d8:	680c      	ldr	r4, [r1, #0]
 80080da:	1aa2      	subs	r2, r4, r2
 80080dc:	600a      	str	r2, [r1, #0]
 80080de:	6882      	ldr	r2, [r0, #8]
 80080e0:	68c0      	ldr	r0, [r0, #12]
 80080e2:	b102      	cbz	r2, 80080e6 <_RemoveFreeBlock+0x26>
 80080e4:	6050      	str	r0, [r2, #4]
 80080e6:	b108      	cbz	r0, 80080ec <_RemoveFreeBlock+0x2c>
 80080e8:	6002      	str	r2, [r0, #0]
 80080ea:	bd10      	pop	{r4, pc}
 80080ec:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
 80080f0:	645a      	str	r2, [r3, #68]	; 0x44
 80080f2:	bd10      	pop	{r4, pc}
 80080f4:	20022318 	.word	0x20022318

080080f8 <_AddFreeMemory>:
 80080f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80080fa:	4e25      	ldr	r6, [pc, #148]	; (8008190 <_AddFreeMemory+0x98>)
 80080fc:	68f3      	ldr	r3, [r6, #12]
 80080fe:	1e5a      	subs	r2, r3, #1
 8008100:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8008102:	4605      	mov	r5, r0
 8008104:	4413      	add	r3, r2
 8008106:	1808      	adds	r0, r1, r0
 8008108:	4298      	cmp	r0, r3
 800810a:	460c      	mov	r4, r1
 800810c:	d805      	bhi.n	800811a <_AddFreeMemory+0x22>
 800810e:	594b      	ldr	r3, [r1, r5]
 8008110:	b91b      	cbnz	r3, 800811a <_AddFreeMemory+0x22>
 8008112:	6843      	ldr	r3, [r0, #4]
 8008114:	441d      	add	r5, r3
 8008116:	f7ff ffd3 	bl	80080c0 <_RemoveFreeBlock>
 800811a:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 800811c:	429c      	cmp	r4, r3
 800811e:	d90a      	bls.n	8008136 <_AddFreeMemory+0x3e>
 8008120:	f854 7c04 	ldr.w	r7, [r4, #-4]
 8008124:	1be7      	subs	r7, r4, r7
 8008126:	683b      	ldr	r3, [r7, #0]
 8008128:	b92b      	cbnz	r3, 8008136 <_AddFreeMemory+0x3e>
 800812a:	687b      	ldr	r3, [r7, #4]
 800812c:	4638      	mov	r0, r7
 800812e:	441d      	add	r5, r3
 8008130:	f7ff ffc6 	bl	80080c0 <_RemoveFreeBlock>
 8008134:	463c      	mov	r4, r7
 8008136:	230f      	movs	r3, #15
 8008138:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
 800813c:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800813e:	4295      	cmp	r5, r2
 8008140:	d202      	bcs.n	8008148 <_AddFreeMemory+0x50>
 8008142:	f113 33ff 	adds.w	r3, r3, #4294967295
 8008146:	d2f7      	bcs.n	8008138 <_AddFreeMemory+0x40>
 8008148:	3308      	adds	r3, #8
 800814a:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
 800814e:	1961      	adds	r1, r4, r5
 8008150:	6852      	ldr	r2, [r2, #4]
 8008152:	60a2      	str	r2, [r4, #8]
 8008154:	2000      	movs	r0, #0
 8008156:	e884 0021 	stmia.w	r4, {r0, r5}
 800815a:	6124      	str	r4, [r4, #16]
 800815c:	f841 5c04 	str.w	r5, [r1, #-4]
 8008160:	f104 0108 	add.w	r1, r4, #8
 8008164:	b102      	cbz	r2, 8008168 <_AddFreeMemory+0x70>
 8008166:	6051      	str	r1, [r2, #4]
 8008168:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 800816c:	60e0      	str	r0, [r4, #12]
 800816e:	6059      	str	r1, [r3, #4]
 8008170:	6833      	ldr	r3, [r6, #0]
 8008172:	f896 1029 	ldrb.w	r1, [r6, #41]	; 0x29
 8008176:	4a06      	ldr	r2, [pc, #24]	; (8008190 <_AddFreeMemory+0x98>)
 8008178:	442b      	add	r3, r5
 800817a:	6033      	str	r3, [r6, #0]
 800817c:	b929      	cbnz	r1, 800818a <_AddFreeMemory+0x92>
 800817e:	68d1      	ldr	r1, [r2, #12]
 8008180:	1acb      	subs	r3, r1, r3
 8008182:	6891      	ldr	r1, [r2, #8]
 8008184:	4299      	cmp	r1, r3
 8008186:	bf38      	it	cc
 8008188:	6093      	strcc	r3, [r2, #8]
 800818a:	4628      	mov	r0, r5
 800818c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800818e:	bf00      	nop
 8008190:	20022318 	.word	0x20022318

08008194 <_RemoveHoles>:
 8008194:	4b25      	ldr	r3, [pc, #148]	; (800822c <_RemoveHoles+0x98>)
 8008196:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800819a:	68da      	ldr	r2, [r3, #12]
 800819c:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 800819e:	3a01      	subs	r2, #1
 80081a0:	4682      	mov	sl, r0
 80081a2:	eb02 0904 	add.w	r9, r2, r4
 80081a6:	469b      	mov	fp, r3
 80081a8:	e894 0028 	ldmia.w	r4, {r3, r5}
 80081ac:	2b00      	cmp	r3, #0
 80081ae:	d133      	bne.n	8008218 <_RemoveHoles+0x84>
 80081b0:	eb04 0805 	add.w	r8, r4, r5
 80081b4:	45c8      	cmp	r8, r9
 80081b6:	d22f      	bcs.n	8008218 <_RemoveHoles+0x84>
 80081b8:	f854 c005 	ldr.w	ip, [r4, r5]
 80081bc:	f8d8 6004 	ldr.w	r6, [r8, #4]
 80081c0:	f1bc 0f00 	cmp.w	ip, #0
 80081c4:	d028      	beq.n	8008218 <_RemoveHoles+0x84>
 80081c6:	f8db 3034 	ldr.w	r3, [fp, #52]	; 0x34
 80081ca:	4f18      	ldr	r7, [pc, #96]	; (800822c <_RemoveHoles+0x98>)
 80081cc:	f813 303c 	ldrb.w	r3, [r3, ip, lsl #3]
 80081d0:	2b01      	cmp	r3, #1
 80081d2:	d121      	bne.n	8008218 <_RemoveHoles+0x84>
 80081d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 80081d6:	4620      	mov	r0, r4
 80081d8:	e88d 1008 	stmia.w	sp, {r3, ip}
 80081dc:	f7ff ff70 	bl	80080c0 <_RemoveFreeBlock>
 80081e0:	f8d8 1000 	ldr.w	r1, [r8]
 80081e4:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 80081e6:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
 80081ea:	4620      	mov	r0, r4
 80081ec:	6054      	str	r4, [r2, #4]
 80081ee:	4641      	mov	r1, r8
 80081f0:	4632      	mov	r2, r6
 80081f2:	f001 f8f2 	bl	80093da <memmove>
 80081f6:	e89d 1008 	ldmia.w	sp, {r3, ip}
 80081fa:	459c      	cmp	ip, r3
 80081fc:	d102      	bne.n	8008204 <_RemoveHoles+0x70>
 80081fe:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 8008200:	1b5b      	subs	r3, r3, r5
 8008202:	637b      	str	r3, [r7, #52]	; 0x34
 8008204:	4628      	mov	r0, r5
 8008206:	19a1      	adds	r1, r4, r6
 8008208:	f7ff ff76 	bl	80080f8 <_AddFreeMemory>
 800820c:	f1ba 0f00 	cmp.w	sl, #0
 8008210:	d001      	beq.n	8008216 <_RemoveHoles+0x82>
 8008212:	4582      	cmp	sl, r0
 8008214:	d905      	bls.n	8008222 <_RemoveHoles+0x8e>
 8008216:	4635      	mov	r5, r6
 8008218:	442c      	add	r4, r5
 800821a:	454c      	cmp	r4, r9
 800821c:	d3c4      	bcc.n	80081a8 <_RemoveHoles+0x14>
 800821e:	2001      	movs	r0, #1
 8008220:	e000      	b.n	8008224 <_RemoveHoles+0x90>
 8008222:	2000      	movs	r0, #0
 8008224:	b003      	add	sp, #12
 8008226:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800822a:	bf00      	nop
 800822c:	20022318 	.word	0x20022318

08008230 <GUI_ALLOC_FreeFixedBlock>:
 8008230:	b128      	cbz	r0, 800823e <GUI_ALLOC_FreeFixedBlock+0xe>
 8008232:	4a03      	ldr	r2, [pc, #12]	; (8008240 <GUI_ALLOC_FreeFixedBlock+0x10>)
 8008234:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8008236:	6003      	str	r3, [r0, #0]
 8008238:	b103      	cbz	r3, 800823c <GUI_ALLOC_FreeFixedBlock+0xc>
 800823a:	6058      	str	r0, [r3, #4]
 800823c:	63d0      	str	r0, [r2, #60]	; 0x3c
 800823e:	4770      	bx	lr
 8008240:	20022318 	.word	0x20022318

08008244 <GUI_ALLOC_h2p>:
 8008244:	b128      	cbz	r0, 8008252 <GUI_ALLOC_h2p+0xe>
 8008246:	4b03      	ldr	r3, [pc, #12]	; (8008254 <GUI_ALLOC_h2p+0x10>)
 8008248:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800824a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 800824e:	6840      	ldr	r0, [r0, #4]
 8008250:	3008      	adds	r0, #8
 8008252:	4770      	bx	lr
 8008254:	20022318 	.word	0x20022318

08008258 <GUI_ALLOC_LockH>:
 8008258:	4b05      	ldr	r3, [pc, #20]	; (8008270 <GUI_ALLOC_LockH+0x18>)
 800825a:	69d9      	ldr	r1, [r3, #28]
 800825c:	3101      	adds	r1, #1
 800825e:	61d9      	str	r1, [r3, #28]
 8008260:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8008262:	f813 1030 	ldrb.w	r1, [r3, r0, lsl #3]
 8008266:	3101      	adds	r1, #1
 8008268:	f803 1030 	strb.w	r1, [r3, r0, lsl #3]
 800826c:	f7ff bfea 	b.w	8008244 <GUI_ALLOC_h2p>
 8008270:	20022318 	.word	0x20022318

08008274 <GUI_ALLOC_UnlockH>:
 8008274:	b530      	push	{r4, r5, lr}
 8008276:	6802      	ldr	r2, [r0, #0]
 8008278:	4b09      	ldr	r3, [pc, #36]	; (80082a0 <GUI_ALLOC_UnlockH+0x2c>)
 800827a:	f852 1c08 	ldr.w	r1, [r2, #-8]
 800827e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8008280:	f812 4031 	ldrb.w	r4, [r2, r1, lsl #3]
 8008284:	2c01      	cmp	r4, #1
 8008286:	d903      	bls.n	8008290 <GUI_ALLOC_UnlockH+0x1c>
 8008288:	69dd      	ldr	r5, [r3, #28]
 800828a:	b10d      	cbz	r5, 8008290 <GUI_ALLOC_UnlockH+0x1c>
 800828c:	3d01      	subs	r5, #1
 800828e:	61dd      	str	r5, [r3, #28]
 8008290:	3c01      	subs	r4, #1
 8008292:	f802 4031 	strb.w	r4, [r2, r1, lsl #3]
 8008296:	2300      	movs	r3, #0
 8008298:	6003      	str	r3, [r0, #0]
 800829a:	4618      	mov	r0, r3
 800829c:	bd30      	pop	{r4, r5, pc}
 800829e:	bf00      	nop
 80082a0:	20022318 	.word	0x20022318

080082a4 <GUI_ALLOC_AssignMemory>:
 80082a4:	4b02      	ldr	r3, [pc, #8]	; (80082b0 <GUI_ALLOC_AssignMemory+0xc>)
 80082a6:	f021 0103 	bic.w	r1, r1, #3
 80082aa:	6018      	str	r0, [r3, #0]
 80082ac:	6059      	str	r1, [r3, #4]
 80082ae:	4770      	bx	lr
 80082b0:	20002088 	.word	0x20002088

080082b4 <GUI_ALLOC_Free>:
 80082b4:	b510      	push	{r4, lr}
 80082b6:	4604      	mov	r4, r0
 80082b8:	b180      	cbz	r0, 80082dc <GUI_ALLOC_Free+0x28>
 80082ba:	4b09      	ldr	r3, [pc, #36]	; (80082e0 <GUI_ALLOC_Free+0x2c>)
 80082bc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80082be:	eb03 02c0 	add.w	r2, r3, r0, lsl #3
 80082c2:	f813 3030 	ldrb.w	r3, [r3, r0, lsl #3]
 80082c6:	2b01      	cmp	r3, #1
 80082c8:	d108      	bne.n	80082dc <GUI_ALLOC_Free+0x28>
 80082ca:	6851      	ldr	r1, [r2, #4]
 80082cc:	6848      	ldr	r0, [r1, #4]
 80082ce:	f7ff ff13 	bl	80080f8 <_AddFreeMemory>
 80082d2:	4620      	mov	r0, r4
 80082d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80082d8:	f7ff bec4 	b.w	8008064 <_PushFreeBlock>
 80082dc:	bd10      	pop	{r4, pc}
 80082de:	bf00      	nop
 80082e0:	20022318 	.word	0x20022318

080082e4 <_EnlargeBlocks>:
 80082e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80082e8:	4c22      	ldr	r4, [pc, #136]	; (8008374 <_EnlargeBlocks+0x90>)
 80082ea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80082ec:	b93b      	cbnz	r3, 80082fe <_EnlargeBlocks+0x1a>
 80082ee:	4b22      	ldr	r3, [pc, #136]	; (8008378 <_EnlargeBlocks+0x94>)
 80082f0:	689d      	ldr	r5, [r3, #8]
 80082f2:	685b      	ldr	r3, [r3, #4]
 80082f4:	3508      	adds	r5, #8
 80082f6:	fbb3 f5f5 	udiv	r5, r3, r5
 80082fa:	3502      	adds	r5, #2
 80082fc:	e003      	b.n	8008306 <_EnlargeBlocks+0x22>
 80082fe:	6923      	ldr	r3, [r4, #16]
 8008300:	1d1d      	adds	r5, r3, #4
 8008302:	eb05 05d3 	add.w	r5, r5, r3, lsr #3
 8008306:	00e8      	lsls	r0, r5, #3
 8008308:	f000 f944 	bl	8008594 <_Alloc>
 800830c:	4680      	mov	r8, r0
 800830e:	b360      	cbz	r0, 800836a <_EnlargeBlocks+0x86>
 8008310:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8008312:	6922      	ldr	r2, [r4, #16]
 8008314:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 8008316:	eb01 03c0 	add.w	r3, r1, r0, lsl #3
 800831a:	00d2      	lsls	r2, r2, #3
 800831c:	685e      	ldr	r6, [r3, #4]
 800831e:	3608      	adds	r6, #8
 8008320:	4630      	mov	r0, r6
 8008322:	f001 f84f 	bl	80093c4 <memcpy>
 8008326:	6922      	ldr	r2, [r4, #16]
 8008328:	6366      	str	r6, [r4, #52]	; 0x34
 800832a:	eb06 01c2 	add.w	r1, r6, r2, lsl #3
 800832e:	f8c4 802c 	str.w	r8, [r4, #44]	; 0x2c
 8008332:	3104      	adds	r1, #4
 8008334:	4613      	mov	r3, r2
 8008336:	1e68      	subs	r0, r5, #1
 8008338:	4283      	cmp	r3, r0
 800833a:	f101 0108 	add.w	r1, r1, #8
 800833e:	d203      	bcs.n	8008348 <_EnlargeBlocks+0x64>
 8008340:	3301      	adds	r3, #1
 8008342:	f841 3c08 	str.w	r3, [r1, #-8]
 8008346:	e7f6      	b.n	8008336 <_EnlargeBlocks+0x52>
 8008348:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 800834c:	2600      	movs	r6, #0
 800834e:	605e      	str	r6, [r3, #4]
 8008350:	6863      	ldr	r3, [r4, #4]
 8008352:	6262      	str	r2, [r4, #36]	; 0x24
 8008354:	1a9b      	subs	r3, r3, r2
 8008356:	442b      	add	r3, r5
 8008358:	6063      	str	r3, [r4, #4]
 800835a:	6125      	str	r5, [r4, #16]
 800835c:	4638      	mov	r0, r7
 800835e:	b13f      	cbz	r7, 8008370 <_EnlargeBlocks+0x8c>
 8008360:	f7ff ffa8 	bl	80082b4 <GUI_ALLOC_Free>
 8008364:	4630      	mov	r0, r6
 8008366:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800836a:	2001      	movs	r0, #1
 800836c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008370:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008374:	20022318 	.word	0x20022318
 8008378:	20002088 	.word	0x20002088

0800837c <_InitOnce>:
 800837c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800837e:	4e58      	ldr	r6, [pc, #352]	; (80084e0 <_InitOnce+0x164>)
 8008380:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
 8008384:	2900      	cmp	r1, #0
 8008386:	f040 80aa 	bne.w	80084de <_InitOnce+0x162>
 800838a:	4d56      	ldr	r5, [pc, #344]	; (80084e4 <_InitOnce+0x168>)
 800838c:	686a      	ldr	r2, [r5, #4]
 800838e:	2301      	movs	r3, #1
 8008390:	f886 3028 	strb.w	r3, [r6, #40]	; 0x28
 8008394:	f5b2 5f20 	cmp.w	r2, #10240	; 0x2800
 8008398:	bf28      	it	cs
 800839a:	f44f 5220 	movcs.w	r2, #10240	; 0x2800
 800839e:	682b      	ldr	r3, [r5, #0]
 80083a0:	0894      	lsrs	r4, r2, #2
 80083a2:	2000      	movs	r0, #0
 80083a4:	42a0      	cmp	r0, r4
 80083a6:	d00c      	beq.n	80083c2 <_InitOnce+0x46>
 80083a8:	1847      	adds	r7, r0, r1
 80083aa:	f04f 0eff 	mov.w	lr, #255	; 0xff
 80083ae:	fbb7 fefe 	udiv	lr, r7, lr
 80083b2:	ebce 2e0e 	rsb	lr, lr, lr, lsl #8
 80083b6:	ebce 0707 	rsb	r7, lr, r7
 80083ba:	f843 7020 	str.w	r7, [r3, r0, lsl #2]
 80083be:	3001      	adds	r0, #1
 80083c0:	e7f0      	b.n	80083a4 <_InitOnce+0x28>
 80083c2:	2000      	movs	r0, #0
 80083c4:	42a0      	cmp	r0, r4
 80083c6:	d016      	beq.n	80083f6 <_InitOnce+0x7a>
 80083c8:	1847      	adds	r7, r0, r1
 80083ca:	f04f 0eff 	mov.w	lr, #255	; 0xff
 80083ce:	fbb7 fefe 	udiv	lr, r7, lr
 80083d2:	ebce 2e0e 	rsb	lr, lr, lr, lsl #8
 80083d6:	ebce 0e07 	rsb	lr, lr, r7
 80083da:	f853 7020 	ldr.w	r7, [r3, r0, lsl #2]
 80083de:	4577      	cmp	r7, lr
 80083e0:	d007      	beq.n	80083f2 <_InitOnce+0x76>
 80083e2:	68aa      	ldr	r2, [r5, #8]
 80083e4:	4b3f      	ldr	r3, [pc, #252]	; (80084e4 <_InitOnce+0x168>)
 80083e6:	2a00      	cmp	r2, #0
 80083e8:	d155      	bne.n	8008496 <_InitOnce+0x11a>
 80083ea:	685a      	ldr	r2, [r3, #4]
 80083ec:	0892      	lsrs	r2, r2, #2
 80083ee:	609a      	str	r2, [r3, #8]
 80083f0:	e051      	b.n	8008496 <_InitOnce+0x11a>
 80083f2:	3001      	adds	r0, #1
 80083f4:	e7e6      	b.n	80083c4 <_InitOnce+0x48>
 80083f6:	3101      	adds	r1, #1
 80083f8:	2902      	cmp	r1, #2
 80083fa:	d1d2      	bne.n	80083a2 <_InitOnce+0x26>
 80083fc:	0854      	lsrs	r4, r2, #1
 80083fe:	2100      	movs	r1, #0
 8008400:	2000      	movs	r0, #0
 8008402:	42a0      	cmp	r0, r4
 8008404:	d00c      	beq.n	8008420 <_InitOnce+0xa4>
 8008406:	1847      	adds	r7, r0, r1
 8008408:	f04f 0eff 	mov.w	lr, #255	; 0xff
 800840c:	fbb7 fefe 	udiv	lr, r7, lr
 8008410:	ebce 2e0e 	rsb	lr, lr, lr, lsl #8
 8008414:	ebce 0707 	rsb	r7, lr, r7
 8008418:	f823 7010 	strh.w	r7, [r3, r0, lsl #1]
 800841c:	3001      	adds	r0, #1
 800841e:	e7f0      	b.n	8008402 <_InitOnce+0x86>
 8008420:	2000      	movs	r0, #0
 8008422:	42a0      	cmp	r0, r4
 8008424:	d00f      	beq.n	8008446 <_InitOnce+0xca>
 8008426:	1847      	adds	r7, r0, r1
 8008428:	f04f 0eff 	mov.w	lr, #255	; 0xff
 800842c:	fbb7 fefe 	udiv	lr, r7, lr
 8008430:	ebce 2e0e 	rsb	lr, lr, lr, lsl #8
 8008434:	ebce 0707 	rsb	r7, lr, r7
 8008438:	f833 c010 	ldrh.w	ip, [r3, r0, lsl #1]
 800843c:	b2bf      	uxth	r7, r7
 800843e:	45bc      	cmp	ip, r7
 8008440:	d1cf      	bne.n	80083e2 <_InitOnce+0x66>
 8008442:	3001      	adds	r0, #1
 8008444:	e7ed      	b.n	8008422 <_InitOnce+0xa6>
 8008446:	3101      	adds	r1, #1
 8008448:	2902      	cmp	r1, #2
 800844a:	d1d9      	bne.n	8008400 <_InitOnce+0x84>
 800844c:	2100      	movs	r1, #0
 800844e:	2000      	movs	r0, #0
 8008450:	4290      	cmp	r0, r2
 8008452:	d007      	beq.n	8008464 <_InitOnce+0xe8>
 8008454:	1844      	adds	r4, r0, r1
 8008456:	27ff      	movs	r7, #255	; 0xff
 8008458:	fbb4 f7f7 	udiv	r7, r4, r7
 800845c:	443c      	add	r4, r7
 800845e:	541c      	strb	r4, [r3, r0]
 8008460:	3001      	adds	r0, #1
 8008462:	e7f5      	b.n	8008450 <_InitOnce+0xd4>
 8008464:	2000      	movs	r0, #0
 8008466:	4290      	cmp	r0, r2
 8008468:	d00b      	beq.n	8008482 <_InitOnce+0x106>
 800846a:	1844      	adds	r4, r0, r1
 800846c:	27ff      	movs	r7, #255	; 0xff
 800846e:	fbb4 f7f7 	udiv	r7, r4, r7
 8008472:	443c      	add	r4, r7
 8008474:	5c1f      	ldrb	r7, [r3, r0]
 8008476:	f004 04ff 	and.w	r4, r4, #255	; 0xff
 800847a:	42a7      	cmp	r7, r4
 800847c:	d1b1      	bne.n	80083e2 <_InitOnce+0x66>
 800847e:	3001      	adds	r0, #1
 8008480:	e7f1      	b.n	8008466 <_InitOnce+0xea>
 8008482:	3101      	adds	r1, #1
 8008484:	2902      	cmp	r1, #2
 8008486:	d1e2      	bne.n	800844e <_InitOnce+0xd2>
 8008488:	2100      	movs	r1, #0
 800848a:	4291      	cmp	r1, r2
 800848c:	d0a9      	beq.n	80083e2 <_InitOnce+0x66>
 800848e:	2000      	movs	r0, #0
 8008490:	5458      	strb	r0, [r3, r1]
 8008492:	3101      	adds	r1, #1
 8008494:	e7f9      	b.n	800848a <_InitOnce+0x10e>
 8008496:	4814      	ldr	r0, [pc, #80]	; (80084e8 <_InitOnce+0x16c>)
 8008498:	4b14      	ldr	r3, [pc, #80]	; (80084ec <_InitOnce+0x170>)
 800849a:	6003      	str	r3, [r0, #0]
 800849c:	f7ff face 	bl	8007a3c <GUI__RegisterExit>
 80084a0:	235a      	movs	r3, #90	; 0x5a
 80084a2:	6233      	str	r3, [r6, #32]
 80084a4:	2300      	movs	r3, #0
 80084a6:	2110      	movs	r1, #16
 80084a8:	eb06 02c3 	add.w	r2, r6, r3, lsl #3
 80084ac:	4099      	lsls	r1, r3
 80084ae:	3301      	adds	r3, #1
 80084b0:	2b10      	cmp	r3, #16
 80084b2:	4c0b      	ldr	r4, [pc, #44]	; (80084e0 <_InitOnce+0x164>)
 80084b4:	6411      	str	r1, [r2, #64]	; 0x40
 80084b6:	d1f6      	bne.n	80084a6 <_InitOnce+0x12a>
 80084b8:	6868      	ldr	r0, [r5, #4]
 80084ba:	6829      	ldr	r1, [r5, #0]
 80084bc:	63a1      	str	r1, [r4, #56]	; 0x38
 80084be:	2302      	movs	r3, #2
 80084c0:	6123      	str	r3, [r4, #16]
 80084c2:	f1a0 0314 	sub.w	r3, r0, #20
 80084c6:	440b      	add	r3, r1
 80084c8:	2501      	movs	r5, #1
 80084ca:	6363      	str	r3, [r4, #52]	; 0x34
 80084cc:	60e0      	str	r0, [r4, #12]
 80084ce:	605d      	str	r5, [r3, #4]
 80084d0:	6265      	str	r5, [r4, #36]	; 0x24
 80084d2:	6065      	str	r5, [r4, #4]
 80084d4:	f7ff fe10 	bl	80080f8 <_AddFreeMemory>
 80084d8:	f7ff ff04 	bl	80082e4 <_EnlargeBlocks>
 80084dc:	6325      	str	r5, [r4, #48]	; 0x30
 80084de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80084e0:	20022318 	.word	0x20022318
 80084e4:	20002088 	.word	0x20002088
 80084e8:	20002094 	.word	0x20002094
 80084ec:	08008089 	.word	0x08008089

080084f0 <GUI_ALLOC_GetFixedBlock>:
 80084f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80084f4:	4605      	mov	r5, r0
 80084f6:	4e26      	ldr	r6, [pc, #152]	; (8008590 <GUI_ALLOC_GetFixedBlock+0xa0>)
 80084f8:	3503      	adds	r5, #3
 80084fa:	f7ff ff3f 	bl	800837c <_InitOnce>
 80084fe:	f025 0503 	bic.w	r5, r5, #3
 8008502:	6c33      	ldr	r3, [r6, #64]	; 0x40
 8008504:	6bf2      	ldr	r2, [r6, #60]	; 0x3c
 8008506:	3504      	adds	r5, #4
 8008508:	429d      	cmp	r5, r3
 800850a:	bf38      	it	cc
 800850c:	461d      	movcc	r5, r3
 800850e:	4614      	mov	r4, r2
 8008510:	b12c      	cbz	r4, 800851e <GUI_ALLOC_GetFixedBlock+0x2e>
 8008512:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8008516:	42ab      	cmp	r3, r5
 8008518:	d02c      	beq.n	8008574 <GUI_ALLOC_GetFixedBlock+0x84>
 800851a:	6824      	ldr	r4, [r4, #0]
 800851c:	e7f8      	b.n	8008510 <GUI_ALLOC_GetFixedBlock+0x20>
 800851e:	68f3      	ldr	r3, [r6, #12]
 8008520:	6bb2      	ldr	r2, [r6, #56]	; 0x38
 8008522:	eb02 0803 	add.w	r8, r2, r3
 8008526:	f858 7c04 	ldr.w	r7, [r8, #-4]
 800852a:	ebc7 0708 	rsb	r7, r7, r8
 800852e:	683b      	ldr	r3, [r7, #0]
 8008530:	b133      	cbz	r3, 8008540 <GUI_ALLOC_GetFixedBlock+0x50>
 8008532:	4620      	mov	r0, r4
 8008534:	f7ff fe2e 	bl	8008194 <_RemoveHoles>
 8008538:	f858 7c04 	ldr.w	r7, [r8, #-4]
 800853c:	ebc7 0708 	rsb	r7, r7, r8
 8008540:	683b      	ldr	r3, [r7, #0]
 8008542:	bb13      	cbnz	r3, 800858a <GUI_ALLOC_GetFixedBlock+0x9a>
 8008544:	687b      	ldr	r3, [r7, #4]
 8008546:	42ab      	cmp	r3, r5
 8008548:	db1f      	blt.n	800858a <GUI_ALLOC_GetFixedBlock+0x9a>
 800854a:	4638      	mov	r0, r7
 800854c:	1d1c      	adds	r4, r3, #4
 800854e:	f7ff fdb7 	bl	80080c0 <_RemoveFreeBlock>
 8008552:	68f3      	ldr	r3, [r6, #12]
 8008554:	6878      	ldr	r0, [r7, #4]
 8008556:	1b5b      	subs	r3, r3, r5
 8008558:	60f3      	str	r3, [r6, #12]
 800855a:	6973      	ldr	r3, [r6, #20]
 800855c:	1b64      	subs	r4, r4, r5
 800855e:	442b      	add	r3, r5
 8008560:	1b40      	subs	r0, r0, r5
 8008562:	443c      	add	r4, r7
 8008564:	6173      	str	r3, [r6, #20]
 8008566:	d002      	beq.n	800856e <GUI_ALLOC_GetFixedBlock+0x7e>
 8008568:	4639      	mov	r1, r7
 800856a:	f7ff fdc5 	bl	80080f8 <_AddFreeMemory>
 800856e:	f844 5c04 	str.w	r5, [r4, #-4]
 8008572:	e00a      	b.n	800858a <GUI_ALLOC_GetFixedBlock+0x9a>
 8008574:	6823      	ldr	r3, [r4, #0]
 8008576:	b10b      	cbz	r3, 800857c <GUI_ALLOC_GetFixedBlock+0x8c>
 8008578:	6861      	ldr	r1, [r4, #4]
 800857a:	6059      	str	r1, [r3, #4]
 800857c:	6861      	ldr	r1, [r4, #4]
 800857e:	b101      	cbz	r1, 8008582 <GUI_ALLOC_GetFixedBlock+0x92>
 8008580:	600b      	str	r3, [r1, #0]
 8008582:	42a2      	cmp	r2, r4
 8008584:	d101      	bne.n	800858a <GUI_ALLOC_GetFixedBlock+0x9a>
 8008586:	6823      	ldr	r3, [r4, #0]
 8008588:	63f3      	str	r3, [r6, #60]	; 0x3c
 800858a:	4620      	mov	r0, r4
 800858c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8008590:	20022318 	.word	0x20022318

08008594 <_Alloc>:
 8008594:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008598:	4d3a      	ldr	r5, [pc, #232]	; (8008684 <_Alloc+0xf0>)
 800859a:	4604      	mov	r4, r0
 800859c:	f7ff feee 	bl	800837c <_InitOnce>
 80085a0:	6c2f      	ldr	r7, [r5, #64]	; 0x40
 80085a2:	682b      	ldr	r3, [r5, #0]
 80085a4:	42bc      	cmp	r4, r7
 80085a6:	bf24      	itt	cs
 80085a8:	1ce7      	addcs	r7, r4, #3
 80085aa:	f027 0703 	biccs.w	r7, r7, #3
 80085ae:	370c      	adds	r7, #12
 80085b0:	429f      	cmp	r7, r3
 80085b2:	4c34      	ldr	r4, [pc, #208]	; (8008684 <_Alloc+0xf0>)
 80085b4:	d842      	bhi.n	800863c <_Alloc+0xa8>
 80085b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80085b8:	6862      	ldr	r2, [r4, #4]
 80085ba:	429a      	cmp	r2, r3
 80085bc:	d90f      	bls.n	80085de <_Alloc+0x4a>
 80085be:	686b      	ldr	r3, [r5, #4]
 80085c0:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 80085c2:	3b01      	subs	r3, #1
 80085c4:	606b      	str	r3, [r5, #4]
 80085c6:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 80085c8:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 80085cc:	eb03 0209 	add.w	r2, r3, r9
 80085d0:	6852      	ldr	r2, [r2, #4]
 80085d2:	626a      	str	r2, [r5, #36]	; 0x24
 80085d4:	2201      	movs	r2, #1
 80085d6:	f803 2036 	strb.w	r2, [r3, r6, lsl #3]
 80085da:	b956      	cbnz	r6, 80085f2 <_Alloc+0x5e>
 80085dc:	e02e      	b.n	800863c <_Alloc+0xa8>
 80085de:	3b01      	subs	r3, #1
 80085e0:	6323      	str	r3, [r4, #48]	; 0x30
 80085e2:	f7ff fe7f 	bl	80082e4 <_EnlargeBlocks>
 80085e6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80085e8:	3301      	adds	r3, #1
 80085ea:	6323      	str	r3, [r4, #48]	; 0x30
 80085ec:	2800      	cmp	r0, #0
 80085ee:	d0e6      	beq.n	80085be <_Alloc+0x2a>
 80085f0:	e024      	b.n	800863c <_Alloc+0xa8>
 80085f2:	230f      	movs	r3, #15
 80085f4:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
 80085f8:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80085fa:	4297      	cmp	r7, r2
 80085fc:	d208      	bcs.n	8008610 <_Alloc+0x7c>
 80085fe:	f113 33ff 	adds.w	r3, r3, #4294967295
 8008602:	d2f7      	bcs.n	80085f4 <_Alloc+0x60>
 8008604:	e004      	b.n	8008610 <_Alloc+0x7c>
 8008606:	eb05 02c3 	add.w	r2, r5, r3, lsl #3
 800860a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800860c:	b91a      	cbnz	r2, 8008616 <_Alloc+0x82>
 800860e:	3301      	adds	r3, #1
 8008610:	2b0f      	cmp	r3, #15
 8008612:	d9f8      	bls.n	8008606 <_Alloc+0x72>
 8008614:	e00a      	b.n	800862c <_Alloc+0x98>
 8008616:	6894      	ldr	r4, [r2, #8]
 8008618:	2c00      	cmp	r4, #0
 800861a:	d0f8      	beq.n	800860e <_Alloc+0x7a>
 800861c:	6862      	ldr	r2, [r4, #4]
 800861e:	4297      	cmp	r7, r2
 8008620:	d90f      	bls.n	8008642 <_Alloc+0xae>
 8008622:	68a2      	ldr	r2, [r4, #8]
 8008624:	2a00      	cmp	r2, #0
 8008626:	d0f2      	beq.n	800860e <_Alloc+0x7a>
 8008628:	6894      	ldr	r4, [r2, #8]
 800862a:	e7f7      	b.n	800861c <_Alloc+0x88>
 800862c:	4638      	mov	r0, r7
 800862e:	f7ff fdb1 	bl	8008194 <_RemoveHoles>
 8008632:	2800      	cmp	r0, #0
 8008634:	d0dd      	beq.n	80085f2 <_Alloc+0x5e>
 8008636:	4630      	mov	r0, r6
 8008638:	f7ff fd14 	bl	8008064 <_PushFreeBlock>
 800863c:	2000      	movs	r0, #0
 800863e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008642:	f8d4 8004 	ldr.w	r8, [r4, #4]
 8008646:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8008648:	ebc7 0208 	rsb	r2, r7, r8
 800864c:	330c      	adds	r3, #12
 800864e:	4620      	mov	r0, r4
 8008650:	429a      	cmp	r2, r3
 8008652:	bf38      	it	cc
 8008654:	4647      	movcc	r7, r8
 8008656:	f7ff fd33 	bl	80080c0 <_RemoveFreeBlock>
 800865a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 800865c:	444b      	add	r3, r9
 800865e:	19e1      	adds	r1, r4, r7
 8008660:	605c      	str	r4, [r3, #4]
 8008662:	45b8      	cmp	r8, r7
 8008664:	f04f 0300 	mov.w	r3, #0
 8008668:	e884 00c0 	stmia.w	r4, {r6, r7}
 800866c:	60a3      	str	r3, [r4, #8]
 800866e:	6124      	str	r4, [r4, #16]
 8008670:	f841 7c04 	str.w	r7, [r1, #-4]
 8008674:	dd03      	ble.n	800867e <_Alloc+0xea>
 8008676:	ebc7 0008 	rsb	r0, r7, r8
 800867a:	f7ff fd3d 	bl	80080f8 <_AddFreeMemory>
 800867e:	4630      	mov	r0, r6
 8008680:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008684:	20022318 	.word	0x20022318

08008688 <GUI_ALLOC_AllocNoInit>:
 8008688:	b108      	cbz	r0, 800868e <GUI_ALLOC_AllocNoInit+0x6>
 800868a:	f7ff bf83 	b.w	8008594 <_Alloc>
 800868e:	4770      	bx	lr

08008690 <GUI_ALLOC_AllocZero>:
 8008690:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8008692:	4605      	mov	r5, r0
 8008694:	f7ff fff8 	bl	8008688 <GUI_ALLOC_AllocNoInit>
 8008698:	4606      	mov	r6, r0
 800869a:	b158      	cbz	r0, 80086b4 <GUI_ALLOC_AllocZero+0x24>
 800869c:	f7ff fddc 	bl	8008258 <GUI_ALLOC_LockH>
 80086a0:	ac02      	add	r4, sp, #8
 80086a2:	2100      	movs	r1, #0
 80086a4:	f844 0d04 	str.w	r0, [r4, #-4]!
 80086a8:	462a      	mov	r2, r5
 80086aa:	f7fe fc45 	bl	8006f38 <GUI__memset>
 80086ae:	4620      	mov	r0, r4
 80086b0:	f7ff fde0 	bl	8008274 <GUI_ALLOC_UnlockH>
 80086b4:	4630      	mov	r0, r6
 80086b6:	b002      	add	sp, #8
 80086b8:	bd70      	pop	{r4, r5, r6, pc}

080086ba <LCD_Index2Color_888>:
 80086ba:	4770      	bx	lr

080086bc <LCD_Index2Color_8888>:
 80086bc:	4770      	bx	lr

080086be <_Color2Index_M8888I>:
 80086be:	43c3      	mvns	r3, r0
 80086c0:	f3c0 4207 	ubfx	r2, r0, #16, #8
 80086c4:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 80086c8:	4313      	orrs	r3, r2
 80086ca:	b2c2      	uxtb	r2, r0
 80086cc:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80086d0:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 80086d4:	4318      	orrs	r0, r3
 80086d6:	4770      	bx	lr

080086d8 <_Index2Color_M8888I>:
 80086d8:	43c3      	mvns	r3, r0
 80086da:	f3c0 4207 	ubfx	r2, r0, #16, #8
 80086de:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 80086e2:	4313      	orrs	r3, r2
 80086e4:	b2c2      	uxtb	r2, r0
 80086e6:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 80086ea:	f400 407f 	and.w	r0, r0, #65280	; 0xff00
 80086ee:	4318      	orrs	r0, r3
 80086f0:	4770      	bx	lr

080086f2 <_GetIndexMask_M8888I>:
 80086f2:	f04f 30ff 	mov.w	r0, #4294967295
 80086f6:	4770      	bx	lr

080086f8 <_Color2IndexBulk_M8888I>:
 80086f8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80086fa:	4c0e      	ldr	r4, [pc, #56]	; (8008734 <_Color2IndexBulk_M8888I+0x3c>)
 80086fc:	6824      	ldr	r4, [r4, #0]
 80086fe:	4607      	mov	r7, r0
 8008700:	460e      	mov	r6, r1
 8008702:	4615      	mov	r5, r2
 8008704:	469c      	mov	ip, r3
 8008706:	b10c      	cbz	r4, 800870c <_Color2IndexBulk_M8888I+0x14>
 8008708:	47a0      	blx	r4
 800870a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800870c:	f857 4b04 	ldr.w	r4, [r7], #4
 8008710:	43e3      	mvns	r3, r4
 8008712:	f3c4 4207 	ubfx	r2, r4, #16, #8
 8008716:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 800871a:	4313      	orrs	r3, r2
 800871c:	b2e2      	uxtb	r2, r4
 800871e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008722:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
 8008726:	431c      	orrs	r4, r3
 8008728:	3d01      	subs	r5, #1
 800872a:	6034      	str	r4, [r6, #0]
 800872c:	4466      	add	r6, ip
 800872e:	d1ed      	bne.n	800870c <_Color2IndexBulk_M8888I+0x14>
 8008730:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008732:	bf00      	nop
 8008734:	200020a0 	.word	0x200020a0

08008738 <_Index2ColorBulk_M8888I>:
 8008738:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800873a:	4c0e      	ldr	r4, [pc, #56]	; (8008774 <_Index2ColorBulk_M8888I+0x3c>)
 800873c:	6824      	ldr	r4, [r4, #0]
 800873e:	4606      	mov	r6, r0
 8008740:	460f      	mov	r7, r1
 8008742:	4615      	mov	r5, r2
 8008744:	469c      	mov	ip, r3
 8008746:	b10c      	cbz	r4, 800874c <_Index2ColorBulk_M8888I+0x14>
 8008748:	47a0      	blx	r4
 800874a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800874c:	6834      	ldr	r4, [r6, #0]
 800874e:	43e3      	mvns	r3, r4
 8008750:	f3c4 4207 	ubfx	r2, r4, #16, #8
 8008754:	f003 437f 	and.w	r3, r3, #4278190080	; 0xff000000
 8008758:	4313      	orrs	r3, r2
 800875a:	b2e2      	uxtb	r2, r4
 800875c:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
 8008760:	f404 447f 	and.w	r4, r4, #65280	; 0xff00
 8008764:	431c      	orrs	r4, r3
 8008766:	3d01      	subs	r5, #1
 8008768:	f847 4b04 	str.w	r4, [r7], #4
 800876c:	4466      	add	r6, ip
 800876e:	d1ed      	bne.n	800874c <_Index2ColorBulk_M8888I+0x14>
 8008770:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8008772:	bf00      	nop
 8008774:	2000209c 	.word	0x2000209c

08008778 <WM__SendMessage>:
 8008778:	b570      	push	{r4, r5, r6, lr}
 800877a:	4c0d      	ldr	r4, [pc, #52]	; (80087b0 <WM__SendMessage+0x38>)
 800877c:	6823      	ldr	r3, [r4, #0]
 800877e:	2b13      	cmp	r3, #19
 8008780:	4606      	mov	r6, r0
 8008782:	460d      	mov	r5, r1
 8008784:	dc12      	bgt.n	80087ac <WM__SendMessage+0x34>
 8008786:	f7ff fd5d 	bl	8008244 <GUI_ALLOC_h2p>
 800878a:	6903      	ldr	r3, [r0, #16]
 800878c:	606e      	str	r6, [r5, #4]
 800878e:	b143      	cbz	r3, 80087a2 <WM__SendMessage+0x2a>
 8008790:	6822      	ldr	r2, [r4, #0]
 8008792:	4628      	mov	r0, r5
 8008794:	3201      	adds	r2, #1
 8008796:	6022      	str	r2, [r4, #0]
 8008798:	4798      	blx	r3
 800879a:	6823      	ldr	r3, [r4, #0]
 800879c:	3b01      	subs	r3, #1
 800879e:	6023      	str	r3, [r4, #0]
 80087a0:	bd70      	pop	{r4, r5, r6, pc}
 80087a2:	4628      	mov	r0, r5
 80087a4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80087a8:	f7fc bcbe 	b.w	8005128 <WM_DefaultProc>
 80087ac:	bd70      	pop	{r4, r5, r6, pc}
 80087ae:	bf00      	nop
 80087b0:	200020a4 	.word	0x200020a4

080087b4 <WM_SendToParent>:
 80087b4:	b538      	push	{r3, r4, r5, lr}
 80087b6:	4605      	mov	r5, r0
 80087b8:	460c      	mov	r4, r1
 80087ba:	b141      	cbz	r1, 80087ce <WM_SendToParent+0x1a>
 80087bc:	f000 f808 	bl	80087d0 <WM_GetParent>
 80087c0:	b128      	cbz	r0, 80087ce <WM_SendToParent+0x1a>
 80087c2:	60a5      	str	r5, [r4, #8]
 80087c4:	4621      	mov	r1, r4
 80087c6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80087ca:	f7ff bfd5 	b.w	8008778 <WM__SendMessage>
 80087ce:	bd38      	pop	{r3, r4, r5, pc}

080087d0 <WM_GetParent>:
 80087d0:	b508      	push	{r3, lr}
 80087d2:	4603      	mov	r3, r0
 80087d4:	b110      	cbz	r0, 80087dc <WM_GetParent+0xc>
 80087d6:	f7ff fd35 	bl	8008244 <GUI_ALLOC_h2p>
 80087da:	6983      	ldr	r3, [r0, #24]
 80087dc:	4618      	mov	r0, r3
 80087de:	bd08      	pop	{r3, pc}

080087e0 <WM_GetFirstChild>:
 80087e0:	b508      	push	{r3, lr}
 80087e2:	4603      	mov	r3, r0
 80087e4:	b110      	cbz	r0, 80087ec <WM_GetFirstChild+0xc>
 80087e6:	f7ff fd2d 	bl	8008244 <GUI_ALLOC_h2p>
 80087ea:	69c3      	ldr	r3, [r0, #28]
 80087ec:	4618      	mov	r0, r3
 80087ee:	bd08      	pop	{r3, pc}

080087f0 <WM_GetDesktopWindow>:
 80087f0:	4b03      	ldr	r3, [pc, #12]	; (8008800 <WM_GetDesktopWindow+0x10>)
 80087f2:	681b      	ldr	r3, [r3, #0]
 80087f4:	7c5a      	ldrb	r2, [r3, #17]
 80087f6:	4b03      	ldr	r3, [pc, #12]	; (8008804 <WM_GetDesktopWindow+0x14>)
 80087f8:	f853 0022 	ldr.w	r0, [r3, r2, lsl #2]
 80087fc:	4770      	bx	lr
 80087fe:	bf00      	nop
 8008800:	20000060 	.word	0x20000060
 8008804:	20022290 	.word	0x20022290

08008808 <WM__GetClientRectEx>:
 8008808:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800880a:	460d      	mov	r5, r1
 800880c:	b158      	cbz	r0, 8008826 <WM__GetClientRectEx+0x1e>
 800880e:	b151      	cbz	r1, 8008826 <WM__GetClientRectEx+0x1e>
 8008810:	f7ff fd22 	bl	8008258 <GUI_ALLOC_LockH>
 8008814:	ac02      	add	r4, sp, #8
 8008816:	4629      	mov	r1, r5
 8008818:	f844 0d04 	str.w	r0, [r4, #-4]!
 800881c:	f7fc fa09 	bl	8004c32 <WM__GetClientRectWin>
 8008820:	4620      	mov	r0, r4
 8008822:	f7ff fd27 	bl	8008274 <GUI_ALLOC_UnlockH>
 8008826:	b003      	add	sp, #12
 8008828:	bd30      	pop	{r4, r5, pc}
	...

0800882c <WM__AddCriticalHandle>:
 800882c:	4b02      	ldr	r3, [pc, #8]	; (8008838 <WM__AddCriticalHandle+0xc>)
 800882e:	681a      	ldr	r2, [r3, #0]
 8008830:	6002      	str	r2, [r0, #0]
 8008832:	6018      	str	r0, [r3, #0]
 8008834:	4770      	bx	lr
 8008836:	bf00      	nop
 8008838:	200222c4 	.word	0x200222c4

0800883c <WM_BringToBottom>:
 800883c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008840:	4604      	mov	r4, r0
 8008842:	b087      	sub	sp, #28
 8008844:	2800      	cmp	r0, #0
 8008846:	d039      	beq.n	80088bc <WM_BringToBottom+0x80>
 8008848:	f7ff fd06 	bl	8008258 <GUI_ALLOC_LockH>
 800884c:	4603      	mov	r3, r0
 800884e:	9001      	str	r0, [sp, #4]
 8008850:	c803      	ldmia	r0, {r0, r1}
 8008852:	ad04      	add	r5, sp, #16
 8008854:	e885 0003 	stmia.w	r5, {r0, r1}
 8008858:	a801      	add	r0, sp, #4
 800885a:	6a1e      	ldr	r6, [r3, #32]
 800885c:	f8d3 9028 	ldr.w	r9, [r3, #40]	; 0x28
 8008860:	f7ff fd08 	bl	8008274 <GUI_ALLOC_UnlockH>
 8008864:	4620      	mov	r0, r4
 8008866:	f000 fd24 	bl	80092b2 <WM__GetPrevSibling>
 800886a:	4607      	mov	r7, r0
 800886c:	b330      	cbz	r0, 80088bc <WM_BringToBottom+0x80>
 800886e:	4620      	mov	r0, r4
 8008870:	f7ff ffae 	bl	80087d0 <WM_GetParent>
 8008874:	f019 0f02 	tst.w	r9, #2
 8008878:	4680      	mov	r8, r0
 800887a:	d004      	beq.n	8008886 <WM_BringToBottom+0x4a>
 800887c:	4628      	mov	r0, r5
 800887e:	4641      	mov	r1, r8
 8008880:	4632      	mov	r2, r6
 8008882:	f7fc f9c8 	bl	8004c16 <WM__InvalidateRectEx>
 8008886:	4620      	mov	r0, r4
 8008888:	f7ff fce6 	bl	8008258 <GUI_ALLOC_LockH>
 800888c:	9001      	str	r0, [sp, #4]
 800888e:	4640      	mov	r0, r8
 8008890:	f7ff fce2 	bl	8008258 <GUI_ALLOC_LockH>
 8008894:	9003      	str	r0, [sp, #12]
 8008896:	4638      	mov	r0, r7
 8008898:	f7ff fcde 	bl	8008258 <GUI_ALLOC_LockH>
 800889c:	9b03      	ldr	r3, [sp, #12]
 800889e:	9a01      	ldr	r2, [sp, #4]
 80088a0:	69d9      	ldr	r1, [r3, #28]
 80088a2:	6206      	str	r6, [r0, #32]
 80088a4:	9002      	str	r0, [sp, #8]
 80088a6:	6211      	str	r1, [r2, #32]
 80088a8:	a801      	add	r0, sp, #4
 80088aa:	61dc      	str	r4, [r3, #28]
 80088ac:	f7ff fce2 	bl	8008274 <GUI_ALLOC_UnlockH>
 80088b0:	a803      	add	r0, sp, #12
 80088b2:	f7ff fcdf 	bl	8008274 <GUI_ALLOC_UnlockH>
 80088b6:	a802      	add	r0, sp, #8
 80088b8:	f7ff fcdc 	bl	8008274 <GUI_ALLOC_UnlockH>
 80088bc:	b007      	add	sp, #28
 80088be:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	...

080088c4 <GUI_MEMDEV__WriteToActiveAlpha>:
 80088c4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80088c8:	b091      	sub	sp, #68	; 0x44
 80088ca:	460e      	mov	r6, r1
 80088cc:	4614      	mov	r4, r2
 80088ce:	900d      	str	r0, [sp, #52]	; 0x34
 80088d0:	f7ff fcc2 	bl	8008258 <GUI_ALLOC_LockH>
 80088d4:	4602      	mov	r2, r0
 80088d6:	a810      	add	r0, sp, #64	; 0x40
 80088d8:	6813      	ldr	r3, [r2, #0]
 80088da:	4d5b      	ldr	r5, [pc, #364]	; (8008a48 <GUI_MEMDEV__WriteToActiveAlpha+0x184>)
 80088dc:	691b      	ldr	r3, [r3, #16]
 80088de:	f840 2d08 	str.w	r2, [r0, #-8]!
 80088e2:	685b      	ldr	r3, [r3, #4]
 80088e4:	f8b2 b008 	ldrh.w	fp, [r2, #8]
 80088e8:	f8b2 900a 	ldrh.w	r9, [r2, #10]
 80088ec:	9309      	str	r3, [sp, #36]	; 0x24
 80088ee:	f7ff fcc1 	bl	8008274 <GUI_ALLOC_UnlockH>
 80088f2:	682b      	ldr	r3, [r5, #0]
 80088f4:	4f55      	ldr	r7, [pc, #340]	; (8008a4c <GUI_MEMDEV__WriteToActiveAlpha+0x188>)
 80088f6:	7c5b      	ldrb	r3, [r3, #17]
 80088f8:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
 80088fc:	68c3      	ldr	r3, [r0, #12]
 80088fe:	2108      	movs	r1, #8
 8008900:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8008902:	4798      	blx	r3
 8008904:	682b      	ldr	r3, [r5, #0]
 8008906:	7c5b      	ldrb	r3, [r3, #17]
 8008908:	f857 3023 	ldr.w	r3, [r7, r3, lsl #2]
 800890c:	f8d3 8010 	ldr.w	r8, [r3, #16]
 8008910:	2817      	cmp	r0, #23
 8008912:	bf88      	it	hi
 8008914:	2020      	movhi	r0, #32
 8008916:	9008      	str	r0, [sp, #32]
 8008918:	f8d8 1004 	ldr.w	r1, [r8, #4]
 800891c:	f8d8 2000 	ldr.w	r2, [r8]
 8008920:	910a      	str	r1, [sp, #40]	; 0x28
 8008922:	2000      	movs	r0, #0
 8008924:	920b      	str	r2, [sp, #44]	; 0x2c
 8008926:	f7fe fd8f 	bl	8007448 <GUI__AllocAlphaBuffer>
 800892a:	2800      	cmp	r0, #0
 800892c:	f040 8089 	bne.w	8008a42 <GUI_MEMDEV__WriteToActiveAlpha+0x17e>
 8008930:	682a      	ldr	r2, [r5, #0]
 8008932:	fa0f f78b 	sxth.w	r7, fp
 8008936:	19f5      	adds	r5, r6, r7
 8008938:	f9b2 300c 	ldrsh.w	r3, [r2, #12]
 800893c:	3d01      	subs	r5, #1
 800893e:	1aed      	subs	r5, r5, r3
 8008940:	f9b2 3008 	ldrsh.w	r3, [r2, #8]
 8008944:	2d00      	cmp	r5, #0
 8008946:	bfcc      	ite	gt
 8008948:	ebc5 0507 	rsbgt	r5, r5, r7
 800894c:	463d      	movle	r5, r7
 800894e:	42b3      	cmp	r3, r6
 8008950:	bfc3      	ittte	gt
 8008952:	ebc6 0103 	rsbgt	r1, r6, r3
 8008956:	ebc1 0505 	rsbgt	r5, r1, r5
 800895a:	461e      	movgt	r6, r3
 800895c:	2100      	movle	r1, #0
 800895e:	2d00      	cmp	r5, #0
 8008960:	dd6f      	ble.n	8008a42 <GUI_MEMDEV__WriteToActiveAlpha+0x17e>
 8008962:	fa0f f389 	sxth.w	r3, r9
 8008966:	18e0      	adds	r0, r4, r3
 8008968:	f9b2 c00e 	ldrsh.w	ip, [r2, #14]
 800896c:	f9b2 200a 	ldrsh.w	r2, [r2, #10]
 8008970:	3801      	subs	r0, #1
 8008972:	ebcc 0000 	rsb	r0, ip, r0
 8008976:	2800      	cmp	r0, #0
 8008978:	bfc8      	it	gt
 800897a:	ebc0 0303 	rsbgt	r3, r0, r3
 800897e:	4294      	cmp	r4, r2
 8008980:	bfbd      	ittte	lt
 8008982:	ebc4 0a02 	rsblt	sl, r4, r2
 8008986:	ebca 0303 	rsblt	r3, sl, r3
 800898a:	4614      	movlt	r4, r2
 800898c:	f04f 0a00 	movge.w	sl, #0
 8008990:	2b00      	cmp	r3, #0
 8008992:	dd56      	ble.n	8008a42 <GUI_MEMDEV__WriteToActiveAlpha+0x17e>
 8008994:	fb07 1a0a 	mla	sl, r7, sl, r1
 8008998:	18e3      	adds	r3, r4, r3
 800899a:	ea4f 0a8a 	mov.w	sl, sl, lsl #2
 800899e:	930c      	str	r3, [sp, #48]	; 0x30
 80089a0:	980d      	ldr	r0, [sp, #52]	; 0x34
 80089a2:	f7fc fc93 	bl	80052cc <GUI_MEMDEV_GetDataPtr>
 80089a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80089a8:	9300      	str	r3, [sp, #0]
 80089aa:	ab0f      	add	r3, sp, #60	; 0x3c
 80089ac:	eb00 020a 	add.w	r2, r0, sl
 80089b0:	9301      	str	r3, [sp, #4]
 80089b2:	4630      	mov	r0, r6
 80089b4:	4621      	mov	r1, r4
 80089b6:	462b      	mov	r3, r5
 80089b8:	f7fe fc60 	bl	800727c <GUI__DoAlphaBlending>
 80089bc:	4681      	mov	r9, r0
 80089be:	2800      	cmp	r0, #0
 80089c0:	d03f      	beq.n	8008a42 <GUI_MEMDEV__WriteToActiveAlpha+0x17e>
 80089c2:	4b23      	ldr	r3, [pc, #140]	; (8008a50 <GUI_MEMDEV__WriteToActiveAlpha+0x18c>)
 80089c4:	990a      	ldr	r1, [sp, #40]	; 0x28
 80089c6:	4299      	cmp	r1, r3
 80089c8:	d01e      	beq.n	8008a08 <GUI_MEMDEV__WriteToActiveAlpha+0x144>
 80089ca:	4629      	mov	r1, r5
 80089cc:	9a08      	ldr	r2, [sp, #32]
 80089ce:	4643      	mov	r3, r8
 80089d0:	f000 fba1 	bl	8009116 <GUI__CompactPixelIndicesEx>
 80089d4:	b9c0      	cbnz	r0, 8008a08 <GUI_MEMDEV__WriteToActiveAlpha+0x144>
 80089d6:	f8d8 c010 	ldr.w	ip, [r8, #16]
 80089da:	f1bc 0f00 	cmp.w	ip, #0
 80089de:	d006      	beq.n	80089ee <GUI_MEMDEV__WriteToActiveAlpha+0x12a>
 80089e0:	4648      	mov	r0, r9
 80089e2:	4649      	mov	r1, r9
 80089e4:	fa0f f28b 	sxth.w	r2, fp
 80089e8:	2304      	movs	r3, #4
 80089ea:	47e0      	blx	ip
 80089ec:	e00c      	b.n	8008a08 <GUI_MEMDEV__WriteToActiveAlpha+0x144>
 80089ee:	464a      	mov	r2, r9
 80089f0:	463b      	mov	r3, r7
 80089f2:	6810      	ldr	r0, [r2, #0]
 80089f4:	990b      	ldr	r1, [sp, #44]	; 0x2c
 80089f6:	9206      	str	r2, [sp, #24]
 80089f8:	9307      	str	r3, [sp, #28]
 80089fa:	4788      	blx	r1
 80089fc:	9b07      	ldr	r3, [sp, #28]
 80089fe:	9a06      	ldr	r2, [sp, #24]
 8008a00:	3b01      	subs	r3, #1
 8008a02:	f842 0b04 	str.w	r0, [r2], #4
 8008a06:	d1f4      	bne.n	80089f2 <GUI_MEMDEV__WriteToActiveAlpha+0x12e>
 8008a08:	9a08      	ldr	r2, [sp, #32]
 8008a0a:	9202      	str	r2, [sp, #8]
 8008a0c:	2301      	movs	r3, #1
 8008a0e:	2200      	movs	r2, #0
 8008a10:	f104 0c01 	add.w	ip, r4, #1
 8008a14:	9300      	str	r3, [sp, #0]
 8008a16:	9301      	str	r3, [sp, #4]
 8008a18:	9203      	str	r2, [sp, #12]
 8008a1a:	9205      	str	r2, [sp, #20]
 8008a1c:	f8cd 9010 	str.w	r9, [sp, #16]
 8008a20:	4630      	mov	r0, r6
 8008a22:	4621      	mov	r1, r4
 8008a24:	462a      	mov	r2, r5
 8008a26:	f8cd c01c 	str.w	ip, [sp, #28]
 8008a2a:	f7fe f8b9 	bl	8006ba0 <LCD_DrawBitmap>
 8008a2e:	2304      	movs	r3, #4
 8008a30:	fb1b aa03 	smlabb	sl, fp, r3, sl
 8008a34:	f8dd c01c 	ldr.w	ip, [sp, #28]
 8008a38:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8008a3a:	459c      	cmp	ip, r3
 8008a3c:	d001      	beq.n	8008a42 <GUI_MEMDEV__WriteToActiveAlpha+0x17e>
 8008a3e:	4664      	mov	r4, ip
 8008a40:	e7ae      	b.n	80089a0 <GUI_MEMDEV__WriteToActiveAlpha+0xdc>
 8008a42:	b011      	add	sp, #68	; 0x44
 8008a44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008a48:	20000060 	.word	0x20000060
 8008a4c:	20022308 	.word	0x20022308
 8008a50:	080086bd 	.word	0x080086bd

08008a54 <GUI_USAGE_DecUseCnt>:
 8008a54:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8008a56:	4605      	mov	r5, r0
 8008a58:	f7ff fbfe 	bl	8008258 <GUI_ALLOC_LockH>
 8008a5c:	4602      	mov	r2, r0
 8008a5e:	a802      	add	r0, sp, #8
 8008a60:	8994      	ldrh	r4, [r2, #12]
 8008a62:	f840 2d04 	str.w	r2, [r0, #-4]!
 8008a66:	3c01      	subs	r4, #1
 8008a68:	b2a4      	uxth	r4, r4
 8008a6a:	8194      	strh	r4, [r2, #12]
 8008a6c:	f7ff fc02 	bl	8008274 <GUI_ALLOC_UnlockH>
 8008a70:	b914      	cbnz	r4, 8008a78 <GUI_USAGE_DecUseCnt+0x24>
 8008a72:	4628      	mov	r0, r5
 8008a74:	f7ff fc1e 	bl	80082b4 <GUI_ALLOC_Free>
 8008a78:	b003      	add	sp, #12
 8008a7a:	bd30      	pop	{r4, r5, pc}

08008a7c <GUI_USAGE_AddRect>:
 8008a7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008a80:	4605      	mov	r5, r0
 8008a82:	4688      	mov	r8, r1
 8008a84:	4617      	mov	r7, r2
 8008a86:	4699      	mov	r9, r3
 8008a88:	68a8      	ldr	r0, [r5, #8]
 8008a8a:	464b      	mov	r3, r9
 8008a8c:	6846      	ldr	r6, [r0, #4]
 8008a8e:	4641      	mov	r1, r8
 8008a90:	4628      	mov	r0, r5
 8008a92:	1c54      	adds	r4, r2, #1
 8008a94:	47b0      	blx	r6
 8008a96:	9b08      	ldr	r3, [sp, #32]
 8008a98:	443b      	add	r3, r7
 8008a9a:	42a3      	cmp	r3, r4
 8008a9c:	d001      	beq.n	8008aa2 <GUI_USAGE_AddRect+0x26>
 8008a9e:	4622      	mov	r2, r4
 8008aa0:	e7f2      	b.n	8008a88 <GUI_USAGE_AddRect+0xc>
 8008aa2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	...

08008aa8 <LCD_SelectLCD>:
 8008aa8:	b510      	push	{r4, lr}
 8008aaa:	4b0d      	ldr	r3, [pc, #52]	; (8008ae0 <LCD_SelectLCD+0x38>)
 8008aac:	681a      	ldr	r2, [r3, #0]
 8008aae:	7c51      	ldrb	r1, [r2, #17]
 8008ab0:	4a0c      	ldr	r2, [pc, #48]	; (8008ae4 <LCD_SelectLCD+0x3c>)
 8008ab2:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
 8008ab6:	461c      	mov	r4, r3
 8008ab8:	b138      	cbz	r0, 8008aca <LCD_SelectLCD+0x22>
 8008aba:	68c2      	ldr	r2, [r0, #12]
 8008abc:	6813      	ldr	r3, [r2, #0]
 8008abe:	2b04      	cmp	r3, #4
 8008ac0:	d001      	beq.n	8008ac6 <LCD_SelectLCD+0x1e>
 8008ac2:	6800      	ldr	r0, [r0, #0]
 8008ac4:	e7f8      	b.n	8008ab8 <LCD_SelectLCD+0x10>
 8008ac6:	f7fe fecb 	bl	8007860 <GUI_DEVICE_Unlink>
 8008aca:	6823      	ldr	r3, [r4, #0]
 8008acc:	2200      	movs	r2, #0
 8008ace:	661a      	str	r2, [r3, #96]	; 0x60
 8008ad0:	f103 0208 	add.w	r2, r3, #8
 8008ad4:	615a      	str	r2, [r3, #20]
 8008ad6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 8008ada:	f7fe b96b 	b.w	8006db4 <LCD_SetClipRectMax>
 8008ade:	bf00      	nop
 8008ae0:	20000060 	.word	0x20000060
 8008ae4:	20022308 	.word	0x20022308

08008ae8 <LCD_ReadRectEx>:
 8008ae8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008aec:	b087      	sub	sp, #28
 8008aee:	4617      	mov	r7, r2
 8008af0:	9304      	str	r3, [sp, #16]
 8008af2:	9b11      	ldr	r3, [sp, #68]	; 0x44
 8008af4:	9c10      	ldr	r4, [sp, #64]	; 0x40
 8008af6:	68da      	ldr	r2, [r3, #12]
 8008af8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8008afa:	f8d2 8014 	ldr.w	r8, [r2, #20]
 8008afe:	4606      	mov	r6, r0
 8008b00:	460d      	mov	r5, r1
 8008b02:	b973      	cbnz	r3, 8008b22 <LCD_ReadRectEx+0x3a>
 8008b04:	4b71      	ldr	r3, [pc, #452]	; (8008ccc <LCD_ReadRectEx+0x1e4>)
 8008b06:	681b      	ldr	r3, [r3, #0]
 8008b08:	7c58      	ldrb	r0, [r3, #17]
 8008b0a:	f7fd ff83 	bl	8006a14 <GUI_GetBitsPerPixelEx>
 8008b0e:	2808      	cmp	r0, #8
 8008b10:	4682      	mov	sl, r0
 8008b12:	dd15      	ble.n	8008b40 <LCD_ReadRectEx+0x58>
 8008b14:	2810      	cmp	r0, #16
 8008b16:	bfcc      	ite	gt
 8008b18:	f04f 0904 	movgt.w	r9, #4
 8008b1c:	f04f 0902 	movle.w	r9, #2
 8008b20:	e010      	b.n	8008b44 <LCD_ReadRectEx+0x5c>
 8008b22:	a811      	add	r0, sp, #68	; 0x44
 8008b24:	2101      	movs	r1, #1
 8008b26:	4798      	blx	r3
 8008b28:	4684      	mov	ip, r0
 8008b2a:	2800      	cmp	r0, #0
 8008b2c:	d0ea      	beq.n	8008b04 <LCD_ReadRectEx+0x1c>
 8008b2e:	9b04      	ldr	r3, [sp, #16]
 8008b30:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008b32:	e88d 0018 	stmia.w	sp, {r3, r4}
 8008b36:	4631      	mov	r1, r6
 8008b38:	462a      	mov	r2, r5
 8008b3a:	463b      	mov	r3, r7
 8008b3c:	47e0      	blx	ip
 8008b3e:	e0c1      	b.n	8008cc4 <LCD_ReadRectEx+0x1dc>
 8008b40:	f04f 0901 	mov.w	r9, #1
 8008b44:	f04f 0b00 	mov.w	fp, #0
 8008b48:	9b04      	ldr	r3, [sp, #16]
 8008b4a:	429d      	cmp	r5, r3
 8008b4c:	f300 80ba 	bgt.w	8008cc4 <LCD_ReadRectEx+0x1dc>
 8008b50:	f1b9 0f02 	cmp.w	r9, #2
 8008b54:	d009      	beq.n	8008b6a <LCD_ReadRectEx+0x82>
 8008b56:	f1b9 0f04 	cmp.w	r9, #4
 8008b5a:	d004      	beq.n	8008b66 <LCD_ReadRectEx+0x7e>
 8008b5c:	f1b9 0f01 	cmp.w	r9, #1
 8008b60:	f040 80ae 	bne.w	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008b64:	e003      	b.n	8008b6e <LCD_ReadRectEx+0x86>
 8008b66:	46b4      	mov	ip, r6
 8008b68:	e09b      	b.n	8008ca2 <LCD_ReadRectEx+0x1ba>
 8008b6a:	46b4      	mov	ip, r6
 8008b6c:	e08a      	b.n	8008c84 <LCD_ReadRectEx+0x19c>
 8008b6e:	f10a 32ff 	add.w	r2, sl, #4294967295
 8008b72:	2a07      	cmp	r2, #7
 8008b74:	f200 80a4 	bhi.w	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008b78:	e8df f002 	tbb	[pc, r2]
 8008b7c:	0606080a 	.word	0x0606080a
 8008b80:	04040404 	.word	0x04040404
 8008b84:	46b4      	mov	ip, r6
 8008b86:	e066      	b.n	8008c56 <LCD_ReadRectEx+0x16e>
 8008b88:	46b4      	mov	ip, r6
 8008b8a:	e047      	b.n	8008c1c <LCD_ReadRectEx+0x134>
 8008b8c:	46b4      	mov	ip, r6
 8008b8e:	e022      	b.n	8008bd6 <LCD_ReadRectEx+0xee>
 8008b90:	46b4      	mov	ip, r6
 8008b92:	45bc      	cmp	ip, r7
 8008b94:	f300 8094 	bgt.w	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008b98:	4661      	mov	r1, ip
 8008b9a:	462a      	mov	r2, r5
 8008b9c:	f8cd c00c 	str.w	ip, [sp, #12]
 8008ba0:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008ba2:	47c0      	blx	r8
 8008ba4:	f1cb 0207 	rsb	r2, fp, #7
 8008ba8:	fa00 f202 	lsl.w	r2, r0, r2
 8008bac:	f64f 717f 	movw	r1, #65407	; 0xff7f
 8008bb0:	7820      	ldrb	r0, [r4, #0]
 8008bb2:	fa41 f10b 	asr.w	r1, r1, fp
 8008bb6:	4001      	ands	r1, r0
 8008bb8:	430a      	orrs	r2, r1
 8008bba:	7022      	strb	r2, [r4, #0]
 8008bbc:	f10b 0301 	add.w	r3, fp, #1
 8008bc0:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008bc4:	f023 0207 	bic.w	r2, r3, #7
 8008bc8:	eb04 04e3 	add.w	r4, r4, r3, asr #3
 8008bcc:	fa43 fb02 	asr.w	fp, r3, r2
 8008bd0:	f10c 0c01 	add.w	ip, ip, #1
 8008bd4:	e7dd      	b.n	8008b92 <LCD_ReadRectEx+0xaa>
 8008bd6:	45bc      	cmp	ip, r7
 8008bd8:	dc72      	bgt.n	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008bda:	4661      	mov	r1, ip
 8008bdc:	462a      	mov	r2, r5
 8008bde:	f8cd c00c 	str.w	ip, [sp, #12]
 8008be2:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008be4:	47c0      	blx	r8
 8008be6:	ea4f 024b 	mov.w	r2, fp, lsl #1
 8008bea:	f1c2 0106 	rsb	r1, r2, #6
 8008bee:	fa00 f101 	lsl.w	r1, r0, r1
 8008bf2:	f64f 703f 	movw	r0, #65343	; 0xff3f
 8008bf6:	fa40 f202 	asr.w	r2, r0, r2
 8008bfa:	7820      	ldrb	r0, [r4, #0]
 8008bfc:	4002      	ands	r2, r0
 8008bfe:	4311      	orrs	r1, r2
 8008c00:	7021      	strb	r1, [r4, #0]
 8008c02:	f10b 0301 	add.w	r3, fp, #1
 8008c06:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008c0a:	f023 0203 	bic.w	r2, r3, #3
 8008c0e:	eb04 04a3 	add.w	r4, r4, r3, asr #2
 8008c12:	fa43 fb02 	asr.w	fp, r3, r2
 8008c16:	f10c 0c01 	add.w	ip, ip, #1
 8008c1a:	e7dc      	b.n	8008bd6 <LCD_ReadRectEx+0xee>
 8008c1c:	45bc      	cmp	ip, r7
 8008c1e:	dc4f      	bgt.n	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008c20:	4661      	mov	r1, ip
 8008c22:	462a      	mov	r2, r5
 8008c24:	f8cd c00c 	str.w	ip, [sp, #12]
 8008c28:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008c2a:	47c0      	blx	r8
 8008c2c:	ea4f 028b 	mov.w	r2, fp, lsl #2
 8008c30:	f1c2 0104 	rsb	r1, r2, #4
 8008c34:	fa00 f101 	lsl.w	r1, r0, r1
 8008c38:	200f      	movs	r0, #15
 8008c3a:	fa00 f202 	lsl.w	r2, r0, r2
 8008c3e:	7820      	ldrb	r0, [r4, #0]
 8008c40:	4002      	ands	r2, r0
 8008c42:	4311      	orrs	r1, r2
 8008c44:	7021      	strb	r1, [r4, #0]
 8008c46:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008c4a:	445c      	add	r4, fp
 8008c4c:	f10c 0c01 	add.w	ip, ip, #1
 8008c50:	f08b 0b01 	eor.w	fp, fp, #1
 8008c54:	e7e2      	b.n	8008c1c <LCD_ReadRectEx+0x134>
 8008c56:	4273      	negs	r3, r6
 8008c58:	1ba2      	subs	r2, r4, r6
 8008c5a:	45bc      	cmp	ip, r7
 8008c5c:	9305      	str	r3, [sp, #20]
 8008c5e:	4462      	add	r2, ip
 8008c60:	dc0e      	bgt.n	8008c80 <LCD_ReadRectEx+0x198>
 8008c62:	4661      	mov	r1, ip
 8008c64:	462a      	mov	r2, r5
 8008c66:	f8cd c00c 	str.w	ip, [sp, #12]
 8008c6a:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008c6c:	47c0      	blx	r8
 8008c6e:	9a05      	ldr	r2, [sp, #20]
 8008c70:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008c74:	4422      	add	r2, r4
 8008c76:	f802 000c 	strb.w	r0, [r2, ip]
 8008c7a:	f10c 0c01 	add.w	ip, ip, #1
 8008c7e:	e7ea      	b.n	8008c56 <LCD_ReadRectEx+0x16e>
 8008c80:	4614      	mov	r4, r2
 8008c82:	e01d      	b.n	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008c84:	45bc      	cmp	ip, r7
 8008c86:	dc1b      	bgt.n	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008c88:	4661      	mov	r1, ip
 8008c8a:	f8cd c00c 	str.w	ip, [sp, #12]
 8008c8e:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008c90:	462a      	mov	r2, r5
 8008c92:	47c0      	blx	r8
 8008c94:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008c98:	f824 0b02 	strh.w	r0, [r4], #2
 8008c9c:	f10c 0c01 	add.w	ip, ip, #1
 8008ca0:	e7f0      	b.n	8008c84 <LCD_ReadRectEx+0x19c>
 8008ca2:	45bc      	cmp	ip, r7
 8008ca4:	dc0c      	bgt.n	8008cc0 <LCD_ReadRectEx+0x1d8>
 8008ca6:	4661      	mov	r1, ip
 8008ca8:	f8cd c00c 	str.w	ip, [sp, #12]
 8008cac:	9811      	ldr	r0, [sp, #68]	; 0x44
 8008cae:	462a      	mov	r2, r5
 8008cb0:	47c0      	blx	r8
 8008cb2:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8008cb6:	f844 0b04 	str.w	r0, [r4], #4
 8008cba:	f10c 0c01 	add.w	ip, ip, #1
 8008cbe:	e7f0      	b.n	8008ca2 <LCD_ReadRectEx+0x1ba>
 8008cc0:	3501      	adds	r5, #1
 8008cc2:	e741      	b.n	8008b48 <LCD_ReadRectEx+0x60>
 8008cc4:	b007      	add	sp, #28
 8008cc6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008cca:	bf00      	nop
 8008ccc:	20000060 	.word	0x20000060

08008cd0 <GUI_ReadRectEx>:
 8008cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8008cd2:	4d16      	ldr	r5, [pc, #88]	; (8008d2c <GUI_ReadRectEx+0x5c>)
 8008cd4:	9e05      	ldr	r6, [sp, #20]
 8008cd6:	682d      	ldr	r5, [r5, #0]
 8008cd8:	9c06      	ldr	r4, [sp, #24]
 8008cda:	f9b5 7008 	ldrsh.w	r7, [r5, #8]
 8008cde:	42b8      	cmp	r0, r7
 8008ce0:	bfb8      	it	lt
 8008ce2:	4638      	movlt	r0, r7
 8008ce4:	f9b5 700c 	ldrsh.w	r7, [r5, #12]
 8008ce8:	42ba      	cmp	r2, r7
 8008cea:	bfa8      	it	ge
 8008cec:	463a      	movge	r2, r7
 8008cee:	4282      	cmp	r2, r0
 8008cf0:	db1b      	blt.n	8008d2a <GUI_ReadRectEx+0x5a>
 8008cf2:	f9b5 700a 	ldrsh.w	r7, [r5, #10]
 8008cf6:	f9b5 500e 	ldrsh.w	r5, [r5, #14]
 8008cfa:	42b9      	cmp	r1, r7
 8008cfc:	bfb8      	it	lt
 8008cfe:	4639      	movlt	r1, r7
 8008d00:	42ab      	cmp	r3, r5
 8008d02:	bfa8      	it	ge
 8008d04:	462b      	movge	r3, r5
 8008d06:	428b      	cmp	r3, r1
 8008d08:	db0f      	blt.n	8008d2a <GUI_ReadRectEx+0x5a>
 8008d0a:	68e5      	ldr	r5, [r4, #12]
 8008d0c:	682d      	ldr	r5, [r5, #0]
 8008d0e:	f035 0704 	bics.w	r7, r5, #4
 8008d12:	d105      	bne.n	8008d20 <GUI_ReadRectEx+0x50>
 8008d14:	9605      	str	r6, [sp, #20]
 8008d16:	9406      	str	r4, [sp, #24]
 8008d18:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8008d1c:	f7ff bee4 	b.w	8008ae8 <LCD_ReadRectEx>
 8008d20:	6825      	ldr	r5, [r4, #0]
 8008d22:	2d00      	cmp	r5, #0
 8008d24:	d0f6      	beq.n	8008d14 <GUI_ReadRectEx+0x44>
 8008d26:	462c      	mov	r4, r5
 8008d28:	e7ef      	b.n	8008d0a <GUI_ReadRectEx+0x3a>
 8008d2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008d2c:	20000060 	.word	0x20000060

08008d30 <_OnExit>:
 8008d30:	b510      	push	{r4, lr}
 8008d32:	4c03      	ldr	r4, [pc, #12]	; (8008d40 <_OnExit+0x10>)
 8008d34:	6820      	ldr	r0, [r4, #0]
 8008d36:	f7ff fa7b 	bl	8008230 <GUI_ALLOC_FreeFixedBlock>
 8008d3a:	2300      	movs	r3, #0
 8008d3c:	6023      	str	r3, [r4, #0]
 8008d3e:	bd10      	pop	{r4, pc}
 8008d40:	20022408 	.word	0x20022408

08008d44 <LCD_InitColors>:
 8008d44:	b538      	push	{r3, r4, r5, lr}
 8008d46:	4d09      	ldr	r5, [pc, #36]	; (8008d6c <LCD_InitColors+0x28>)
 8008d48:	682c      	ldr	r4, [r5, #0]
 8008d4a:	b95c      	cbnz	r4, 8008d64 <LCD_InitColors+0x20>
 8008d4c:	4b08      	ldr	r3, [pc, #32]	; (8008d70 <LCD_InitColors+0x2c>)
 8008d4e:	6818      	ldr	r0, [r3, #0]
 8008d50:	0080      	lsls	r0, r0, #2
 8008d52:	f7ff fbcd 	bl	80084f0 <GUI_ALLOC_GetFixedBlock>
 8008d56:	6028      	str	r0, [r5, #0]
 8008d58:	b130      	cbz	r0, 8008d68 <LCD_InitColors+0x24>
 8008d5a:	4806      	ldr	r0, [pc, #24]	; (8008d74 <LCD_InitColors+0x30>)
 8008d5c:	4b06      	ldr	r3, [pc, #24]	; (8008d78 <LCD_InitColors+0x34>)
 8008d5e:	6003      	str	r3, [r0, #0]
 8008d60:	f7fe fe6c 	bl	8007a3c <GUI__RegisterExit>
 8008d64:	2000      	movs	r0, #0
 8008d66:	bd38      	pop	{r3, r4, r5, pc}
 8008d68:	2001      	movs	r0, #1
 8008d6a:	bd38      	pop	{r3, r4, r5, pc}
 8008d6c:	20022408 	.word	0x20022408
 8008d70:	2000006c 	.word	0x2000006c
 8008d74:	200020a8 	.word	0x200020a8
 8008d78:	08008d31 	.word	0x08008d31

08008d7c <LCD_InitLUT>:
 8008d7c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008d80:	f000 fab3 	bl	80092ea <LCD_GetNumLayers>
 8008d84:	2400      	movs	r4, #0
 8008d86:	4680      	mov	r8, r0
 8008d88:	4544      	cmp	r4, r8
 8008d8a:	da2c      	bge.n	8008de6 <LCD_InitLUT+0x6a>
 8008d8c:	4620      	mov	r0, r4
 8008d8e:	f7fe fd2f 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8008d92:	b330      	cbz	r0, 8008de2 <LCD_InitLUT+0x66>
 8008d94:	4e15      	ldr	r6, [pc, #84]	; (8008dec <LCD_InitLUT+0x70>)
 8008d96:	6833      	ldr	r3, [r6, #0]
 8008d98:	4620      	mov	r0, r4
 8008d9a:	f893 9011 	ldrb.w	r9, [r3, #17]
 8008d9e:	745c      	strb	r4, [r3, #17]
 8008da0:	f7fd fe10 	bl	80069c4 <LCD_GetBitsPerPixelEx>
 8008da4:	2808      	cmp	r0, #8
 8008da6:	dd03      	ble.n	8008db0 <LCD_InitLUT+0x34>
 8008da8:	6833      	ldr	r3, [r6, #0]
 8008daa:	f883 9011 	strb.w	r9, [r3, #17]
 8008dae:	e018      	b.n	8008de2 <LCD_InitLUT+0x66>
 8008db0:	4b0f      	ldr	r3, [pc, #60]	; (8008df0 <LCD_InitLUT+0x74>)
 8008db2:	f853 3024 	ldr.w	r3, [r3, r4, lsl #2]
 8008db6:	691a      	ldr	r2, [r3, #16]
 8008db8:	4b0e      	ldr	r3, [pc, #56]	; (8008df4 <LCD_InitLUT+0x78>)
 8008dba:	429a      	cmp	r2, r3
 8008dbc:	d0f4      	beq.n	8008da8 <LCD_InitLUT+0x2c>
 8008dbe:	4620      	mov	r0, r4
 8008dc0:	f7fd fe03 	bl	80069ca <LCD_GetNumColorsEx>
 8008dc4:	2500      	movs	r5, #0
 8008dc6:	4682      	mov	sl, r0
 8008dc8:	4555      	cmp	r5, sl
 8008dca:	daed      	bge.n	8008da8 <LCD_InitLUT+0x2c>
 8008dcc:	b2ef      	uxtb	r7, r5
 8008dce:	4638      	mov	r0, r7
 8008dd0:	f7fe f85a 	bl	8006e88 <LCD_Index2Color>
 8008dd4:	4639      	mov	r1, r7
 8008dd6:	4602      	mov	r2, r0
 8008dd8:	4620      	mov	r0, r4
 8008dda:	f7fd fd85 	bl	80068e8 <LCD_SetLUTEntryEx>
 8008dde:	3501      	adds	r5, #1
 8008de0:	e7f2      	b.n	8008dc8 <LCD_InitLUT+0x4c>
 8008de2:	3401      	adds	r4, #1
 8008de4:	e7d0      	b.n	8008d88 <LCD_InitLUT+0xc>
 8008de6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008dea:	bf00      	nop
 8008dec:	20000060 	.word	0x20000060
 8008df0:	20022308 	.word	0x20022308
 8008df4:	0800b4a8 	.word	0x0800b4a8

08008df8 <GUI__ExpandPixelIndicesEx>:
 8008df8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8008dfc:	1e0c      	subs	r4, r1, #0
 8008dfe:	4605      	mov	r5, r0
 8008e00:	f340 80b3 	ble.w	8008f6a <GUI__ExpandPixelIndicesEx+0x172>
 8008e04:	2a08      	cmp	r2, #8
 8008e06:	685f      	ldr	r7, [r3, #4]
 8008e08:	dd04      	ble.n	8008e14 <GUI__ExpandPixelIndicesEx+0x1c>
 8008e0a:	2a10      	cmp	r2, #16
 8008e0c:	f340 8098 	ble.w	8008f40 <GUI__ExpandPixelIndicesEx+0x148>
 8008e10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008e14:	3a01      	subs	r2, #1
 8008e16:	2a07      	cmp	r2, #7
 8008e18:	f200 80a7 	bhi.w	8008f6a <GUI__ExpandPixelIndicesEx+0x172>
 8008e1c:	e8df f002 	tbb	[pc, r2]
 8008e20:	58a52d04 	.word	0x58a52d04
 8008e24:	83a5a5a5 	.word	0x83a5a5a5
 8008e28:	1e66      	subs	r6, r4, #1
 8008e2a:	10f2      	asrs	r2, r6, #3
 8008e2c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
 8008e30:	3b01      	subs	r3, #1
 8008e32:	eb05 0802 	add.w	r8, r5, r2
 8008e36:	eb05 0983 	add.w	r9, r5, r3, lsl #2
 8008e3a:	f006 0607 	and.w	r6, r6, #7
 8008e3e:	f815 a002 	ldrb.w	sl, [r5, r2]
 8008e42:	2580      	movs	r5, #128	; 0x80
 8008e44:	4135      	asrs	r5, r6
 8008e46:	f108 38ff 	add.w	r8, r8, #4294967295
 8008e4a:	b2ed      	uxtb	r5, r5
 8008e4c:	f1c6 0307 	rsb	r3, r6, #7
 8008e50:	ea0a 0005 	and.w	r0, sl, r5
 8008e54:	4118      	asrs	r0, r3
 8008e56:	47b8      	blx	r7
 8008e58:	f849 0904 	str.w	r0, [r9], #-4
 8008e5c:	b936      	cbnz	r6, 8008e6c <GUI__ExpandPixelIndicesEx+0x74>
 8008e5e:	f898 a000 	ldrb.w	sl, [r8]
 8008e62:	2501      	movs	r5, #1
 8008e64:	f108 38ff 	add.w	r8, r8, #4294967295
 8008e68:	2607      	movs	r6, #7
 8008e6a:	e002      	b.n	8008e72 <GUI__ExpandPixelIndicesEx+0x7a>
 8008e6c:	006d      	lsls	r5, r5, #1
 8008e6e:	3e01      	subs	r6, #1
 8008e70:	b2ed      	uxtb	r5, r5
 8008e72:	3c01      	subs	r4, #1
 8008e74:	d1ea      	bne.n	8008e4c <GUI__ExpandPixelIndicesEx+0x54>
 8008e76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008e7a:	1e66      	subs	r6, r4, #1
 8008e7c:	10b2      	asrs	r2, r6, #2
 8008e7e:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
 8008e82:	3b01      	subs	r3, #1
 8008e84:	f006 0603 	and.w	r6, r6, #3
 8008e88:	eb05 0802 	add.w	r8, r5, r2
 8008e8c:	eb05 0983 	add.w	r9, r5, r3, lsl #2
 8008e90:	f815 a002 	ldrb.w	sl, [r5, r2]
 8008e94:	0073      	lsls	r3, r6, #1
 8008e96:	25c0      	movs	r5, #192	; 0xc0
 8008e98:	411d      	asrs	r5, r3
 8008e9a:	f108 38ff 	add.w	r8, r8, #4294967295
 8008e9e:	b2ed      	uxtb	r5, r5
 8008ea0:	0073      	lsls	r3, r6, #1
 8008ea2:	f1c3 0306 	rsb	r3, r3, #6
 8008ea6:	ea0a 0005 	and.w	r0, sl, r5
 8008eaa:	4118      	asrs	r0, r3
 8008eac:	47b8      	blx	r7
 8008eae:	f849 0904 	str.w	r0, [r9], #-4
 8008eb2:	b936      	cbnz	r6, 8008ec2 <GUI__ExpandPixelIndicesEx+0xca>
 8008eb4:	2503      	movs	r5, #3
 8008eb6:	f898 a000 	ldrb.w	sl, [r8]
 8008eba:	462e      	mov	r6, r5
 8008ebc:	f108 38ff 	add.w	r8, r8, #4294967295
 8008ec0:	e002      	b.n	8008ec8 <GUI__ExpandPixelIndicesEx+0xd0>
 8008ec2:	00ad      	lsls	r5, r5, #2
 8008ec4:	3e01      	subs	r6, #1
 8008ec6:	b2ed      	uxtb	r5, r5
 8008ec8:	3c01      	subs	r4, #1
 8008eca:	d1e9      	bne.n	8008ea0 <GUI__ExpandPixelIndicesEx+0xa8>
 8008ecc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008ed0:	1e66      	subs	r6, r4, #1
 8008ed2:	1072      	asrs	r2, r6, #1
 8008ed4:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
 8008ed8:	3b01      	subs	r3, #1
 8008eda:	f006 0601 	and.w	r6, r6, #1
 8008ede:	eb05 0802 	add.w	r8, r5, r2
 8008ee2:	eb05 0983 	add.w	r9, r5, r3, lsl #2
 8008ee6:	f815 a002 	ldrb.w	sl, [r5, r2]
 8008eea:	00b3      	lsls	r3, r6, #2
 8008eec:	25f0      	movs	r5, #240	; 0xf0
 8008eee:	411d      	asrs	r5, r3
 8008ef0:	f108 38ff 	add.w	r8, r8, #4294967295
 8008ef4:	b2ed      	uxtb	r5, r5
 8008ef6:	00b3      	lsls	r3, r6, #2
 8008ef8:	f1c3 0304 	rsb	r3, r3, #4
 8008efc:	ea0a 0005 	and.w	r0, sl, r5
 8008f00:	4118      	asrs	r0, r3
 8008f02:	47b8      	blx	r7
 8008f04:	f849 0904 	str.w	r0, [r9], #-4
 8008f08:	b936      	cbnz	r6, 8008f18 <GUI__ExpandPixelIndicesEx+0x120>
 8008f0a:	f898 a000 	ldrb.w	sl, [r8]
 8008f0e:	250f      	movs	r5, #15
 8008f10:	f108 38ff 	add.w	r8, r8, #4294967295
 8008f14:	2601      	movs	r6, #1
 8008f16:	e002      	b.n	8008f1e <GUI__ExpandPixelIndicesEx+0x126>
 8008f18:	012d      	lsls	r5, r5, #4
 8008f1a:	b2ed      	uxtb	r5, r5
 8008f1c:	2600      	movs	r6, #0
 8008f1e:	3c01      	subs	r4, #1
 8008f20:	d1e9      	bne.n	8008ef6 <GUI__ExpandPixelIndicesEx+0xfe>
 8008f22:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008f26:	192e      	adds	r6, r5, r4
 8008f28:	eb05 0584 	add.w	r5, r5, r4, lsl #2
 8008f2c:	1b34      	subs	r4, r6, r4
 8008f2e:	f816 0d01 	ldrb.w	r0, [r6, #-1]!
 8008f32:	47b8      	blx	r7
 8008f34:	42a6      	cmp	r6, r4
 8008f36:	f845 0d04 	str.w	r0, [r5, #-4]!
 8008f3a:	d1f8      	bne.n	8008f2e <GUI__ExpandPixelIndicesEx+0x136>
 8008f3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008f40:	695e      	ldr	r6, [r3, #20]
 8008f42:	b12e      	cbz	r6, 8008f50 <GUI__ExpandPixelIndicesEx+0x158>
 8008f44:	4629      	mov	r1, r5
 8008f46:	4622      	mov	r2, r4
 8008f48:	2302      	movs	r3, #2
 8008f4a:	47b0      	blx	r6
 8008f4c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008f50:	0064      	lsls	r4, r4, #1
 8008f52:	4425      	add	r5, r4
 8008f54:	192e      	adds	r6, r5, r4
 8008f56:	1b2c      	subs	r4, r5, r4
 8008f58:	f835 0d02 	ldrh.w	r0, [r5, #-2]!
 8008f5c:	47b8      	blx	r7
 8008f5e:	42a5      	cmp	r5, r4
 8008f60:	f846 0d04 	str.w	r0, [r6, #-4]!
 8008f64:	d1f8      	bne.n	8008f58 <GUI__ExpandPixelIndicesEx+0x160>
 8008f66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8008f6a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

08008f6e <GUI__ConvertColor2Index>:
 8008f6e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8008f72:	f8dd 8020 	ldr.w	r8, [sp, #32]
 8008f76:	681e      	ldr	r6, [r3, #0]
 8008f78:	f1b8 0f00 	cmp.w	r8, #0
 8008f7c:	bf08      	it	eq
 8008f7e:	4680      	moveq	r8, r0
 8008f80:	2a08      	cmp	r2, #8
 8008f82:	4604      	mov	r4, r0
 8008f84:	460d      	mov	r5, r1
 8008f86:	dd05      	ble.n	8008f94 <GUI__ConvertColor2Index+0x26>
 8008f88:	2a10      	cmp	r2, #16
 8008f8a:	f340 80b6 	ble.w	80090fa <GUI__ConvertColor2Index+0x18c>
 8008f8e:	2000      	movs	r0, #0
 8008f90:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8008f94:	3a01      	subs	r2, #1
 8008f96:	2a07      	cmp	r2, #7
 8008f98:	f200 80a4 	bhi.w	80090e4 <GUI__ConvertColor2Index+0x176>
 8008f9c:	e8df f002 	tbb	[pc, r2]
 8008fa0:	87a26111 	.word	0x87a26111
 8008fa4:	92a2a2a2 	.word	0x92a2a2a2
 8008fa8:	69e0      	ldr	r0, [r4, #28]
 8008faa:	47b0      	blx	r6
 8008fac:	4338      	orrs	r0, r7
 8008fae:	f104 0920 	add.w	r9, r4, #32
 8008fb2:	b2c7      	uxtb	r7, r0
 8008fb4:	3d08      	subs	r5, #8
 8008fb6:	f808 7b01 	strb.w	r7, [r8], #1
 8008fba:	2d00      	cmp	r5, #0
 8008fbc:	f000 8092 	beq.w	80090e4 <GUI__ConvertColor2Index+0x176>
 8008fc0:	464c      	mov	r4, r9
 8008fc2:	6820      	ldr	r0, [r4, #0]
 8008fc4:	47b0      	blx	r6
 8008fc6:	2d01      	cmp	r5, #1
 8008fc8:	ea4f 10c0 	mov.w	r0, r0, lsl #7
 8008fcc:	b2c7      	uxtb	r7, r0
 8008fce:	f000 808c 	beq.w	80090ea <GUI__ConvertColor2Index+0x17c>
 8008fd2:	6860      	ldr	r0, [r4, #4]
 8008fd4:	47b0      	blx	r6
 8008fd6:	2d02      	cmp	r5, #2
 8008fd8:	ea47 1080 	orr.w	r0, r7, r0, lsl #6
 8008fdc:	b2c7      	uxtb	r7, r0
 8008fde:	d102      	bne.n	8008fe6 <GUI__ConvertColor2Index+0x78>
 8008fe0:	f104 0908 	add.w	r9, r4, #8
 8008fe4:	e083      	b.n	80090ee <GUI__ConvertColor2Index+0x180>
 8008fe6:	68a0      	ldr	r0, [r4, #8]
 8008fe8:	47b0      	blx	r6
 8008fea:	2d03      	cmp	r5, #3
 8008fec:	ea47 1040 	orr.w	r0, r7, r0, lsl #5
 8008ff0:	b2c7      	uxtb	r7, r0
 8008ff2:	d102      	bne.n	8008ffa <GUI__ConvertColor2Index+0x8c>
 8008ff4:	f104 090c 	add.w	r9, r4, #12
 8008ff8:	e079      	b.n	80090ee <GUI__ConvertColor2Index+0x180>
 8008ffa:	68e0      	ldr	r0, [r4, #12]
 8008ffc:	47b0      	blx	r6
 8008ffe:	2d04      	cmp	r5, #4
 8009000:	ea47 1000 	orr.w	r0, r7, r0, lsl #4
 8009004:	b2c7      	uxtb	r7, r0
 8009006:	d102      	bne.n	800900e <GUI__ConvertColor2Index+0xa0>
 8009008:	f104 0910 	add.w	r9, r4, #16
 800900c:	e06f      	b.n	80090ee <GUI__ConvertColor2Index+0x180>
 800900e:	6920      	ldr	r0, [r4, #16]
 8009010:	47b0      	blx	r6
 8009012:	2d05      	cmp	r5, #5
 8009014:	ea47 00c0 	orr.w	r0, r7, r0, lsl #3
 8009018:	b2c7      	uxtb	r7, r0
 800901a:	d102      	bne.n	8009022 <GUI__ConvertColor2Index+0xb4>
 800901c:	f104 0914 	add.w	r9, r4, #20
 8009020:	e065      	b.n	80090ee <GUI__ConvertColor2Index+0x180>
 8009022:	6960      	ldr	r0, [r4, #20]
 8009024:	47b0      	blx	r6
 8009026:	2d06      	cmp	r5, #6
 8009028:	ea47 0080 	orr.w	r0, r7, r0, lsl #2
 800902c:	b2c7      	uxtb	r7, r0
 800902e:	d102      	bne.n	8009036 <GUI__ConvertColor2Index+0xc8>
 8009030:	f104 0918 	add.w	r9, r4, #24
 8009034:	e05b      	b.n	80090ee <GUI__ConvertColor2Index+0x180>
 8009036:	69a0      	ldr	r0, [r4, #24]
 8009038:	47b0      	blx	r6
 800903a:	2d07      	cmp	r5, #7
 800903c:	ea47 0040 	orr.w	r0, r7, r0, lsl #1
 8009040:	b2c7      	uxtb	r7, r0
 8009042:	d1b1      	bne.n	8008fa8 <GUI__ConvertColor2Index+0x3a>
 8009044:	f104 091c 	add.w	r9, r4, #28
 8009048:	e051      	b.n	80090ee <GUI__ConvertColor2Index+0x180>
 800904a:	68e0      	ldr	r0, [r4, #12]
 800904c:	47b0      	blx	r6
 800904e:	4338      	orrs	r0, r7
 8009050:	f104 0910 	add.w	r9, r4, #16
 8009054:	b2c7      	uxtb	r7, r0
 8009056:	3d04      	subs	r5, #4
 8009058:	f808 7b01 	strb.w	r7, [r8], #1
 800905c:	2d00      	cmp	r5, #0
 800905e:	d041      	beq.n	80090e4 <GUI__ConvertColor2Index+0x176>
 8009060:	464c      	mov	r4, r9
 8009062:	6820      	ldr	r0, [r4, #0]
 8009064:	47b0      	blx	r6
 8009066:	2d01      	cmp	r5, #1
 8009068:	ea4f 1080 	mov.w	r0, r0, lsl #6
 800906c:	b2c7      	uxtb	r7, r0
 800906e:	d040      	beq.n	80090f2 <GUI__ConvertColor2Index+0x184>
 8009070:	6860      	ldr	r0, [r4, #4]
 8009072:	47b0      	blx	r6
 8009074:	2d02      	cmp	r5, #2
 8009076:	ea47 1000 	orr.w	r0, r7, r0, lsl #4
 800907a:	b2c7      	uxtb	r7, r0
 800907c:	d102      	bne.n	8009084 <GUI__ConvertColor2Index+0x116>
 800907e:	f104 0908 	add.w	r9, r4, #8
 8009082:	e038      	b.n	80090f6 <GUI__ConvertColor2Index+0x188>
 8009084:	68a0      	ldr	r0, [r4, #8]
 8009086:	47b0      	blx	r6
 8009088:	2d03      	cmp	r5, #3
 800908a:	ea47 0080 	orr.w	r0, r7, r0, lsl #2
 800908e:	b2c7      	uxtb	r7, r0
 8009090:	d1db      	bne.n	800904a <GUI__ConvertColor2Index+0xdc>
 8009092:	f104 090c 	add.w	r9, r4, #12
 8009096:	e02e      	b.n	80090f6 <GUI__ConvertColor2Index+0x188>
 8009098:	6860      	ldr	r0, [r4, #4]
 800909a:	47b0      	blx	r6
 800909c:	4338      	orrs	r0, r7
 800909e:	f104 0908 	add.w	r9, r4, #8
 80090a2:	b2c7      	uxtb	r7, r0
 80090a4:	3d02      	subs	r5, #2
 80090a6:	f808 7b01 	strb.w	r7, [r8], #1
 80090aa:	b1dd      	cbz	r5, 80090e4 <GUI__ConvertColor2Index+0x176>
 80090ac:	464c      	mov	r4, r9
 80090ae:	6820      	ldr	r0, [r4, #0]
 80090b0:	47b0      	blx	r6
 80090b2:	2d01      	cmp	r5, #1
 80090b4:	ea4f 1000 	mov.w	r0, r0, lsl #4
 80090b8:	b2c7      	uxtb	r7, r0
 80090ba:	d1ed      	bne.n	8009098 <GUI__ConvertColor2Index+0x12a>
 80090bc:	f104 0904 	add.w	r9, r4, #4
 80090c0:	2500      	movs	r5, #0
 80090c2:	e7f0      	b.n	80090a6 <GUI__ConvertColor2Index+0x138>
 80090c4:	691f      	ldr	r7, [r3, #16]
 80090c6:	b12f      	cbz	r7, 80090d4 <GUI__ConvertColor2Index+0x166>
 80090c8:	4620      	mov	r0, r4
 80090ca:	4641      	mov	r1, r8
 80090cc:	462a      	mov	r2, r5
 80090ce:	2301      	movs	r3, #1
 80090d0:	47b8      	blx	r7
 80090d2:	e007      	b.n	80090e4 <GUI__ConvertColor2Index+0x176>
 80090d4:	f854 0027 	ldr.w	r0, [r4, r7, lsl #2]
 80090d8:	47b0      	blx	r6
 80090da:	f808 0007 	strb.w	r0, [r8, r7]
 80090de:	3701      	adds	r7, #1
 80090e0:	42bd      	cmp	r5, r7
 80090e2:	d1f7      	bne.n	80090d4 <GUI__ConvertColor2Index+0x166>
 80090e4:	2001      	movs	r0, #1
 80090e6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80090ea:	f104 0904 	add.w	r9, r4, #4
 80090ee:	2500      	movs	r5, #0
 80090f0:	e761      	b.n	8008fb6 <GUI__ConvertColor2Index+0x48>
 80090f2:	f104 0904 	add.w	r9, r4, #4
 80090f6:	2500      	movs	r5, #0
 80090f8:	e7ae      	b.n	8009058 <GUI__ConvertColor2Index+0xea>
 80090fa:	691f      	ldr	r7, [r3, #16]
 80090fc:	b11f      	cbz	r7, 8009106 <GUI__ConvertColor2Index+0x198>
 80090fe:	4641      	mov	r1, r8
 8009100:	462a      	mov	r2, r5
 8009102:	2302      	movs	r3, #2
 8009104:	e7e4      	b.n	80090d0 <GUI__ConvertColor2Index+0x162>
 8009106:	f854 0b04 	ldr.w	r0, [r4], #4
 800910a:	47b0      	blx	r6
 800910c:	3d01      	subs	r5, #1
 800910e:	f828 0b02 	strh.w	r0, [r8], #2
 8009112:	d1f8      	bne.n	8009106 <GUI__ConvertColor2Index+0x198>
 8009114:	e7e6      	b.n	80090e4 <GUI__ConvertColor2Index+0x176>

08009116 <GUI__CompactPixelIndicesEx>:
 8009116:	b513      	push	{r0, r1, r4, lr}
 8009118:	2400      	movs	r4, #0
 800911a:	9400      	str	r4, [sp, #0]
 800911c:	f7ff ff27 	bl	8008f6e <GUI__ConvertColor2Index>
 8009120:	b002      	add	sp, #8
 8009122:	bd10      	pop	{r4, pc}

08009124 <_GetCharCode>:
 8009124:	7800      	ldrb	r0, [r0, #0]
 8009126:	4770      	bx	lr

08009128 <_GetCharSize>:
 8009128:	2001      	movs	r0, #1
 800912a:	4770      	bx	lr

0800912c <_CalcSizeOfChar>:
 800912c:	2001      	movs	r0, #1
 800912e:	4770      	bx	lr

08009130 <_Encode>:
 8009130:	7001      	strb	r1, [r0, #0]
 8009132:	2001      	movs	r0, #1
 8009134:	4770      	bx	lr
	...

08009138 <GUI_UC__GetCharCodeInc>:
 8009138:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800913a:	4e08      	ldr	r6, [pc, #32]	; (800915c <GUI_UC__GetCharCodeInc+0x24>)
 800913c:	6804      	ldr	r4, [r0, #0]
 800913e:	6833      	ldr	r3, [r6, #0]
 8009140:	4605      	mov	r5, r0
 8009142:	681b      	ldr	r3, [r3, #0]
 8009144:	4620      	mov	r0, r4
 8009146:	4798      	blx	r3
 8009148:	6833      	ldr	r3, [r6, #0]
 800914a:	4607      	mov	r7, r0
 800914c:	685b      	ldr	r3, [r3, #4]
 800914e:	4620      	mov	r0, r4
 8009150:	4798      	blx	r3
 8009152:	4420      	add	r0, r4
 8009154:	6028      	str	r0, [r5, #0]
 8009156:	4638      	mov	r0, r7
 8009158:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800915a:	bf00      	nop
 800915c:	20022300 	.word	0x20022300

08009160 <GUI_UC__NumChars2NumBytes>:
 8009160:	b570      	push	{r4, r5, r6, lr}
 8009162:	4604      	mov	r4, r0
 8009164:	460e      	mov	r6, r1
 8009166:	2500      	movs	r5, #0
 8009168:	b146      	cbz	r6, 800917c <GUI_UC__NumChars2NumBytes+0x1c>
 800916a:	4b05      	ldr	r3, [pc, #20]	; (8009180 <GUI_UC__NumChars2NumBytes+0x20>)
 800916c:	681b      	ldr	r3, [r3, #0]
 800916e:	4620      	mov	r0, r4
 8009170:	685b      	ldr	r3, [r3, #4]
 8009172:	4798      	blx	r3
 8009174:	3e01      	subs	r6, #1
 8009176:	4404      	add	r4, r0
 8009178:	4405      	add	r5, r0
 800917a:	e7f5      	b.n	8009168 <GUI_UC__NumChars2NumBytes+0x8>
 800917c:	4628      	mov	r0, r5
 800917e:	bd70      	pop	{r4, r5, r6, pc}
 8009180:	20022300 	.word	0x20022300

08009184 <GUI_SetTextAlign>:
 8009184:	4b03      	ldr	r3, [pc, #12]	; (8009194 <GUI_SetTextAlign+0x10>)
 8009186:	681b      	ldr	r3, [r3, #0]
 8009188:	f9b3 202c 	ldrsh.w	r2, [r3, #44]	; 0x2c
 800918c:	8598      	strh	r0, [r3, #44]	; 0x2c
 800918e:	4610      	mov	r0, r2
 8009190:	4770      	bx	lr
 8009192:	bf00      	nop
 8009194:	20000060 	.word	0x20000060

08009198 <GUI_SetOrg>:
 8009198:	460a      	mov	r2, r1
 800919a:	4908      	ldr	r1, [pc, #32]	; (80091bc <GUI_SetOrg+0x24>)
 800919c:	b510      	push	{r4, lr}
 800919e:	8008      	strh	r0, [r1, #0]
 80091a0:	4907      	ldr	r1, [pc, #28]	; (80091c0 <GUI_SetOrg+0x28>)
 80091a2:	800a      	strh	r2, [r1, #0]
 80091a4:	4907      	ldr	r1, [pc, #28]	; (80091c4 <GUI_SetOrg+0x2c>)
 80091a6:	6809      	ldr	r1, [r1, #0]
 80091a8:	4603      	mov	r3, r0
 80091aa:	7c48      	ldrb	r0, [r1, #17]
 80091ac:	4906      	ldr	r1, [pc, #24]	; (80091c8 <GUI_SetOrg+0x30>)
 80091ae:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 80091b2:	68c1      	ldr	r1, [r0, #12]
 80091b4:	6a0c      	ldr	r4, [r1, #32]
 80091b6:	4619      	mov	r1, r3
 80091b8:	47a0      	blx	r4
 80091ba:	bd10      	pop	{r4, pc}
 80091bc:	200222f4 	.word	0x200222f4
 80091c0:	200222e8 	.word	0x200222e8
 80091c4:	20000060 	.word	0x20000060
 80091c8:	20022308 	.word	0x20022308

080091cc <GUI_GetBkColor>:
 80091cc:	b508      	push	{r3, lr}
 80091ce:	f000 f89b 	bl	8009308 <LCD_GetBkColorIndex>
 80091d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80091d6:	f7fd be57 	b.w	8006e88 <LCD_Index2Color>

080091da <GUI_GetColor>:
 80091da:	b508      	push	{r3, lr}
 80091dc:	f000 f89c 	bl	8009318 <LCD_GetColorIndex>
 80091e0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80091e4:	f7fd be50 	b.w	8006e88 <LCD_Index2Color>

080091e8 <_GetIndexMask_0>:
 80091e8:	b508      	push	{r3, lr}
 80091ea:	f7fd fc0b 	bl	8006a04 <LCD_GetNumColors>
 80091ee:	f5b0 7f80 	cmp.w	r0, #256	; 0x100
 80091f2:	d010      	beq.n	8009216 <_GetIndexMask_0+0x2e>
 80091f4:	287f      	cmp	r0, #127	; 0x7f
 80091f6:	d810      	bhi.n	800921a <_GetIndexMask_0+0x32>
 80091f8:	283f      	cmp	r0, #63	; 0x3f
 80091fa:	d810      	bhi.n	800921e <_GetIndexMask_0+0x36>
 80091fc:	281f      	cmp	r0, #31
 80091fe:	d810      	bhi.n	8009222 <_GetIndexMask_0+0x3a>
 8009200:	280f      	cmp	r0, #15
 8009202:	d810      	bhi.n	8009226 <_GetIndexMask_0+0x3e>
 8009204:	2807      	cmp	r0, #7
 8009206:	d810      	bhi.n	800922a <_GetIndexMask_0+0x42>
 8009208:	2803      	cmp	r0, #3
 800920a:	d810      	bhi.n	800922e <_GetIndexMask_0+0x46>
 800920c:	2801      	cmp	r0, #1
 800920e:	bf94      	ite	ls
 8009210:	2000      	movls	r0, #0
 8009212:	2001      	movhi	r0, #1
 8009214:	e00c      	b.n	8009230 <_GetIndexMask_0+0x48>
 8009216:	2008      	movs	r0, #8
 8009218:	e00a      	b.n	8009230 <_GetIndexMask_0+0x48>
 800921a:	2007      	movs	r0, #7
 800921c:	e008      	b.n	8009230 <_GetIndexMask_0+0x48>
 800921e:	2006      	movs	r0, #6
 8009220:	e006      	b.n	8009230 <_GetIndexMask_0+0x48>
 8009222:	2005      	movs	r0, #5
 8009224:	e004      	b.n	8009230 <_GetIndexMask_0+0x48>
 8009226:	2004      	movs	r0, #4
 8009228:	e002      	b.n	8009230 <_GetIndexMask_0+0x48>
 800922a:	2003      	movs	r0, #3
 800922c:	e000      	b.n	8009230 <_GetIndexMask_0+0x48>
 800922e:	2002      	movs	r0, #2
 8009230:	2301      	movs	r3, #1
 8009232:	fa03 f000 	lsl.w	r0, r3, r0
 8009236:	3801      	subs	r0, #1
 8009238:	bd08      	pop	{r3, pc}

0800923a <_Index2Color_0>:
 800923a:	b538      	push	{r3, r4, r5, lr}
 800923c:	4604      	mov	r4, r0
 800923e:	f7fd fbe1 	bl	8006a04 <LCD_GetNumColors>
 8009242:	4605      	mov	r5, r0
 8009244:	f7fd fbfc 	bl	8006a40 <LCD_GetPalette>
 8009248:	42ac      	cmp	r4, r5
 800924a:	d203      	bcs.n	8009254 <_Index2Color_0+0x1a>
 800924c:	b118      	cbz	r0, 8009256 <_Index2Color_0+0x1c>
 800924e:	f850 0024 	ldr.w	r0, [r0, r4, lsl #2]
 8009252:	bd38      	pop	{r3, r4, r5, pc}
 8009254:	2000      	movs	r0, #0
 8009256:	bd38      	pop	{r3, r4, r5, pc}

08009258 <_Color2Index_0>:
 8009258:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800925c:	4681      	mov	r9, r0
 800925e:	f7fd fbd1 	bl	8006a04 <LCD_GetNumColors>
 8009262:	4680      	mov	r8, r0
 8009264:	f7fd fbec 	bl	8006a40 <LCD_GetPalette>
 8009268:	4606      	mov	r6, r0
 800926a:	b1d8      	cbz	r0, 80092a4 <_Color2Index_0+0x4c>
 800926c:	2300      	movs	r3, #0
 800926e:	f856 2023 	ldr.w	r2, [r6, r3, lsl #2]
 8009272:	4591      	cmp	r9, r2
 8009274:	d01a      	beq.n	80092ac <_Color2Index_0+0x54>
 8009276:	3301      	adds	r3, #1
 8009278:	4543      	cmp	r3, r8
 800927a:	dbf8      	blt.n	800926e <_Color2Index_0+0x16>
 800927c:	2500      	movs	r5, #0
 800927e:	f06f 477f 	mvn.w	r7, #4278190080	; 0xff000000
 8009282:	462c      	mov	r4, r5
 8009284:	f856 1024 	ldr.w	r1, [r6, r4, lsl #2]
 8009288:	4648      	mov	r0, r9
 800928a:	f000 f84d 	bl	8009328 <GUI_CalcColorDist>
 800928e:	42b8      	cmp	r0, r7
 8009290:	bf38      	it	cc
 8009292:	4625      	movcc	r5, r4
 8009294:	f104 0401 	add.w	r4, r4, #1
 8009298:	bf28      	it	cs
 800929a:	4638      	movcs	r0, r7
 800929c:	4544      	cmp	r4, r8
 800929e:	da02      	bge.n	80092a6 <_Color2Index_0+0x4e>
 80092a0:	4607      	mov	r7, r0
 80092a2:	e7ef      	b.n	8009284 <_Color2Index_0+0x2c>
 80092a4:	4605      	mov	r5, r0
 80092a6:	4628      	mov	r0, r5
 80092a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80092ac:	4618      	mov	r0, r3
 80092ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

080092b2 <WM__GetPrevSibling>:
 80092b2:	b538      	push	{r3, r4, r5, lr}
 80092b4:	4605      	mov	r5, r0
 80092b6:	f000 f80f 	bl	80092d8 <WM__GetFirstSibling>
 80092ba:	4604      	mov	r4, r0
 80092bc:	b154      	cbz	r4, 80092d4 <WM__GetPrevSibling+0x22>
 80092be:	42ac      	cmp	r4, r5
 80092c0:	d007      	beq.n	80092d2 <WM__GetPrevSibling+0x20>
 80092c2:	4620      	mov	r0, r4
 80092c4:	f7fe ffbe 	bl	8008244 <GUI_ALLOC_h2p>
 80092c8:	6a03      	ldr	r3, [r0, #32]
 80092ca:	42ab      	cmp	r3, r5
 80092cc:	d002      	beq.n	80092d4 <WM__GetPrevSibling+0x22>
 80092ce:	461c      	mov	r4, r3
 80092d0:	e7f4      	b.n	80092bc <WM__GetPrevSibling+0xa>
 80092d2:	2400      	movs	r4, #0
 80092d4:	4620      	mov	r0, r4
 80092d6:	bd38      	pop	{r3, r4, r5, pc}

080092d8 <WM__GetFirstSibling>:
 80092d8:	b508      	push	{r3, lr}
 80092da:	f7ff fa79 	bl	80087d0 <WM_GetParent>
 80092de:	b118      	cbz	r0, 80092e8 <WM__GetFirstSibling+0x10>
 80092e0:	f7fe ffb0 	bl	8008244 <GUI_ALLOC_h2p>
 80092e4:	69c0      	ldr	r0, [r0, #28]
 80092e6:	bd08      	pop	{r3, pc}
 80092e8:	bd08      	pop	{r3, pc}

080092ea <LCD_GetNumLayers>:
 80092ea:	b510      	push	{r4, lr}
 80092ec:	2000      	movs	r0, #0
 80092ee:	f7fe fa7f 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 80092f2:	1c04      	adds	r4, r0, #0
 80092f4:	f04f 0001 	mov.w	r0, #1
 80092f8:	bf18      	it	ne
 80092fa:	2401      	movne	r4, #1
 80092fc:	f7fe fa78 	bl	80077f0 <GUI_DEVICE__GetpDriver>
 8009300:	b100      	cbz	r0, 8009304 <LCD_GetNumLayers+0x1a>
 8009302:	3401      	adds	r4, #1
 8009304:	4620      	mov	r0, r4
 8009306:	bd10      	pop	{r4, pc}

08009308 <LCD_GetBkColorIndex>:
 8009308:	4b02      	ldr	r3, [pc, #8]	; (8009314 <LCD_GetBkColorIndex+0xc>)
 800930a:	681b      	ldr	r3, [r3, #0]
 800930c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800930e:	6818      	ldr	r0, [r3, #0]
 8009310:	4770      	bx	lr
 8009312:	bf00      	nop
 8009314:	20000060 	.word	0x20000060

08009318 <LCD_GetColorIndex>:
 8009318:	4b02      	ldr	r3, [pc, #8]	; (8009324 <LCD_GetColorIndex+0xc>)
 800931a:	681b      	ldr	r3, [r3, #0]
 800931c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800931e:	6818      	ldr	r0, [r3, #0]
 8009320:	4770      	bx	lr
 8009322:	bf00      	nop
 8009324:	20000060 	.word	0x20000060

08009328 <GUI_CalcColorDist>:
 8009328:	b2cb      	uxtb	r3, r1
 800932a:	b2c2      	uxtb	r2, r0
 800932c:	1ad2      	subs	r2, r2, r3
 800932e:	b292      	uxth	r2, r2
 8009330:	b293      	uxth	r3, r2
 8009332:	b530      	push	{r4, r5, lr}
 8009334:	041c      	lsls	r4, r3, #16
 8009336:	bf48      	it	mi
 8009338:	4253      	negmi	r3, r2
 800933a:	f3c1 2507 	ubfx	r5, r1, #8, #8
 800933e:	f3c0 2207 	ubfx	r2, r0, #8, #8
 8009342:	ebc5 0202 	rsb	r2, r5, r2
 8009346:	bf48      	it	mi
 8009348:	b29b      	uxthmi	r3, r3
 800934a:	b292      	uxth	r2, r2
 800934c:	0c09      	lsrs	r1, r1, #16
 800934e:	fb13 f403 	smulbb	r4, r3, r3
 8009352:	ebc1 4110 	rsb	r1, r1, r0, lsr #16
 8009356:	b293      	uxth	r3, r2
 8009358:	041d      	lsls	r5, r3, #16
 800935a:	b289      	uxth	r1, r1
 800935c:	b288      	uxth	r0, r1
 800935e:	bf44      	itt	mi
 8009360:	4253      	negmi	r3, r2
 8009362:	b29b      	uxthmi	r3, r3
 8009364:	0402      	lsls	r2, r0, #16
 8009366:	bf48      	it	mi
 8009368:	4248      	negmi	r0, r1
 800936a:	fb13 4303 	smlabb	r3, r3, r3, r4
 800936e:	bf48      	it	mi
 8009370:	b280      	uxthmi	r0, r0
 8009372:	fb00 3000 	mla	r0, r0, r0, r3
 8009376:	bd30      	pop	{r4, r5, pc}

08009378 <__libc_init_array>:
 8009378:	b570      	push	{r4, r5, r6, lr}
 800937a:	4b0e      	ldr	r3, [pc, #56]	; (80093b4 <__libc_init_array+0x3c>)
 800937c:	4c0e      	ldr	r4, [pc, #56]	; (80093b8 <__libc_init_array+0x40>)
 800937e:	1ae4      	subs	r4, r4, r3
 8009380:	10a4      	asrs	r4, r4, #2
 8009382:	2500      	movs	r5, #0
 8009384:	461e      	mov	r6, r3
 8009386:	42a5      	cmp	r5, r4
 8009388:	d004      	beq.n	8009394 <__libc_init_array+0x1c>
 800938a:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800938e:	4798      	blx	r3
 8009390:	3501      	adds	r5, #1
 8009392:	e7f8      	b.n	8009386 <__libc_init_array+0xe>
 8009394:	f000 fbda 	bl	8009b4c <_init>
 8009398:	4c08      	ldr	r4, [pc, #32]	; (80093bc <__libc_init_array+0x44>)
 800939a:	4b09      	ldr	r3, [pc, #36]	; (80093c0 <__libc_init_array+0x48>)
 800939c:	1ae4      	subs	r4, r4, r3
 800939e:	10a4      	asrs	r4, r4, #2
 80093a0:	2500      	movs	r5, #0
 80093a2:	461e      	mov	r6, r3
 80093a4:	42a5      	cmp	r5, r4
 80093a6:	d004      	beq.n	80093b2 <__libc_init_array+0x3a>
 80093a8:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80093ac:	4798      	blx	r3
 80093ae:	3501      	adds	r5, #1
 80093b0:	e7f8      	b.n	80093a4 <__libc_init_array+0x2c>
 80093b2:	bd70      	pop	{r4, r5, r6, pc}
 80093b4:	0800b4c4 	.word	0x0800b4c4
 80093b8:	0800b4c4 	.word	0x0800b4c4
 80093bc:	0800b4c8 	.word	0x0800b4c8
 80093c0:	0800b4c4 	.word	0x0800b4c4

080093c4 <memcpy>:
 80093c4:	b510      	push	{r4, lr}
 80093c6:	1e43      	subs	r3, r0, #1
 80093c8:	440a      	add	r2, r1
 80093ca:	4291      	cmp	r1, r2
 80093cc:	d004      	beq.n	80093d8 <memcpy+0x14>
 80093ce:	f811 4b01 	ldrb.w	r4, [r1], #1
 80093d2:	f803 4f01 	strb.w	r4, [r3, #1]!
 80093d6:	e7f8      	b.n	80093ca <memcpy+0x6>
 80093d8:	bd10      	pop	{r4, pc}

080093da <memmove>:
 80093da:	4288      	cmp	r0, r1
 80093dc:	b510      	push	{r4, lr}
 80093de:	eb01 0302 	add.w	r3, r1, r2
 80093e2:	d801      	bhi.n	80093e8 <memmove+0xe>
 80093e4:	1e42      	subs	r2, r0, #1
 80093e6:	e00b      	b.n	8009400 <memmove+0x26>
 80093e8:	4298      	cmp	r0, r3
 80093ea:	d2fb      	bcs.n	80093e4 <memmove+0xa>
 80093ec:	1881      	adds	r1, r0, r2
 80093ee:	1ad2      	subs	r2, r2, r3
 80093f0:	42d3      	cmn	r3, r2
 80093f2:	d004      	beq.n	80093fe <memmove+0x24>
 80093f4:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 80093f8:	f801 4d01 	strb.w	r4, [r1, #-1]!
 80093fc:	e7f8      	b.n	80093f0 <memmove+0x16>
 80093fe:	bd10      	pop	{r4, pc}
 8009400:	4299      	cmp	r1, r3
 8009402:	d004      	beq.n	800940e <memmove+0x34>
 8009404:	f811 4b01 	ldrb.w	r4, [r1], #1
 8009408:	f802 4f01 	strb.w	r4, [r2, #1]!
 800940c:	e7f8      	b.n	8009400 <memmove+0x26>
 800940e:	bd10      	pop	{r4, pc}

08009410 <memset>:
 8009410:	4402      	add	r2, r0
 8009412:	4603      	mov	r3, r0
 8009414:	4293      	cmp	r3, r2
 8009416:	d002      	beq.n	800941e <memset+0xe>
 8009418:	f803 1b01 	strb.w	r1, [r3], #1
 800941c:	e7fa      	b.n	8009414 <memset+0x4>
 800941e:	4770      	bx	lr

08009420 <rand>:
 8009420:	4b19      	ldr	r3, [pc, #100]	; (8009488 <rand+0x68>)
 8009422:	b510      	push	{r4, lr}
 8009424:	681c      	ldr	r4, [r3, #0]
 8009426:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8009428:	b9d3      	cbnz	r3, 8009460 <rand+0x40>
 800942a:	2018      	movs	r0, #24
 800942c:	f000 f832 	bl	8009494 <malloc>
 8009430:	f243 330e 	movw	r3, #13070	; 0x330e
 8009434:	63a0      	str	r0, [r4, #56]	; 0x38
 8009436:	8003      	strh	r3, [r0, #0]
 8009438:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 800943c:	8043      	strh	r3, [r0, #2]
 800943e:	f241 2334 	movw	r3, #4660	; 0x1234
 8009442:	8083      	strh	r3, [r0, #4]
 8009444:	f24e 636d 	movw	r3, #58989	; 0xe66d
 8009448:	80c3      	strh	r3, [r0, #6]
 800944a:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 800944e:	8103      	strh	r3, [r0, #8]
 8009450:	2305      	movs	r3, #5
 8009452:	8143      	strh	r3, [r0, #10]
 8009454:	230b      	movs	r3, #11
 8009456:	8183      	strh	r3, [r0, #12]
 8009458:	2201      	movs	r2, #1
 800945a:	2300      	movs	r3, #0
 800945c:	e9c0 2304 	strd	r2, r3, [r0, #16]
 8009460:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8009462:	4c0a      	ldr	r4, [pc, #40]	; (800948c <rand+0x6c>)
 8009464:	690b      	ldr	r3, [r1, #16]
 8009466:	6948      	ldr	r0, [r1, #20]
 8009468:	4a09      	ldr	r2, [pc, #36]	; (8009490 <rand+0x70>)
 800946a:	435c      	muls	r4, r3
 800946c:	fb02 4000 	mla	r0, r2, r0, r4
 8009470:	fba3 2302 	umull	r2, r3, r3, r2
 8009474:	3201      	adds	r2, #1
 8009476:	4403      	add	r3, r0
 8009478:	f143 0300 	adc.w	r3, r3, #0
 800947c:	e9c1 2304 	strd	r2, r3, [r1, #16]
 8009480:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 8009484:	bd10      	pop	{r4, pc}
 8009486:	bf00      	nop
 8009488:	20000160 	.word	0x20000160
 800948c:	5851f42d 	.word	0x5851f42d
 8009490:	4c957f2d 	.word	0x4c957f2d

08009494 <malloc>:
 8009494:	4b02      	ldr	r3, [pc, #8]	; (80094a0 <malloc+0xc>)
 8009496:	4601      	mov	r1, r0
 8009498:	6818      	ldr	r0, [r3, #0]
 800949a:	f000 b803 	b.w	80094a4 <_malloc_r>
 800949e:	bf00      	nop
 80094a0:	20000160 	.word	0x20000160

080094a4 <_malloc_r>:
 80094a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80094a8:	f101 040b 	add.w	r4, r1, #11
 80094ac:	2c16      	cmp	r4, #22
 80094ae:	b085      	sub	sp, #20
 80094b0:	4681      	mov	r9, r0
 80094b2:	d903      	bls.n	80094bc <_malloc_r+0x18>
 80094b4:	f034 0407 	bics.w	r4, r4, #7
 80094b8:	d501      	bpl.n	80094be <_malloc_r+0x1a>
 80094ba:	e002      	b.n	80094c2 <_malloc_r+0x1e>
 80094bc:	2410      	movs	r4, #16
 80094be:	428c      	cmp	r4, r1
 80094c0:	d203      	bcs.n	80094ca <_malloc_r+0x26>
 80094c2:	230c      	movs	r3, #12
 80094c4:	f8c9 3000 	str.w	r3, [r9]
 80094c8:	e1ea      	b.n	80098a0 <_malloc_r+0x3fc>
 80094ca:	4648      	mov	r0, r9
 80094cc:	f000 fa0a 	bl	80098e4 <__malloc_lock>
 80094d0:	f5b4 7ffc 	cmp.w	r4, #504	; 0x1f8
 80094d4:	4d9e      	ldr	r5, [pc, #632]	; (8009750 <_malloc_r+0x2ac>)
 80094d6:	d217      	bcs.n	8009508 <_malloc_r+0x64>
 80094d8:	f104 0208 	add.w	r2, r4, #8
 80094dc:	442a      	add	r2, r5
 80094de:	f1a2 0108 	sub.w	r1, r2, #8
 80094e2:	6856      	ldr	r6, [r2, #4]
 80094e4:	428e      	cmp	r6, r1
 80094e6:	ea4f 03d4 	mov.w	r3, r4, lsr #3
 80094ea:	d102      	bne.n	80094f2 <_malloc_r+0x4e>
 80094ec:	68d6      	ldr	r6, [r2, #12]
 80094ee:	42b2      	cmp	r2, r6
 80094f0:	d008      	beq.n	8009504 <_malloc_r+0x60>
 80094f2:	6873      	ldr	r3, [r6, #4]
 80094f4:	68f2      	ldr	r2, [r6, #12]
 80094f6:	68b1      	ldr	r1, [r6, #8]
 80094f8:	f023 0303 	bic.w	r3, r3, #3
 80094fc:	60ca      	str	r2, [r1, #12]
 80094fe:	4433      	add	r3, r6
 8009500:	6091      	str	r1, [r2, #8]
 8009502:	e02f      	b.n	8009564 <_malloc_r+0xc0>
 8009504:	3302      	adds	r3, #2
 8009506:	e03d      	b.n	8009584 <_malloc_r+0xe0>
 8009508:	0a63      	lsrs	r3, r4, #9
 800950a:	d01a      	beq.n	8009542 <_malloc_r+0x9e>
 800950c:	2b04      	cmp	r3, #4
 800950e:	d802      	bhi.n	8009516 <_malloc_r+0x72>
 8009510:	09a3      	lsrs	r3, r4, #6
 8009512:	3338      	adds	r3, #56	; 0x38
 8009514:	e018      	b.n	8009548 <_malloc_r+0xa4>
 8009516:	2b14      	cmp	r3, #20
 8009518:	d801      	bhi.n	800951e <_malloc_r+0x7a>
 800951a:	335b      	adds	r3, #91	; 0x5b
 800951c:	e014      	b.n	8009548 <_malloc_r+0xa4>
 800951e:	2b54      	cmp	r3, #84	; 0x54
 8009520:	d802      	bhi.n	8009528 <_malloc_r+0x84>
 8009522:	0b23      	lsrs	r3, r4, #12
 8009524:	336e      	adds	r3, #110	; 0x6e
 8009526:	e00f      	b.n	8009548 <_malloc_r+0xa4>
 8009528:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 800952c:	d802      	bhi.n	8009534 <_malloc_r+0x90>
 800952e:	0be3      	lsrs	r3, r4, #15
 8009530:	3377      	adds	r3, #119	; 0x77
 8009532:	e009      	b.n	8009548 <_malloc_r+0xa4>
 8009534:	f240 5254 	movw	r2, #1364	; 0x554
 8009538:	4293      	cmp	r3, r2
 800953a:	d804      	bhi.n	8009546 <_malloc_r+0xa2>
 800953c:	0ca3      	lsrs	r3, r4, #18
 800953e:	337c      	adds	r3, #124	; 0x7c
 8009540:	e002      	b.n	8009548 <_malloc_r+0xa4>
 8009542:	233f      	movs	r3, #63	; 0x3f
 8009544:	e000      	b.n	8009548 <_malloc_r+0xa4>
 8009546:	237e      	movs	r3, #126	; 0x7e
 8009548:	1c5a      	adds	r2, r3, #1
 800954a:	eb05 02c2 	add.w	r2, r5, r2, lsl #3
 800954e:	f1a2 0008 	sub.w	r0, r2, #8
 8009552:	6856      	ldr	r6, [r2, #4]
 8009554:	e00c      	b.n	8009570 <_malloc_r+0xcc>
 8009556:	2900      	cmp	r1, #0
 8009558:	68f1      	ldr	r1, [r6, #12]
 800955a:	db08      	blt.n	800956e <_malloc_r+0xca>
 800955c:	68b3      	ldr	r3, [r6, #8]
 800955e:	60d9      	str	r1, [r3, #12]
 8009560:	608b      	str	r3, [r1, #8]
 8009562:	18b3      	adds	r3, r6, r2
 8009564:	685a      	ldr	r2, [r3, #4]
 8009566:	f042 0201 	orr.w	r2, r2, #1
 800956a:	605a      	str	r2, [r3, #4]
 800956c:	e1a3      	b.n	80098b6 <_malloc_r+0x412>
 800956e:	460e      	mov	r6, r1
 8009570:	4286      	cmp	r6, r0
 8009572:	d006      	beq.n	8009582 <_malloc_r+0xde>
 8009574:	6872      	ldr	r2, [r6, #4]
 8009576:	f022 0203 	bic.w	r2, r2, #3
 800957a:	1b11      	subs	r1, r2, r4
 800957c:	290f      	cmp	r1, #15
 800957e:	ddea      	ble.n	8009556 <_malloc_r+0xb2>
 8009580:	3b01      	subs	r3, #1
 8009582:	3301      	adds	r3, #1
 8009584:	4a72      	ldr	r2, [pc, #456]	; (8009750 <_malloc_r+0x2ac>)
 8009586:	692e      	ldr	r6, [r5, #16]
 8009588:	f102 0708 	add.w	r7, r2, #8
 800958c:	42be      	cmp	r6, r7
 800958e:	4639      	mov	r1, r7
 8009590:	d079      	beq.n	8009686 <_malloc_r+0x1e2>
 8009592:	6870      	ldr	r0, [r6, #4]
 8009594:	f020 0003 	bic.w	r0, r0, #3
 8009598:	ebc4 0e00 	rsb	lr, r4, r0
 800959c:	f1be 0f0f 	cmp.w	lr, #15
 80095a0:	dd0d      	ble.n	80095be <_malloc_r+0x11a>
 80095a2:	1933      	adds	r3, r6, r4
 80095a4:	f044 0401 	orr.w	r4, r4, #1
 80095a8:	6074      	str	r4, [r6, #4]
 80095aa:	6153      	str	r3, [r2, #20]
 80095ac:	6113      	str	r3, [r2, #16]
 80095ae:	f04e 0201 	orr.w	r2, lr, #1
 80095b2:	60df      	str	r7, [r3, #12]
 80095b4:	609f      	str	r7, [r3, #8]
 80095b6:	605a      	str	r2, [r3, #4]
 80095b8:	f843 e00e 	str.w	lr, [r3, lr]
 80095bc:	e17b      	b.n	80098b6 <_malloc_r+0x412>
 80095be:	f1be 0f00 	cmp.w	lr, #0
 80095c2:	6157      	str	r7, [r2, #20]
 80095c4:	6117      	str	r7, [r2, #16]
 80095c6:	db05      	blt.n	80095d4 <_malloc_r+0x130>
 80095c8:	4430      	add	r0, r6
 80095ca:	6843      	ldr	r3, [r0, #4]
 80095cc:	f043 0301 	orr.w	r3, r3, #1
 80095d0:	6043      	str	r3, [r0, #4]
 80095d2:	e170      	b.n	80098b6 <_malloc_r+0x412>
 80095d4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80095d8:	d215      	bcs.n	8009606 <_malloc_r+0x162>
 80095da:	08c0      	lsrs	r0, r0, #3
 80095dc:	ea4f 0ea0 	mov.w	lr, r0, asr #2
 80095e0:	2701      	movs	r7, #1
 80095e2:	fa07 fe0e 	lsl.w	lr, r7, lr
 80095e6:	6857      	ldr	r7, [r2, #4]
 80095e8:	3001      	adds	r0, #1
 80095ea:	ea4e 0707 	orr.w	r7, lr, r7
 80095ee:	6057      	str	r7, [r2, #4]
 80095f0:	eb02 07c0 	add.w	r7, r2, r0, lsl #3
 80095f4:	f852 e030 	ldr.w	lr, [r2, r0, lsl #3]
 80095f8:	f8c6 e008 	str.w	lr, [r6, #8]
 80095fc:	3f08      	subs	r7, #8
 80095fe:	60f7      	str	r7, [r6, #12]
 8009600:	f842 6030 	str.w	r6, [r2, r0, lsl #3]
 8009604:	e03d      	b.n	8009682 <_malloc_r+0x1de>
 8009606:	0a42      	lsrs	r2, r0, #9
 8009608:	2a04      	cmp	r2, #4
 800960a:	d802      	bhi.n	8009612 <_malloc_r+0x16e>
 800960c:	0982      	lsrs	r2, r0, #6
 800960e:	3238      	adds	r2, #56	; 0x38
 8009610:	e015      	b.n	800963e <_malloc_r+0x19a>
 8009612:	2a14      	cmp	r2, #20
 8009614:	d801      	bhi.n	800961a <_malloc_r+0x176>
 8009616:	325b      	adds	r2, #91	; 0x5b
 8009618:	e011      	b.n	800963e <_malloc_r+0x19a>
 800961a:	2a54      	cmp	r2, #84	; 0x54
 800961c:	d802      	bhi.n	8009624 <_malloc_r+0x180>
 800961e:	0b02      	lsrs	r2, r0, #12
 8009620:	326e      	adds	r2, #110	; 0x6e
 8009622:	e00c      	b.n	800963e <_malloc_r+0x19a>
 8009624:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8009628:	d802      	bhi.n	8009630 <_malloc_r+0x18c>
 800962a:	0bc2      	lsrs	r2, r0, #15
 800962c:	3277      	adds	r2, #119	; 0x77
 800962e:	e006      	b.n	800963e <_malloc_r+0x19a>
 8009630:	f240 5754 	movw	r7, #1364	; 0x554
 8009634:	42ba      	cmp	r2, r7
 8009636:	bf9a      	itte	ls
 8009638:	0c82      	lsrls	r2, r0, #18
 800963a:	327c      	addls	r2, #124	; 0x7c
 800963c:	227e      	movhi	r2, #126	; 0x7e
 800963e:	1c57      	adds	r7, r2, #1
 8009640:	eb05 0ec2 	add.w	lr, r5, r2, lsl #3
 8009644:	f855 7037 	ldr.w	r7, [r5, r7, lsl #3]
 8009648:	f8df c104 	ldr.w	ip, [pc, #260]	; 8009750 <_malloc_r+0x2ac>
 800964c:	45be      	cmp	lr, r7
 800964e:	d10d      	bne.n	800966c <_malloc_r+0x1c8>
 8009650:	2001      	movs	r0, #1
 8009652:	1092      	asrs	r2, r2, #2
 8009654:	fa00 f202 	lsl.w	r2, r0, r2
 8009658:	f8dc 0004 	ldr.w	r0, [ip, #4]
 800965c:	4310      	orrs	r0, r2
 800965e:	f8cc 0004 	str.w	r0, [ip, #4]
 8009662:	4672      	mov	r2, lr
 8009664:	e009      	b.n	800967a <_malloc_r+0x1d6>
 8009666:	68bf      	ldr	r7, [r7, #8]
 8009668:	45be      	cmp	lr, r7
 800966a:	d004      	beq.n	8009676 <_malloc_r+0x1d2>
 800966c:	687a      	ldr	r2, [r7, #4]
 800966e:	f022 0203 	bic.w	r2, r2, #3
 8009672:	4290      	cmp	r0, r2
 8009674:	d3f7      	bcc.n	8009666 <_malloc_r+0x1c2>
 8009676:	68fa      	ldr	r2, [r7, #12]
 8009678:	46be      	mov	lr, r7
 800967a:	60f2      	str	r2, [r6, #12]
 800967c:	f8c6 e008 	str.w	lr, [r6, #8]
 8009680:	6096      	str	r6, [r2, #8]
 8009682:	f8ce 600c 	str.w	r6, [lr, #12]
 8009686:	2001      	movs	r0, #1
 8009688:	109a      	asrs	r2, r3, #2
 800968a:	fa00 f202 	lsl.w	r2, r0, r2
 800968e:	6868      	ldr	r0, [r5, #4]
 8009690:	4282      	cmp	r2, r0
 8009692:	d85f      	bhi.n	8009754 <_malloc_r+0x2b0>
 8009694:	4202      	tst	r2, r0
 8009696:	d106      	bne.n	80096a6 <_malloc_r+0x202>
 8009698:	f023 0303 	bic.w	r3, r3, #3
 800969c:	0052      	lsls	r2, r2, #1
 800969e:	4202      	tst	r2, r0
 80096a0:	f103 0304 	add.w	r3, r3, #4
 80096a4:	d0fa      	beq.n	800969c <_malloc_r+0x1f8>
 80096a6:	eb05 08c3 	add.w	r8, r5, r3, lsl #3
 80096aa:	46c2      	mov	sl, r8
 80096ac:	469c      	mov	ip, r3
 80096ae:	f8da 600c 	ldr.w	r6, [sl, #12]
 80096b2:	4556      	cmp	r6, sl
 80096b4:	d02c      	beq.n	8009710 <_malloc_r+0x26c>
 80096b6:	6870      	ldr	r0, [r6, #4]
 80096b8:	68f7      	ldr	r7, [r6, #12]
 80096ba:	f020 0003 	bic.w	r0, r0, #3
 80096be:	ebc4 0e00 	rsb	lr, r4, r0
 80096c2:	f1be 0f0f 	cmp.w	lr, #15
 80096c6:	dd11      	ble.n	80096ec <_malloc_r+0x248>
 80096c8:	1933      	adds	r3, r6, r4
 80096ca:	f044 0401 	orr.w	r4, r4, #1
 80096ce:	6074      	str	r4, [r6, #4]
 80096d0:	f856 2f08 	ldr.w	r2, [r6, #8]!
 80096d4:	60d7      	str	r7, [r2, #12]
 80096d6:	60ba      	str	r2, [r7, #8]
 80096d8:	f04e 0201 	orr.w	r2, lr, #1
 80096dc:	616b      	str	r3, [r5, #20]
 80096de:	612b      	str	r3, [r5, #16]
 80096e0:	60d9      	str	r1, [r3, #12]
 80096e2:	6099      	str	r1, [r3, #8]
 80096e4:	605a      	str	r2, [r3, #4]
 80096e6:	f843 e00e 	str.w	lr, [r3, lr]
 80096ea:	e00b      	b.n	8009704 <_malloc_r+0x260>
 80096ec:	f1be 0f00 	cmp.w	lr, #0
 80096f0:	db0c      	blt.n	800970c <_malloc_r+0x268>
 80096f2:	1833      	adds	r3, r6, r0
 80096f4:	685a      	ldr	r2, [r3, #4]
 80096f6:	f042 0201 	orr.w	r2, r2, #1
 80096fa:	605a      	str	r2, [r3, #4]
 80096fc:	f856 3f08 	ldr.w	r3, [r6, #8]!
 8009700:	60df      	str	r7, [r3, #12]
 8009702:	60bb      	str	r3, [r7, #8]
 8009704:	4648      	mov	r0, r9
 8009706:	f000 f8ee 	bl	80098e6 <__malloc_unlock>
 800970a:	e0d8      	b.n	80098be <_malloc_r+0x41a>
 800970c:	463e      	mov	r6, r7
 800970e:	e7d0      	b.n	80096b2 <_malloc_r+0x20e>
 8009710:	f10c 0c01 	add.w	ip, ip, #1
 8009714:	f01c 0f03 	tst.w	ip, #3
 8009718:	f10a 0a08 	add.w	sl, sl, #8
 800971c:	d1c7      	bne.n	80096ae <_malloc_r+0x20a>
 800971e:	0798      	lsls	r0, r3, #30
 8009720:	d104      	bne.n	800972c <_malloc_r+0x288>
 8009722:	686b      	ldr	r3, [r5, #4]
 8009724:	ea23 0302 	bic.w	r3, r3, r2
 8009728:	606b      	str	r3, [r5, #4]
 800972a:	e005      	b.n	8009738 <_malloc_r+0x294>
 800972c:	f858 0908 	ldr.w	r0, [r8], #-8
 8009730:	4580      	cmp	r8, r0
 8009732:	f103 33ff 	add.w	r3, r3, #4294967295
 8009736:	d0f2      	beq.n	800971e <_malloc_r+0x27a>
 8009738:	6868      	ldr	r0, [r5, #4]
 800973a:	0052      	lsls	r2, r2, #1
 800973c:	4282      	cmp	r2, r0
 800973e:	d809      	bhi.n	8009754 <_malloc_r+0x2b0>
 8009740:	b142      	cbz	r2, 8009754 <_malloc_r+0x2b0>
 8009742:	4663      	mov	r3, ip
 8009744:	4202      	tst	r2, r0
 8009746:	d1ae      	bne.n	80096a6 <_malloc_r+0x202>
 8009748:	3304      	adds	r3, #4
 800974a:	0052      	lsls	r2, r2, #1
 800974c:	e7fa      	b.n	8009744 <_malloc_r+0x2a0>
 800974e:	bf00      	nop
 8009750:	20000164 	.word	0x20000164
 8009754:	f8d5 b008 	ldr.w	fp, [r5, #8]
 8009758:	f8db 6004 	ldr.w	r6, [fp, #4]
 800975c:	f026 0603 	bic.w	r6, r6, #3
 8009760:	42b4      	cmp	r4, r6
 8009762:	d803      	bhi.n	800976c <_malloc_r+0x2c8>
 8009764:	1b33      	subs	r3, r6, r4
 8009766:	2b0f      	cmp	r3, #15
 8009768:	f300 809c 	bgt.w	80098a4 <_malloc_r+0x400>
 800976c:	4a56      	ldr	r2, [pc, #344]	; (80098c8 <_malloc_r+0x424>)
 800976e:	4957      	ldr	r1, [pc, #348]	; (80098cc <_malloc_r+0x428>)
 8009770:	6812      	ldr	r2, [r2, #0]
 8009772:	6808      	ldr	r0, [r1, #0]
 8009774:	9101      	str	r1, [sp, #4]
 8009776:	f102 0810 	add.w	r8, r2, #16
 800977a:	4a55      	ldr	r2, [pc, #340]	; (80098d0 <_malloc_r+0x42c>)
 800977c:	9203      	str	r2, [sp, #12]
 800977e:	3001      	adds	r0, #1
 8009780:	bf18      	it	ne
 8009782:	f102 31ff 	addne.w	r1, r2, #4294967295
 8009786:	44a0      	add	r8, r4
 8009788:	bf1e      	ittt	ne
 800978a:	4488      	addne	r8, r1
 800978c:	4251      	negne	r1, r2
 800978e:	ea01 0808 	andne.w	r8, r1, r8
 8009792:	eb0b 0306 	add.w	r3, fp, r6
 8009796:	4641      	mov	r1, r8
 8009798:	4648      	mov	r0, r9
 800979a:	9302      	str	r3, [sp, #8]
 800979c:	f000 f8a4 	bl	80098e8 <_sbrk_r>
 80097a0:	1c42      	adds	r2, r0, #1
 80097a2:	4607      	mov	r7, r0
 80097a4:	d06f      	beq.n	8009886 <_malloc_r+0x3e2>
 80097a6:	9b02      	ldr	r3, [sp, #8]
 80097a8:	9a03      	ldr	r2, [sp, #12]
 80097aa:	4283      	cmp	r3, r0
 80097ac:	d901      	bls.n	80097b2 <_malloc_r+0x30e>
 80097ae:	45ab      	cmp	fp, r5
 80097b0:	d169      	bne.n	8009886 <_malloc_r+0x3e2>
 80097b2:	f8df a128 	ldr.w	sl, [pc, #296]	; 80098dc <_malloc_r+0x438>
 80097b6:	f8df c128 	ldr.w	ip, [pc, #296]	; 80098e0 <_malloc_r+0x43c>
 80097ba:	f8da 0000 	ldr.w	r0, [sl]
 80097be:	42bb      	cmp	r3, r7
 80097c0:	4440      	add	r0, r8
 80097c2:	f8ca 0000 	str.w	r0, [sl]
 80097c6:	d108      	bne.n	80097da <_malloc_r+0x336>
 80097c8:	ea13 0f0c 	tst.w	r3, ip
 80097cc:	d105      	bne.n	80097da <_malloc_r+0x336>
 80097ce:	68ab      	ldr	r3, [r5, #8]
 80097d0:	4446      	add	r6, r8
 80097d2:	f046 0601 	orr.w	r6, r6, #1
 80097d6:	605e      	str	r6, [r3, #4]
 80097d8:	e049      	b.n	800986e <_malloc_r+0x3ca>
 80097da:	9901      	ldr	r1, [sp, #4]
 80097dc:	f8d1 e000 	ldr.w	lr, [r1]
 80097e0:	f1be 3fff 	cmp.w	lr, #4294967295
 80097e4:	bf15      	itete	ne
 80097e6:	1afb      	subne	r3, r7, r3
 80097e8:	4b38      	ldreq	r3, [pc, #224]	; (80098cc <_malloc_r+0x428>)
 80097ea:	181b      	addne	r3, r3, r0
 80097ec:	601f      	streq	r7, [r3, #0]
 80097ee:	bf18      	it	ne
 80097f0:	f8ca 3000 	strne.w	r3, [sl]
 80097f4:	f017 0307 	ands.w	r3, r7, #7
 80097f8:	bf1c      	itt	ne
 80097fa:	f1c3 0308 	rsbne	r3, r3, #8
 80097fe:	18ff      	addne	r7, r7, r3
 8009800:	44b8      	add	r8, r7
 8009802:	441a      	add	r2, r3
 8009804:	ea08 080c 	and.w	r8, r8, ip
 8009808:	ebc8 0802 	rsb	r8, r8, r2
 800980c:	4641      	mov	r1, r8
 800980e:	4648      	mov	r0, r9
 8009810:	f000 f86a 	bl	80098e8 <_sbrk_r>
 8009814:	1c43      	adds	r3, r0, #1
 8009816:	bf04      	itt	eq
 8009818:	4638      	moveq	r0, r7
 800981a:	f04f 0800 	moveq.w	r8, #0
 800981e:	f8da 3000 	ldr.w	r3, [sl]
 8009822:	60af      	str	r7, [r5, #8]
 8009824:	1bc2      	subs	r2, r0, r7
 8009826:	4442      	add	r2, r8
 8009828:	4443      	add	r3, r8
 800982a:	f042 0201 	orr.w	r2, r2, #1
 800982e:	45ab      	cmp	fp, r5
 8009830:	f8ca 3000 	str.w	r3, [sl]
 8009834:	607a      	str	r2, [r7, #4]
 8009836:	d01a      	beq.n	800986e <_malloc_r+0x3ca>
 8009838:	2e0f      	cmp	r6, #15
 800983a:	d802      	bhi.n	8009842 <_malloc_r+0x39e>
 800983c:	2301      	movs	r3, #1
 800983e:	607b      	str	r3, [r7, #4]
 8009840:	e021      	b.n	8009886 <_malloc_r+0x3e2>
 8009842:	f8db 3004 	ldr.w	r3, [fp, #4]
 8009846:	3e0c      	subs	r6, #12
 8009848:	f026 0607 	bic.w	r6, r6, #7
 800984c:	f003 0301 	and.w	r3, r3, #1
 8009850:	4333      	orrs	r3, r6
 8009852:	f8cb 3004 	str.w	r3, [fp, #4]
 8009856:	eb0b 0306 	add.w	r3, fp, r6
 800985a:	2205      	movs	r2, #5
 800985c:	2e0f      	cmp	r6, #15
 800985e:	605a      	str	r2, [r3, #4]
 8009860:	609a      	str	r2, [r3, #8]
 8009862:	d904      	bls.n	800986e <_malloc_r+0x3ca>
 8009864:	f10b 0108 	add.w	r1, fp, #8
 8009868:	4648      	mov	r0, r9
 800986a:	f000 f8a3 	bl	80099b4 <_free_r>
 800986e:	4a19      	ldr	r2, [pc, #100]	; (80098d4 <_malloc_r+0x430>)
 8009870:	f8da 3000 	ldr.w	r3, [sl]
 8009874:	6811      	ldr	r1, [r2, #0]
 8009876:	428b      	cmp	r3, r1
 8009878:	bf88      	it	hi
 800987a:	6013      	strhi	r3, [r2, #0]
 800987c:	4a16      	ldr	r2, [pc, #88]	; (80098d8 <_malloc_r+0x434>)
 800987e:	6811      	ldr	r1, [r2, #0]
 8009880:	428b      	cmp	r3, r1
 8009882:	bf88      	it	hi
 8009884:	6013      	strhi	r3, [r2, #0]
 8009886:	68ab      	ldr	r3, [r5, #8]
 8009888:	685a      	ldr	r2, [r3, #4]
 800988a:	f022 0203 	bic.w	r2, r2, #3
 800988e:	4294      	cmp	r4, r2
 8009890:	eba2 0304 	sub.w	r3, r2, r4
 8009894:	d801      	bhi.n	800989a <_malloc_r+0x3f6>
 8009896:	2b0f      	cmp	r3, #15
 8009898:	dc04      	bgt.n	80098a4 <_malloc_r+0x400>
 800989a:	4648      	mov	r0, r9
 800989c:	f000 f823 	bl	80098e6 <__malloc_unlock>
 80098a0:	2600      	movs	r6, #0
 80098a2:	e00c      	b.n	80098be <_malloc_r+0x41a>
 80098a4:	68ae      	ldr	r6, [r5, #8]
 80098a6:	f044 0201 	orr.w	r2, r4, #1
 80098aa:	4434      	add	r4, r6
 80098ac:	f043 0301 	orr.w	r3, r3, #1
 80098b0:	6072      	str	r2, [r6, #4]
 80098b2:	60ac      	str	r4, [r5, #8]
 80098b4:	6063      	str	r3, [r4, #4]
 80098b6:	4648      	mov	r0, r9
 80098b8:	f000 f815 	bl	80098e6 <__malloc_unlock>
 80098bc:	3608      	adds	r6, #8
 80098be:	4630      	mov	r0, r6
 80098c0:	b005      	add	sp, #20
 80098c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80098c6:	bf00      	nop
 80098c8:	200020b8 	.word	0x200020b8
 80098cc:	20000570 	.word	0x20000570
 80098d0:	00000080 	.word	0x00000080
 80098d4:	200020b4 	.word	0x200020b4
 80098d8:	200020b0 	.word	0x200020b0
 80098dc:	200020bc 	.word	0x200020bc
 80098e0:	0000007f 	.word	0x0000007f

080098e4 <__malloc_lock>:
 80098e4:	4770      	bx	lr

080098e6 <__malloc_unlock>:
 80098e6:	4770      	bx	lr

080098e8 <_sbrk_r>:
 80098e8:	b538      	push	{r3, r4, r5, lr}
 80098ea:	4c06      	ldr	r4, [pc, #24]	; (8009904 <_sbrk_r+0x1c>)
 80098ec:	2300      	movs	r3, #0
 80098ee:	4605      	mov	r5, r0
 80098f0:	4608      	mov	r0, r1
 80098f2:	6023      	str	r3, [r4, #0]
 80098f4:	f000 f91c 	bl	8009b30 <_sbrk>
 80098f8:	1c43      	adds	r3, r0, #1
 80098fa:	d102      	bne.n	8009902 <_sbrk_r+0x1a>
 80098fc:	6823      	ldr	r3, [r4, #0]
 80098fe:	b103      	cbz	r3, 8009902 <_sbrk_r+0x1a>
 8009900:	602b      	str	r3, [r5, #0]
 8009902:	bd38      	pop	{r3, r4, r5, pc}
 8009904:	2002240c 	.word	0x2002240c

08009908 <_malloc_trim_r>:
 8009908:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800990c:	4f25      	ldr	r7, [pc, #148]	; (80099a4 <_malloc_trim_r+0x9c>)
 800990e:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 80099b0 <_malloc_trim_r+0xa8>
 8009912:	4689      	mov	r9, r1
 8009914:	4606      	mov	r6, r0
 8009916:	f7ff ffe5 	bl	80098e4 <__malloc_lock>
 800991a:	68bb      	ldr	r3, [r7, #8]
 800991c:	685d      	ldr	r5, [r3, #4]
 800991e:	f1a8 0411 	sub.w	r4, r8, #17
 8009922:	f025 0503 	bic.w	r5, r5, #3
 8009926:	442c      	add	r4, r5
 8009928:	ebc9 0404 	rsb	r4, r9, r4
 800992c:	fbb4 f4f8 	udiv	r4, r4, r8
 8009930:	3c01      	subs	r4, #1
 8009932:	fb08 f404 	mul.w	r4, r8, r4
 8009936:	4544      	cmp	r4, r8
 8009938:	da05      	bge.n	8009946 <_malloc_trim_r+0x3e>
 800993a:	4630      	mov	r0, r6
 800993c:	f7ff ffd3 	bl	80098e6 <__malloc_unlock>
 8009940:	2000      	movs	r0, #0
 8009942:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8009946:	2100      	movs	r1, #0
 8009948:	4630      	mov	r0, r6
 800994a:	f7ff ffcd 	bl	80098e8 <_sbrk_r>
 800994e:	68bb      	ldr	r3, [r7, #8]
 8009950:	442b      	add	r3, r5
 8009952:	4298      	cmp	r0, r3
 8009954:	d1f1      	bne.n	800993a <_malloc_trim_r+0x32>
 8009956:	4261      	negs	r1, r4
 8009958:	4630      	mov	r0, r6
 800995a:	f7ff ffc5 	bl	80098e8 <_sbrk_r>
 800995e:	3001      	adds	r0, #1
 8009960:	d110      	bne.n	8009984 <_malloc_trim_r+0x7c>
 8009962:	2100      	movs	r1, #0
 8009964:	4630      	mov	r0, r6
 8009966:	f7ff ffbf 	bl	80098e8 <_sbrk_r>
 800996a:	68ba      	ldr	r2, [r7, #8]
 800996c:	1a83      	subs	r3, r0, r2
 800996e:	2b0f      	cmp	r3, #15
 8009970:	dde3      	ble.n	800993a <_malloc_trim_r+0x32>
 8009972:	490d      	ldr	r1, [pc, #52]	; (80099a8 <_malloc_trim_r+0xa0>)
 8009974:	6809      	ldr	r1, [r1, #0]
 8009976:	1a40      	subs	r0, r0, r1
 8009978:	490c      	ldr	r1, [pc, #48]	; (80099ac <_malloc_trim_r+0xa4>)
 800997a:	f043 0301 	orr.w	r3, r3, #1
 800997e:	6008      	str	r0, [r1, #0]
 8009980:	6053      	str	r3, [r2, #4]
 8009982:	e7da      	b.n	800993a <_malloc_trim_r+0x32>
 8009984:	68bb      	ldr	r3, [r7, #8]
 8009986:	4a09      	ldr	r2, [pc, #36]	; (80099ac <_malloc_trim_r+0xa4>)
 8009988:	1b2d      	subs	r5, r5, r4
 800998a:	f045 0501 	orr.w	r5, r5, #1
 800998e:	605d      	str	r5, [r3, #4]
 8009990:	6813      	ldr	r3, [r2, #0]
 8009992:	4630      	mov	r0, r6
 8009994:	1b1c      	subs	r4, r3, r4
 8009996:	6014      	str	r4, [r2, #0]
 8009998:	f7ff ffa5 	bl	80098e6 <__malloc_unlock>
 800999c:	2001      	movs	r0, #1
 800999e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80099a2:	bf00      	nop
 80099a4:	20000164 	.word	0x20000164
 80099a8:	20000570 	.word	0x20000570
 80099ac:	200020bc 	.word	0x200020bc
 80099b0:	00000080 	.word	0x00000080

080099b4 <_free_r>:
 80099b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80099b8:	4604      	mov	r4, r0
 80099ba:	4688      	mov	r8, r1
 80099bc:	2900      	cmp	r1, #0
 80099be:	f000 80ad 	beq.w	8009b1c <_free_r+0x168>
 80099c2:	f7ff ff8f 	bl	80098e4 <__malloc_lock>
 80099c6:	f858 2c04 	ldr.w	r2, [r8, #-4]
 80099ca:	4d55      	ldr	r5, [pc, #340]	; (8009b20 <_free_r+0x16c>)
 80099cc:	f022 0001 	bic.w	r0, r2, #1
 80099d0:	f1a8 0308 	sub.w	r3, r8, #8
 80099d4:	181f      	adds	r7, r3, r0
 80099d6:	68a9      	ldr	r1, [r5, #8]
 80099d8:	687e      	ldr	r6, [r7, #4]
 80099da:	428f      	cmp	r7, r1
 80099dc:	f026 0603 	bic.w	r6, r6, #3
 80099e0:	f002 0201 	and.w	r2, r2, #1
 80099e4:	d11b      	bne.n	8009a1e <_free_r+0x6a>
 80099e6:	4430      	add	r0, r6
 80099e8:	b93a      	cbnz	r2, 80099fa <_free_r+0x46>
 80099ea:	f858 2c08 	ldr.w	r2, [r8, #-8]
 80099ee:	1a9b      	subs	r3, r3, r2
 80099f0:	4410      	add	r0, r2
 80099f2:	6899      	ldr	r1, [r3, #8]
 80099f4:	68da      	ldr	r2, [r3, #12]
 80099f6:	60ca      	str	r2, [r1, #12]
 80099f8:	6091      	str	r1, [r2, #8]
 80099fa:	f040 0201 	orr.w	r2, r0, #1
 80099fe:	605a      	str	r2, [r3, #4]
 8009a00:	60ab      	str	r3, [r5, #8]
 8009a02:	4b48      	ldr	r3, [pc, #288]	; (8009b24 <_free_r+0x170>)
 8009a04:	681b      	ldr	r3, [r3, #0]
 8009a06:	4298      	cmp	r0, r3
 8009a08:	d304      	bcc.n	8009a14 <_free_r+0x60>
 8009a0a:	4b47      	ldr	r3, [pc, #284]	; (8009b28 <_free_r+0x174>)
 8009a0c:	4620      	mov	r0, r4
 8009a0e:	6819      	ldr	r1, [r3, #0]
 8009a10:	f7ff ff7a 	bl	8009908 <_malloc_trim_r>
 8009a14:	4620      	mov	r0, r4
 8009a16:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8009a1a:	f7ff bf64 	b.w	80098e6 <__malloc_unlock>
 8009a1e:	607e      	str	r6, [r7, #4]
 8009a20:	b97a      	cbnz	r2, 8009a42 <_free_r+0x8e>
 8009a22:	f858 1c08 	ldr.w	r1, [r8, #-8]
 8009a26:	1a5b      	subs	r3, r3, r1
 8009a28:	4408      	add	r0, r1
 8009a2a:	6899      	ldr	r1, [r3, #8]
 8009a2c:	f105 0e08 	add.w	lr, r5, #8
 8009a30:	4571      	cmp	r1, lr
 8009a32:	d008      	beq.n	8009a46 <_free_r+0x92>
 8009a34:	f8d3 e00c 	ldr.w	lr, [r3, #12]
 8009a38:	f8c1 e00c 	str.w	lr, [r1, #12]
 8009a3c:	f8ce 1008 	str.w	r1, [lr, #8]
 8009a40:	e002      	b.n	8009a48 <_free_r+0x94>
 8009a42:	2200      	movs	r2, #0
 8009a44:	e000      	b.n	8009a48 <_free_r+0x94>
 8009a46:	2201      	movs	r2, #1
 8009a48:	19b9      	adds	r1, r7, r6
 8009a4a:	6849      	ldr	r1, [r1, #4]
 8009a4c:	07c9      	lsls	r1, r1, #31
 8009a4e:	d40e      	bmi.n	8009a6e <_free_r+0xba>
 8009a50:	4430      	add	r0, r6
 8009a52:	68b9      	ldr	r1, [r7, #8]
 8009a54:	b942      	cbnz	r2, 8009a68 <_free_r+0xb4>
 8009a56:	4e35      	ldr	r6, [pc, #212]	; (8009b2c <_free_r+0x178>)
 8009a58:	42b1      	cmp	r1, r6
 8009a5a:	d105      	bne.n	8009a68 <_free_r+0xb4>
 8009a5c:	616b      	str	r3, [r5, #20]
 8009a5e:	612b      	str	r3, [r5, #16]
 8009a60:	2201      	movs	r2, #1
 8009a62:	60d9      	str	r1, [r3, #12]
 8009a64:	6099      	str	r1, [r3, #8]
 8009a66:	e002      	b.n	8009a6e <_free_r+0xba>
 8009a68:	68fe      	ldr	r6, [r7, #12]
 8009a6a:	60ce      	str	r6, [r1, #12]
 8009a6c:	60b1      	str	r1, [r6, #8]
 8009a6e:	f040 0101 	orr.w	r1, r0, #1
 8009a72:	6059      	str	r1, [r3, #4]
 8009a74:	5018      	str	r0, [r3, r0]
 8009a76:	2a00      	cmp	r2, #0
 8009a78:	d1cc      	bne.n	8009a14 <_free_r+0x60>
 8009a7a:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8009a7e:	d212      	bcs.n	8009aa6 <_free_r+0xf2>
 8009a80:	08c0      	lsrs	r0, r0, #3
 8009a82:	1081      	asrs	r1, r0, #2
 8009a84:	2201      	movs	r2, #1
 8009a86:	fa02 f101 	lsl.w	r1, r2, r1
 8009a8a:	686a      	ldr	r2, [r5, #4]
 8009a8c:	3001      	adds	r0, #1
 8009a8e:	430a      	orrs	r2, r1
 8009a90:	606a      	str	r2, [r5, #4]
 8009a92:	eb05 02c0 	add.w	r2, r5, r0, lsl #3
 8009a96:	f855 1030 	ldr.w	r1, [r5, r0, lsl #3]
 8009a9a:	6099      	str	r1, [r3, #8]
 8009a9c:	3a08      	subs	r2, #8
 8009a9e:	60da      	str	r2, [r3, #12]
 8009aa0:	f845 3030 	str.w	r3, [r5, r0, lsl #3]
 8009aa4:	e038      	b.n	8009b18 <_free_r+0x164>
 8009aa6:	0a42      	lsrs	r2, r0, #9
 8009aa8:	2a04      	cmp	r2, #4
 8009aaa:	d802      	bhi.n	8009ab2 <_free_r+0xfe>
 8009aac:	0982      	lsrs	r2, r0, #6
 8009aae:	3238      	adds	r2, #56	; 0x38
 8009ab0:	e015      	b.n	8009ade <_free_r+0x12a>
 8009ab2:	2a14      	cmp	r2, #20
 8009ab4:	d801      	bhi.n	8009aba <_free_r+0x106>
 8009ab6:	325b      	adds	r2, #91	; 0x5b
 8009ab8:	e011      	b.n	8009ade <_free_r+0x12a>
 8009aba:	2a54      	cmp	r2, #84	; 0x54
 8009abc:	d802      	bhi.n	8009ac4 <_free_r+0x110>
 8009abe:	0b02      	lsrs	r2, r0, #12
 8009ac0:	326e      	adds	r2, #110	; 0x6e
 8009ac2:	e00c      	b.n	8009ade <_free_r+0x12a>
 8009ac4:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 8009ac8:	d802      	bhi.n	8009ad0 <_free_r+0x11c>
 8009aca:	0bc2      	lsrs	r2, r0, #15
 8009acc:	3277      	adds	r2, #119	; 0x77
 8009ace:	e006      	b.n	8009ade <_free_r+0x12a>
 8009ad0:	f240 5154 	movw	r1, #1364	; 0x554
 8009ad4:	428a      	cmp	r2, r1
 8009ad6:	bf9a      	itte	ls
 8009ad8:	0c82      	lsrls	r2, r0, #18
 8009ada:	327c      	addls	r2, #124	; 0x7c
 8009adc:	227e      	movhi	r2, #126	; 0x7e
 8009ade:	1c51      	adds	r1, r2, #1
 8009ae0:	eb05 06c2 	add.w	r6, r5, r2, lsl #3
 8009ae4:	f855 1031 	ldr.w	r1, [r5, r1, lsl #3]
 8009ae8:	4f0d      	ldr	r7, [pc, #52]	; (8009b20 <_free_r+0x16c>)
 8009aea:	428e      	cmp	r6, r1
 8009aec:	d10b      	bne.n	8009b06 <_free_r+0x152>
 8009aee:	2101      	movs	r1, #1
 8009af0:	1092      	asrs	r2, r2, #2
 8009af2:	fa01 f202 	lsl.w	r2, r1, r2
 8009af6:	6879      	ldr	r1, [r7, #4]
 8009af8:	4311      	orrs	r1, r2
 8009afa:	6079      	str	r1, [r7, #4]
 8009afc:	4631      	mov	r1, r6
 8009afe:	e008      	b.n	8009b12 <_free_r+0x15e>
 8009b00:	6889      	ldr	r1, [r1, #8]
 8009b02:	428e      	cmp	r6, r1
 8009b04:	d004      	beq.n	8009b10 <_free_r+0x15c>
 8009b06:	684a      	ldr	r2, [r1, #4]
 8009b08:	f022 0203 	bic.w	r2, r2, #3
 8009b0c:	4290      	cmp	r0, r2
 8009b0e:	d3f7      	bcc.n	8009b00 <_free_r+0x14c>
 8009b10:	68ce      	ldr	r6, [r1, #12]
 8009b12:	60de      	str	r6, [r3, #12]
 8009b14:	6099      	str	r1, [r3, #8]
 8009b16:	60b3      	str	r3, [r6, #8]
 8009b18:	60cb      	str	r3, [r1, #12]
 8009b1a:	e77b      	b.n	8009a14 <_free_r+0x60>
 8009b1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009b20:	20000164 	.word	0x20000164
 8009b24:	2000056c 	.word	0x2000056c
 8009b28:	200020b8 	.word	0x200020b8
 8009b2c:	2000016c 	.word	0x2000016c

08009b30 <_sbrk>:
 8009b30:	4b04      	ldr	r3, [pc, #16]	; (8009b44 <_sbrk+0x14>)
 8009b32:	6819      	ldr	r1, [r3, #0]
 8009b34:	4602      	mov	r2, r0
 8009b36:	b909      	cbnz	r1, 8009b3c <_sbrk+0xc>
 8009b38:	4903      	ldr	r1, [pc, #12]	; (8009b48 <_sbrk+0x18>)
 8009b3a:	6019      	str	r1, [r3, #0]
 8009b3c:	6818      	ldr	r0, [r3, #0]
 8009b3e:	4402      	add	r2, r0
 8009b40:	601a      	str	r2, [r3, #0]
 8009b42:	4770      	bx	lr
 8009b44:	200020e4 	.word	0x200020e4
 8009b48:	20022410 	.word	0x20022410

08009b4c <_init>:
 8009b4c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009b4e:	bf00      	nop
 8009b50:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009b52:	bc08      	pop	{r3}
 8009b54:	469e      	mov	lr, r3
 8009b56:	4770      	bx	lr

08009b58 <_fini>:
 8009b58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009b5a:	bf00      	nop
 8009b5c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009b5e:	bc08      	pop	{r3}
 8009b60:	469e      	mov	lr, r3
 8009b62:	4770      	bx	lr
